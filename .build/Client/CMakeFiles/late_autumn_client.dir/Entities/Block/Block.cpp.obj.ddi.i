# 0 "D:/Institute/Third_year/PZ_Networks/1_3/Client/Entities/Block/Block.cpp"
# 1 "D:\\Institute\\Third_year\\PZ_Networks\\1_3\\.build//"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "D:/Institute/Third_year/PZ_Networks/1_3/Client/Entities/Block/Block.cpp"
# 1 "D:/Institute/Third_year/PZ_Networks/1_3/Client/Entities/Block/Block.h" 1


# 1 "D:/Institute/Third_year/PZ_Networks/1_3/Client/Entities/Entity/Entity.h" 1


# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_rect.h" 1
# 32 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_rect.h"
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h" 1
# 35 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_platform_defines.h" 1
# 36 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h" 2

# 1 "D:/Programs/MinGW/lib/gcc/x86_64-w64-mingw32/14.2.0/include/stdarg.h" 1 3 4
# 1 "D:/Programs/MinGW/x86_64-w64-mingw32/include/stdarg.h" 1 3 4
# 45 "D:/Programs/MinGW/x86_64-w64-mingw32/include/stdarg.h" 3 4

# 45 "D:/Programs/MinGW/x86_64-w64-mingw32/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 107 "D:/Programs/MinGW/x86_64-w64-mingw32/include/stdarg.h" 3 4
typedef __gnuc_va_list va_list;
# 140 "D:/Programs/MinGW/x86_64-w64-mingw32/include/stdarg.h" 3 4
# 1 "D:/Programs/MinGW/x86_64-w64-mingw32/include/_mingw_stdarg.h" 1 3 4
# 14 "D:/Programs/MinGW/x86_64-w64-mingw32/include/_mingw_stdarg.h" 3 4
# 1 "D:/Programs/MinGW/x86_64-w64-mingw32/include/vadefs.h" 1 3 4
# 9 "D:/Programs/MinGW/x86_64-w64-mingw32/include/vadefs.h" 3 4
# 1 "D:/Programs/MinGW/x86_64-w64-mingw32/include/_mingw.h" 1 3 4
# 10 "D:/Programs/MinGW/x86_64-w64-mingw32/include/_mingw.h" 3 4
# 1 "D:/Programs/MinGW/x86_64-w64-mingw32/include/_mingw_mac.h" 1 3 4
# 98 "D:/Programs/MinGW/x86_64-w64-mingw32/include/_mingw_mac.h" 3 4
             
# 107 "D:/Programs/MinGW/x86_64-w64-mingw32/include/_mingw_mac.h" 3 4
             
# 316 "D:/Programs/MinGW/x86_64-w64-mingw32/include/_mingw_mac.h" 3 4
       
# 395 "D:/Programs/MinGW/x86_64-w64-mingw32/include/_mingw_mac.h" 3 4
       
# 11 "D:/Programs/MinGW/x86_64-w64-mingw32/include/_mingw.h" 2 3 4
# 1 "D:/Programs/MinGW/x86_64-w64-mingw32/include/_mingw_secapi.h" 1 3 4
# 44 "D:/Programs/MinGW/x86_64-w64-mingw32/include/_mingw_secapi.h" 3 4
extern "C++" {
template <bool __test, typename __dsttype>
  struct __if_array;
template <typename __dsttype>
  struct __if_array <true, __dsttype> {
    typedef __dsttype __type;
};
}
# 12 "D:/Programs/MinGW/x86_64-w64-mingw32/include/_mingw.h" 2 3 4
# 282 "D:/Programs/MinGW/x86_64-w64-mingw32/include/_mingw.h" 3 4
# 1 "D:/Programs/MinGW/x86_64-w64-mingw32/include/vadefs.h" 1 3 4
# 283 "D:/Programs/MinGW/x86_64-w64-mingw32/include/_mingw.h" 2 3 4
# 568 "D:/Programs/MinGW/x86_64-w64-mingw32/include/_mingw.h" 3 4
extern "C" {
# 580 "D:/Programs/MinGW/x86_64-w64-mingw32/include/_mingw.h" 3 4
void __attribute__((__cdecl__)) __debugbreak(void);
extern __inline__ __attribute__((__always_inline__,__gnu_inline__)) void __attribute__((__cdecl__)) __debugbreak(void)
{

  __asm__ __volatile__("int {$}3":);







}
# 601 "D:/Programs/MinGW/x86_64-w64-mingw32/include/_mingw.h" 3 4
void __attribute__((__cdecl__)) __attribute__ ((__noreturn__)) __fastfail(unsigned int code);
extern __inline__ __attribute__((__always_inline__,__gnu_inline__)) void __attribute__((__cdecl__)) __attribute__ ((__noreturn__)) __fastfail(unsigned int code)
{

  __asm__ __volatile__("int {$}0x29"::"c"(code));
# 615 "D:/Programs/MinGW/x86_64-w64-mingw32/include/_mingw.h" 3 4
  __builtin_unreachable();
}
# 641 "D:/Programs/MinGW/x86_64-w64-mingw32/include/_mingw.h" 3 4
const char *__mingw_get_crt_info (void);


}
# 661 "D:/Programs/MinGW/x86_64-w64-mingw32/include/_mingw.h" 3 4
# 1 "D:/Programs/MinGW/x86_64-w64-mingw32/include/sdks/_mingw_ddk.h" 1 3 4
# 662 "D:/Programs/MinGW/x86_64-w64-mingw32/include/_mingw.h" 2 3 4
# 10 "D:/Programs/MinGW/x86_64-w64-mingw32/include/vadefs.h" 2 3 4




#pragma pack(push,_CRT_PACKING)



extern "C" {
# 99 "D:/Programs/MinGW/x86_64-w64-mingw32/include/vadefs.h" 3 4
}



#pragma pack(pop)
# 15 "D:/Programs/MinGW/x86_64-w64-mingw32/include/_mingw_stdarg.h" 2 3 4
# 141 "D:/Programs/MinGW/x86_64-w64-mingw32/include/stdarg.h" 2 3 4
# 2 "D:/Programs/MinGW/lib/gcc/x86_64-w64-mingw32/14.2.0/include/stdarg.h" 2 3 4
# 38 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h" 2
# 1 "D:/Programs/MinGW/lib/gcc/x86_64-w64-mingw32/14.2.0/include/stdint.h" 1 3 4
# 9 "D:/Programs/MinGW/lib/gcc/x86_64-w64-mingw32/14.2.0/include/stdint.h" 3 4
# 1 "D:/Programs/MinGW/x86_64-w64-mingw32/include/stdint.h" 1 3 4
# 28 "D:/Programs/MinGW/x86_64-w64-mingw32/include/stdint.h" 3 4
# 1 "D:/Programs/MinGW/x86_64-w64-mingw32/include/crtdefs.h" 1 3 4
# 10 "D:/Programs/MinGW/x86_64-w64-mingw32/include/crtdefs.h" 3 4
# 1 "D:/Programs/MinGW/x86_64-w64-mingw32/include/corecrt.h" 1 3 4
# 10 "D:/Programs/MinGW/x86_64-w64-mingw32/include/corecrt.h" 3 4
# 1 "D:/Programs/MinGW/x86_64-w64-mingw32/include/_mingw.h" 1 3 4
# 11 "D:/Programs/MinGW/x86_64-w64-mingw32/include/corecrt.h" 2 3 4




#pragma pack(push,_CRT_PACKING)
# 35 "D:/Programs/MinGW/x86_64-w64-mingw32/include/corecrt.h" 3 4
__extension__ typedef unsigned long long size_t;
# 45 "D:/Programs/MinGW/x86_64-w64-mingw32/include/corecrt.h" 3 4
__extension__ typedef long long ssize_t;






typedef size_t rsize_t;
# 62 "D:/Programs/MinGW/x86_64-w64-mingw32/include/corecrt.h" 3 4
__extension__ typedef long long intptr_t;
# 75 "D:/Programs/MinGW/x86_64-w64-mingw32/include/corecrt.h" 3 4
__extension__ typedef unsigned long long uintptr_t;
# 88 "D:/Programs/MinGW/x86_64-w64-mingw32/include/corecrt.h" 3 4
__extension__ typedef long long ptrdiff_t;
# 106 "D:/Programs/MinGW/x86_64-w64-mingw32/include/corecrt.h" 3 4
typedef unsigned short wint_t;
typedef unsigned short wctype_t;





typedef int errno_t;




typedef long __time32_t;




__extension__ typedef long long __time64_t;
# 138 "D:/Programs/MinGW/x86_64-w64-mingw32/include/corecrt.h" 3 4
typedef __time64_t time_t;
# 430 "D:/Programs/MinGW/x86_64-w64-mingw32/include/corecrt.h" 3 4
struct threadlocaleinfostruct;
struct threadmbcinfostruct;
typedef struct threadlocaleinfostruct *pthreadlocinfo;
typedef struct threadmbcinfostruct *pthreadmbcinfo;
struct __lc_time_data;

typedef struct localeinfo_struct {
  pthreadlocinfo locinfo;
  pthreadmbcinfo mbcinfo;
} _locale_tstruct,*_locale_t;



typedef struct tagLC_ID {
  unsigned short wLanguage;
  unsigned short wCountry;
  unsigned short wCodePage;
} LC_ID,*LPLC_ID;




typedef struct threadlocaleinfostruct {

  const unsigned short *_locale_pctype;
  int _locale_mb_cur_max;
  unsigned int _locale_lc_codepage;
# 482 "D:/Programs/MinGW/x86_64-w64-mingw32/include/corecrt.h" 3 4
} threadlocinfo;
# 501 "D:/Programs/MinGW/x86_64-w64-mingw32/include/corecrt.h" 3 4
#pragma pack(pop)
# 11 "D:/Programs/MinGW/x86_64-w64-mingw32/include/crtdefs.h" 2 3 4
# 29 "D:/Programs/MinGW/x86_64-w64-mingw32/include/stdint.h" 2 3 4



# 1 "D:/Programs/MinGW/lib/gcc/x86_64-w64-mingw32/14.2.0/include/stddef.h" 1 3 4
# 1 "D:/Programs/MinGW/x86_64-w64-mingw32/include/stddef.h" 1 3 4
# 13 "D:/Programs/MinGW/x86_64-w64-mingw32/include/stddef.h" 3 4
extern "C" {




  __attribute__ ((__dllimport__)) extern int *__attribute__((__cdecl__)) _errno(void);

  errno_t __attribute__((__cdecl__)) _set_errno(int _Value);
  errno_t __attribute__((__cdecl__)) _get_errno(int *_Value);


  __attribute__ ((__dllimport__)) extern unsigned long __attribute__((__cdecl__)) __threadid(void);

  __attribute__ ((__dllimport__)) extern uintptr_t __attribute__((__cdecl__)) __threadhandle(void);


}
# 2 "D:/Programs/MinGW/lib/gcc/x86_64-w64-mingw32/14.2.0/include/stddef.h" 2 3 4
# 426 "D:/Programs/MinGW/lib/gcc/x86_64-w64-mingw32/14.2.0/include/stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
# 437 "D:/Programs/MinGW/lib/gcc/x86_64-w64-mingw32/14.2.0/include/stddef.h" 3 4
} max_align_t;






  typedef decltype(nullptr) nullptr_t;
# 33 "D:/Programs/MinGW/x86_64-w64-mingw32/include/stdint.h" 2 3 4


typedef signed char int8_t;
typedef unsigned char uint8_t;
typedef short int16_t;
typedef unsigned short uint16_t;
typedef int int32_t;
typedef unsigned uint32_t;
__extension__ typedef long long int64_t;
__extension__ typedef unsigned long long uint64_t;


typedef signed char int_least8_t;
typedef unsigned char uint_least8_t;
typedef short int_least16_t;
typedef unsigned short uint_least16_t;
typedef int int_least32_t;
typedef unsigned uint_least32_t;
__extension__ typedef long long int_least64_t;
__extension__ typedef unsigned long long uint_least64_t;





typedef signed char int_fast8_t;
typedef unsigned char uint_fast8_t;
typedef short int_fast16_t;
typedef unsigned short uint_fast16_t;
typedef int int_fast32_t;
typedef unsigned int uint_fast32_t;
__extension__ typedef long long int_fast64_t;
__extension__ typedef unsigned long long uint_fast64_t;


__extension__ typedef long long intmax_t;
__extension__ typedef unsigned long long uintmax_t;
# 10 "D:/Programs/MinGW/lib/gcc/x86_64-w64-mingw32/14.2.0/include/stdint.h" 2 3 4
# 39 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h" 2
# 1 "D:/Programs/MinGW/x86_64-w64-mingw32/include/string.h" 1 3
# 21 "D:/Programs/MinGW/x86_64-w64-mingw32/include/string.h" 3
extern "C" {
# 45 "D:/Programs/MinGW/x86_64-w64-mingw32/include/string.h" 3
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _memccpy(void *_Dst,const void *_Src,int _Val,size_t _MaxCount);
  void *__attribute__((__cdecl__)) memchr(const void *_Buf ,int _Val,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _memicmp(const void *_Buf1,const void *_Buf2,size_t _Size);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _memicmp_l(const void *_Buf1,const void *_Buf2,size_t _Size,_locale_t _Locale);
  int __attribute__((__cdecl__)) memcmp(const void *_Buf1,const void *_Buf2,size_t _Size);
  void * __attribute__((__cdecl__)) memcpy(void * __restrict__ _Dst,const void * __restrict__ _Src,size_t _Size) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) memcpy_s (void *_dest,size_t _numberOfElements,const void *_src,size_t _count);
  void * __attribute__((__cdecl__)) mempcpy (void *_Dst, const void *_Src, size_t _Size);
  void * __attribute__((__cdecl__)) memset(void *_Dst,int _Val,size_t _Size);

  void * __attribute__((__cdecl__)) memccpy(void *_Dst,const void *_Src,int _Val,size_t _Size) ;
  int __attribute__((__cdecl__)) memicmp(const void *_Buf1,const void *_Buf2,size_t _Size) ;


  char * __attribute__((__cdecl__)) _strset(char *_Str,int _Val) ;
  char * __attribute__((__cdecl__)) _strset_l(char *_Str,int _Val,_locale_t _Locale) ;
  char * __attribute__((__cdecl__)) strcpy(char * __restrict__ _Dest,const char * __restrict__ _Source);
  char * __attribute__((__cdecl__)) strcat(char * __restrict__ _Dest,const char * __restrict__ _Source);
  int __attribute__((__cdecl__)) strcmp(const char *_Str1,const char *_Str2);
  size_t __attribute__((__cdecl__)) strlen(const char *_Str);
  size_t __attribute__((__cdecl__)) strnlen(const char *_Str,size_t _MaxCount);
  void *__attribute__((__cdecl__)) memmove(void *_Dst,const void *_Src,size_t _Size) ;
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strdup(const char *_Src);
  char *__attribute__((__cdecl__)) strchr(const char *_Str,int _Val);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _stricmp(const char *_Str1,const char *_Str2);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _strcmpi(const char *_Str1,const char *_Str2);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _stricmp_l(const char *_Str1,const char *_Str2,_locale_t _Locale);
  int __attribute__((__cdecl__)) strcoll(const char *_Str1,const char *_Str2);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _strcoll_l(const char *_Str1,const char *_Str2,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _stricoll(const char *_Str1,const char *_Str2);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _stricoll_l(const char *_Str1,const char *_Str2,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _strncoll (const char *_Str1,const char *_Str2,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _strncoll_l(const char *_Str1,const char *_Str2,size_t _MaxCount,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _strnicoll (const char *_Str1,const char *_Str2,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _strnicoll_l(const char *_Str1,const char *_Str2,size_t _MaxCount,_locale_t _Locale);
  size_t __attribute__((__cdecl__)) strcspn(const char *_Str,const char *_Control);
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strerror(const char *_ErrMsg) ;
  char *__attribute__((__cdecl__)) strerror(int) ;
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strlwr(char *_String) ;
  char *strlwr_l(char *_String,_locale_t _Locale) ;
  char *__attribute__((__cdecl__)) strncat(char * __restrict__ _Dest,const char * __restrict__ _Source,size_t _Count) ;
  int __attribute__((__cdecl__)) strncmp(const char *_Str1,const char *_Str2,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _strnicmp(const char *_Str1,const char *_Str2,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _strnicmp_l(const char *_Str1,const char *_Str2,size_t _MaxCount,_locale_t _Locale);
  char *strncpy(char * __restrict__ _Dest,const char * __restrict__ _Source,size_t _Count) ;
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strnset(char *_Str,int _Val,size_t _MaxCount) ;
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strnset_l(char *str,int c,size_t count,_locale_t _Locale) ;
  char *__attribute__((__cdecl__)) strpbrk(const char *_Str,const char *_Control);
  char *__attribute__((__cdecl__)) strrchr(const char *_Str,int _Ch);
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strrev(char *_Str);
  size_t __attribute__((__cdecl__)) strspn(const char *_Str,const char *_Control);
  char *__attribute__((__cdecl__)) strstr(const char *_Str,const char *_SubStr);
  char *__attribute__((__cdecl__)) strtok(char * __restrict__ _Str,const char * __restrict__ _Delim) ;
       

  char *strtok_r(char * __restrict__ _Str, const char * __restrict__ _Delim, char ** __restrict__ __last);
       
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strupr(char *_String) ;
  __attribute__ ((__dllimport__)) char *_strupr_l(char *_String,_locale_t _Locale) ;
  size_t __attribute__((__cdecl__)) strxfrm(char * __restrict__ _Dst,const char * __restrict__ _Src,size_t _MaxCount);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _strxfrm_l(char * __restrict__ _Dst,const char * __restrict__ _Src,size_t _MaxCount,_locale_t _Locale);


  char *__attribute__((__cdecl__)) strdup(const char *_Src) ;
  int __attribute__((__cdecl__)) strcmpi(const char *_Str1,const char *_Str2) ;
  int __attribute__((__cdecl__)) stricmp(const char *_Str1,const char *_Str2) ;
  char *__attribute__((__cdecl__)) strlwr(char *_Str) ;
  int __attribute__((__cdecl__)) strnicmp(const char *_Str1,const char *_Str,size_t _MaxCount) ;
  int __attribute__((__cdecl__)) strncasecmp (const char *, const char *, size_t);
  int __attribute__((__cdecl__)) strcasecmp (const char *, const char *);







  char *__attribute__((__cdecl__)) strnset(char *_Str,int _Val,size_t _MaxCount) ;
  char *__attribute__((__cdecl__)) strrev(char *_Str) ;
  char *__attribute__((__cdecl__)) strset(char *_Str,int _Val) ;
  char *__attribute__((__cdecl__)) strupr(char *_Str) ;





  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcsdup(const wchar_t *_Str);
  wchar_t *__attribute__((__cdecl__)) wcscat(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Source) ;
  wchar_t *__attribute__((__cdecl__)) wcschr(const wchar_t *_Str,wchar_t _Ch);
  int __attribute__((__cdecl__)) wcscmp(const wchar_t *_Str1,const wchar_t *_Str2);
  wchar_t *__attribute__((__cdecl__)) wcscpy(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Source) ;
  size_t __attribute__((__cdecl__)) wcscspn(const wchar_t *_Str,const wchar_t *_Control);
  size_t __attribute__((__cdecl__)) wcslen(const wchar_t *_Str);
  size_t __attribute__((__cdecl__)) wcsnlen(const wchar_t *_Src,size_t _MaxCount);
  wchar_t *wcsncat(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Source,size_t _Count) ;
  int __attribute__((__cdecl__)) wcsncmp(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount);
  wchar_t *wcsncpy(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Source,size_t _Count) ;
  wchar_t *__attribute__((__cdecl__)) _wcsncpy_l(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Source,size_t _Count,_locale_t _Locale) ;
  wchar_t *__attribute__((__cdecl__)) wcspbrk(const wchar_t *_Str,const wchar_t *_Control);
  wchar_t *__attribute__((__cdecl__)) wcsrchr(const wchar_t *_Str,wchar_t _Ch);
  size_t __attribute__((__cdecl__)) wcsspn(const wchar_t *_Str,const wchar_t *_Control);
  wchar_t *__attribute__((__cdecl__)) wcsstr(const wchar_t *_Str,const wchar_t *_SubStr);

  wchar_t *__attribute__((__cdecl__)) wcstok(wchar_t * __restrict__ _Str,const wchar_t * __restrict__ _Delim,wchar_t **_Ptr) ;



  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcserror(int _ErrNum) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) __wcserror(const wchar_t *_Str) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsicmp(const wchar_t *_Str1,const wchar_t *_Str2);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsicmp_l(const wchar_t *_Str1,const wchar_t *_Str2,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsnicmp(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsnicmp_l(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount,_locale_t _Locale);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcsnset(wchar_t *_Str,wchar_t _Val,size_t _MaxCount) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcsrev(wchar_t *_Str);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcsset(wchar_t *_Str,wchar_t _Val) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcslwr(wchar_t *_String) ;
  __attribute__ ((__dllimport__)) wchar_t *_wcslwr_l(wchar_t *_String,_locale_t _Locale) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcsupr(wchar_t *_String) ;
  __attribute__ ((__dllimport__)) wchar_t *_wcsupr_l(wchar_t *_String,_locale_t _Locale) ;
  size_t __attribute__((__cdecl__)) wcsxfrm(wchar_t * __restrict__ _Dst,const wchar_t * __restrict__ _Src,size_t _MaxCount);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _wcsxfrm_l(wchar_t * __restrict__ _Dst,const wchar_t * __restrict__ _Src,size_t _MaxCount,_locale_t _Locale);
  int __attribute__((__cdecl__)) wcscoll(const wchar_t *_Str1,const wchar_t *_Str2);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcscoll_l(const wchar_t *_Str1,const wchar_t *_Str2,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsicoll(const wchar_t *_Str1,const wchar_t *_Str2);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsicoll_l(const wchar_t *_Str1,const wchar_t *_Str2,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsncoll(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsncoll_l(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsnicoll(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsnicoll_l(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount,_locale_t _Locale);


  wchar_t *__attribute__((__cdecl__)) wcsdup(const wchar_t *_Str) ;

  int __attribute__((__cdecl__)) wcsicmp(const wchar_t *_Str1,const wchar_t *_Str2) ;
  int __attribute__((__cdecl__)) wcsnicmp(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount) ;
  wchar_t *__attribute__((__cdecl__)) wcsnset(wchar_t *_Str,wchar_t _Val,size_t _MaxCount) ;
  wchar_t *__attribute__((__cdecl__)) wcsrev(wchar_t *_Str) ;
  wchar_t *__attribute__((__cdecl__)) wcsset(wchar_t *_Str,wchar_t _Val) ;
  wchar_t *__attribute__((__cdecl__)) wcslwr(wchar_t *_Str) ;
  wchar_t *__attribute__((__cdecl__)) wcsupr(wchar_t *_Str) ;
  int __attribute__((__cdecl__)) wcsicoll(const wchar_t *_Str1,const wchar_t *_Str2) ;




}


# 1 "D:/Programs/MinGW/x86_64-w64-mingw32/include/sec_api/string_s.h" 1 3
# 9 "D:/Programs/MinGW/x86_64-w64-mingw32/include/sec_api/string_s.h" 3
# 1 "D:/Programs/MinGW/x86_64-w64-mingw32/include/string.h" 1 3
# 10 "D:/Programs/MinGW/x86_64-w64-mingw32/include/sec_api/string_s.h" 2 3
# 21 "D:/Programs/MinGW/x86_64-w64-mingw32/include/sec_api/string_s.h" 3
extern "C" {


  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strset_s(char *_Dst,size_t _DstSize,int _Value);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _strset_s(char (&_Dst)[__size], int _Value) { return _strset_s(_Dst,__size,_Value); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strerror_s(char *_Buf,size_t _SizeInBytes,const char *_ErrMsg);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _strerror_s(char (&_Buf)[__size], const char * _ErrMsg) { return _strerror_s(_Buf,__size,_ErrMsg); } }
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) strerror_s(char *_Buf,size_t _SizeInBytes,int _ErrNum);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) strerror_s(char (&_Buf)[__size], int _ErrNum) { return strerror_s(_Buf,__size,_ErrNum); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strlwr_s(char *_Str,size_t _Size);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _strlwr_s(char (&_Str)[__size]) { return _strlwr_s(_Str,__size); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strlwr_s_l(char *_Str,size_t _Size,_locale_t _Locale);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _strlwr_s_l(char (&_Str)[__size], _locale_t _Locale) { return _strlwr_s_l(_Str,__size,_Locale); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strnset_s(char *_Str,size_t _Size,int _Val,size_t _MaxCount);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _strnset_s(char (&_Str)[__size], int _Val, size_t _MaxCount) { return _strnset_s(_Str,__size,_Val,_MaxCount); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strupr_s(char *_Str,size_t _Size);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _strupr_s(char (&_Str)[__size]) { return _strupr_s(_Str,__size); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strupr_s_l(char *_Str,size_t _Size,_locale_t _Locale);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _strupr_s_l(char (&_Str)[__size], _locale_t _Locale) { return _strupr_s_l(_Str,__size,_Locale); } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) strncat_s(char *_Dst,size_t _DstSizeInChars,const char *_Src,size_t _MaxCount);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) strncat_s(char (&_Dst)[__size], const char * _Src, size_t _MaxCount) { return strncat_s(_Dst,__size,_Src,_MaxCount); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strncat_s_l(char *_Dst,size_t _DstSizeInChars,const char *_Src,size_t _MaxCount,_locale_t _Locale);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _strncat_s_l(char (&_Dst)[__size], const char * _Src, size_t _MaxCount, _locale_t _Locale) { return _strncat_s_l(_Dst,__size,_Src,_MaxCount,_Locale); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) strcpy_s(char *_Dst, rsize_t _SizeInBytes, const char *_Src);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) strcpy_s(char (&_Dest)[__size], const char * _Source) { return strcpy_s(_Dest,__size,_Source); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) strncpy_s(char *_Dst, size_t _DstSizeInChars, const char *_Src, size_t _MaxCount);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) strncpy_s(char (&_Dest)[__size], const char * _Source, size_t _MaxCount) { return strncpy_s(_Dest,__size,_Source,_MaxCount); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strncpy_s_l(char *_Dst, size_t _DstSizeInChars, const char *_Src, size_t _MaxCount, _locale_t _Locale);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _strncpy_s_l(char (&_Dest)[__size], const char * _Source, size_t _MaxCount, _locale_t _Locale) { return _strncpy_s_l(_Dest,__size,_Source,_MaxCount,_Locale); } }
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) strtok_s(char *_Str,const char *_Delim,char **_Context);
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strtok_s_l(char *_Str,const char *_Delim,char **_Context,_locale_t _Locale);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) strcat_s(char *_Dst, rsize_t _SizeInBytes, const char * _Src);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) strcat_s(char (&_Dest)[__size], const char * _Source) { return strcat_s(_Dest,__size,_Source); } }

  inline __attribute__((__always_inline__)) size_t __attribute__((__cdecl__)) strnlen_s(const char * _src, size_t _count) {
    return _src ? strnlen(_src, _count) : 0;
  }

  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) memmove_s(void *_dest,size_t _numberOfElements,const void *_src,size_t _count);


  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) wcstok_s(wchar_t *_Str,const wchar_t *_Delim,wchar_t **_Context);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcserror_s(wchar_t *_Buf,size_t _SizeInWords,int _ErrNum);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _wcserror_s(wchar_t (&buffer)[__size], int error) { return _wcserror_s(buffer,__size,error); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) __wcserror_s(wchar_t *_Buffer,size_t _SizeInWords,const wchar_t *_ErrMsg);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcsnset_s(wchar_t *_Dst,size_t _DstSizeInWords,wchar_t _Val,size_t _MaxCount);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcsset_s(wchar_t *_Str,size_t _SizeInWords,wchar_t _Val);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcslwr_s(wchar_t *_Str,size_t _SizeInWords);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _wcslwr_s(wchar_t (&_Str)[__size]) { return _wcslwr_s(_Str,__size); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcslwr_s_l(wchar_t *_Str,size_t _SizeInWords,_locale_t _Locale);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _wcslwr_s_l(wchar_t (&_Str)[__size], _locale_t _Locale) { return _wcslwr_s_l(_Str,__size,_Locale); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcsupr_s(wchar_t *_Str,size_t _Size);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _wcsupr_s(wchar_t (&_Str)[__size]) { return _wcsupr_s(_Str,__size); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcsupr_s_l(wchar_t *_Str,size_t _Size,_locale_t _Locale);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _wcsupr_s_l(wchar_t (&_Str)[__size], _locale_t _Locale) { return _wcsupr_s_l(_Str,__size,_Locale); } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) wcscpy_s(wchar_t *_Dst, rsize_t _SizeInWords, const wchar_t *_Src);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) wcscpy_s(wchar_t (&_Dest)[__size], const wchar_t * _Source) { return wcscpy_s(_Dest,__size,_Source); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) wcscat_s(wchar_t * _Dst, rsize_t _SizeInWords, const wchar_t *_Src);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) wcscat_s(wchar_t (&_Dest)[__size], const wchar_t * _Source) { return wcscat_s(_Dest,__size,_Source); } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) wcsncat_s(wchar_t *_Dst,size_t _DstSizeInChars,const wchar_t *_Src,size_t _MaxCount);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) wcsncat_s(wchar_t (&_Dst)[__size], const wchar_t * _Src, size_t _MaxCount) { return wcsncat_s(_Dst,__size,_Src,_MaxCount); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcsncat_s_l(wchar_t *_Dst,size_t _DstSizeInChars,const wchar_t *_Src,size_t _MaxCount,_locale_t _Locale);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _wcsncat_s_l(wchar_t (&_Dst)[__size], const wchar_t * _Src, size_t _MaxCount, _locale_t _Locale) { return _wcsncat_s_l(_Dst,__size,_Src,_MaxCount,_Locale); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) wcsncpy_s(wchar_t *_Dst, size_t _DstSizeInChars, const wchar_t *_Src, size_t _MaxCount);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) wcsncpy_s(wchar_t (&_Dest)[__size], const wchar_t * _Source, size_t _MaxCount) { return wcsncpy_s(_Dest,__size,_Source,_MaxCount); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcsncpy_s_l(wchar_t *_Dst, size_t _DstSizeInChars, const wchar_t *_Src, size_t _MaxCount, _locale_t _Locale);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _wcsncpy_s_l(wchar_t (&_Dest)[__size], const wchar_t * _Source, size_t _MaxCount, _locale_t _Locale) { return _wcsncpy_s_l(_Dest,__size,_Source,_MaxCount,_Locale); } }
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcstok_s_l(wchar_t *_Str,const wchar_t *_Delim,wchar_t **_Context,_locale_t _Locale);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcsset_s_l(wchar_t *_Str,size_t _SizeInChars,wchar_t _Val,_locale_t _Locale);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _wcsset_s_l(wchar_t (&_Str)[__size], wchar_t _Val, _locale_t _Locale) { return _wcsset_s_l(_Str,__size,_Val,_Locale); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcsnset_s_l(wchar_t *_Str,size_t _SizeInChars,wchar_t _Val, size_t _Count,_locale_t _Locale);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _wcsnset_s_l(wchar_t (&_Str)[__size], wchar_t _Val, size_t _Count, _locale_t _Locale) { return _wcsnset_s_l(_Str,__size,_Val,_Count,_Locale); } }

  inline __attribute__((__always_inline__)) size_t __attribute__((__cdecl__)) wcsnlen_s(const wchar_t * _src, size_t _count) {
    return _src ? wcsnlen(_src, _count) : 0;
  }



}
# 195 "D:/Programs/MinGW/x86_64-w64-mingw32/include/string.h" 2 3
# 40 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h" 2
# 1 "D:/Programs/MinGW/x86_64-w64-mingw32/include/wchar.h" 1 3
# 10 "D:/Programs/MinGW/x86_64-w64-mingw32/include/wchar.h" 3
# 1 "D:/Programs/MinGW/x86_64-w64-mingw32/include/corecrt_stdio_config.h" 1 3
# 11 "D:/Programs/MinGW/x86_64-w64-mingw32/include/wchar.h" 2 3
# 1 "D:/Programs/MinGW/x86_64-w64-mingw32/include/corecrt_wstdlib.h" 1 3
# 12 "D:/Programs/MinGW/x86_64-w64-mingw32/include/corecrt_wstdlib.h" 3
extern "C" {


  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _itow_s (int _Val,wchar_t *_DstBuf,size_t _SizeInWords,int _Radix);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _itow_s(int _Val, wchar_t (&_DstBuf)[__size], int _Radix) { return _itow_s(_Val, _DstBuf, __size, _Radix); } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ltow_s (long _Val,wchar_t *_DstBuf,size_t _SizeInWords,int _Radix);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _ltow_s(long _Val, wchar_t (&_DstBuf)[__size], int _Radix) { return _ltow_s(_Val, _DstBuf, __size, _Radix); } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ultow_s (unsigned long _Val,wchar_t *_DstBuf,size_t _SizeInWords,int _Radix);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _ultow_s(unsigned long _Val, wchar_t (&_DstBuf)[__size], int _Radix) { return _ultow_s(_Val, _DstBuf, __size, _Radix); } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wgetenv_s(size_t *_ReturnSize,wchar_t *_DstBuf,size_t _DstSizeInWords,const wchar_t *_VarName);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _wgetenv_s(size_t* _ReturnSize, wchar_t (&_DstBuf)[__size], const wchar_t* _VarName) { return _wgetenv_s(_ReturnSize, _DstBuf, __size, _VarName); } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wdupenv_s(wchar_t **_Buffer,size_t *_BufferSizeInWords,const wchar_t *_VarName);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _i64tow_s(long long _Val,wchar_t *_DstBuf,size_t _SizeInWords,int _Radix);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ui64tow_s(unsigned long long _Val,wchar_t *_DstBuf,size_t _SizeInWords,int _Radix);

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wmakepath_s(wchar_t *_PathResult,size_t _SizeInWords,const wchar_t *_Drive,const wchar_t *_Dir,const wchar_t *_Filename,const wchar_t *_Ext);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _wmakepath_s(wchar_t (&_PathResult)[__size], const wchar_t* _Drive, const wchar_t* _Dir, const wchar_t* _Filename, const wchar_t* _Ext) { return _wmakepath_s(_PathResult,__size,_Drive,_Dir,_Filename,_Ext); } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wputenv_s(const wchar_t *_Name,const wchar_t *_Value);

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wsearchenv_s(const wchar_t *_Filename,const wchar_t *_EnvVar,wchar_t *_ResultPath,size_t _SizeInWords);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _wsearchenv_s(const wchar_t* _Filename, const wchar_t* _EnvVar, wchar_t (&_ResultPath)[__size]) { return _wsearchenv_s(_Filename, _EnvVar, _ResultPath, __size); } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wsplitpath_s(const wchar_t *_FullPath,wchar_t *_Drive,size_t _DriveSizeInWords,wchar_t *_Dir,size_t _DirSizeInWords,wchar_t *_Filename,size_t _FilenameSizeInWords,wchar_t *_Ext,size_t _ExtSizeInWords);
  extern "C++" { template <size_t __drive_size, size_t __dir_size, size_t __name_size, size_t __ext_size> inline errno_t __attribute__((__cdecl__)) _wsplitpath_s(const wchar_t *_Dest, wchar_t (&__drive)[__drive_size], wchar_t (&__dir)[__dir_size], wchar_t (&__name)[__name_size], wchar_t (&__ext)[__ext_size]) { return _wsplitpath_s(_Dest, __drive, __drive_size, __dir, __dir_size, __name, __name_size, __ext, __ext_size); } }


}
# 12 "D:/Programs/MinGW/x86_64-w64-mingw32/include/wchar.h" 2 3
# 26 "D:/Programs/MinGW/x86_64-w64-mingw32/include/wchar.h" 3
#pragma pack(push,_CRT_PACKING)


extern "C" {
# 42 "D:/Programs/MinGW/x86_64-w64-mingw32/include/wchar.h" 3
  struct _iobuf {
    char *_ptr;
    int _cnt;
    char *_base;
    int _flag;
    int _file;
    int _charbuf;
    int _bufsiz;
    char *_tmpfname;
  };
  typedef struct _iobuf FILE;



__attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) __acrt_iob_func(unsigned index);


  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) __iob_func(void);
# 82 "D:/Programs/MinGW/x86_64-w64-mingw32/include/wchar.h" 3
  typedef unsigned long _fsize_t;




  struct _wfinddata32_t {
    unsigned attrib;
    __time32_t time_create;
    __time32_t time_access;
    __time32_t time_write;
    _fsize_t size;
    wchar_t name[260];
  };

  struct _wfinddata32i64_t {
    unsigned attrib;
    __time32_t time_create;
    __time32_t time_access;
    __time32_t time_write;
    __extension__ long long size;
    wchar_t name[260];
  };

  struct _wfinddata64i32_t {
    unsigned attrib;
    __time64_t time_create;
    __time64_t time_access;
    __time64_t time_write;
    _fsize_t size;
    wchar_t name[260];
  };

  struct _wfinddata64_t {
    unsigned attrib;
    __time64_t time_create;
    __time64_t time_access;
    __time64_t time_write;
    __extension__ long long size;
    wchar_t name[260];
  };
# 173 "D:/Programs/MinGW/x86_64-w64-mingw32/include/wchar.h" 3
  __attribute__ ((__dllimport__)) unsigned short* __pctype_func(void);
# 202 "D:/Programs/MinGW/x86_64-w64-mingw32/include/wchar.h" 3
  extern unsigned short ** __imp__wctype;
# 217 "D:/Programs/MinGW/x86_64-w64-mingw32/include/wchar.h" 3
  extern unsigned short ** __imp__pwctype;
# 241 "D:/Programs/MinGW/x86_64-w64-mingw32/include/wchar.h" 3
  int __attribute__((__cdecl__)) iswalpha(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswalpha_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswupper(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswupper_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswlower(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswlower_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswdigit(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswdigit_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswxdigit(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswxdigit_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswspace(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswspace_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswpunct(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswpunct_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswalnum(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswalnum_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswprint(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswprint_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswgraph(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswgraph_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswcntrl(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswcntrl_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswascii(wint_t _C);

  int __attribute__((__cdecl__)) isleadbyte(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isleadbyte_l(int _C,_locale_t _Locale);

  wint_t __attribute__((__cdecl__)) towupper(wint_t _C);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _towupper_l(wint_t _C,_locale_t _Locale);
  wint_t __attribute__((__cdecl__)) towlower(wint_t _C);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _towlower_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswctype(wint_t _C,wctype_t _Type);

  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswctype_l(wint_t _C,wctype_t _Type,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) __iswcsymf(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswcsymf_l(wint_t _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) __iswcsym(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswcsym_l(wint_t _C,_locale_t _Locale);


  int __attribute__((__cdecl__)) is_wctype(wint_t _C,wctype_t _Type);



  int __attribute__((__cdecl__)) iswblank(wint_t _C);







  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wgetcwd(wchar_t *_DstBuf,int _SizeInWords);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wgetdcwd(int _Drive,wchar_t *_DstBuf,int _SizeInWords);

  wchar_t *__attribute__((__cdecl__)) _wgetdcwd_nolock(int _Drive,wchar_t *_DstBuf,int _SizeInWords);

  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wchdir(const wchar_t *_Path);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wmkdir(const wchar_t *_Path);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wrmdir(const wchar_t *_Path);





  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _waccess(const wchar_t *_Filename,int _AccessMode);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wchmod(const wchar_t *_Filename,int _Mode);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcreat(const wchar_t *_Filename,int _PermissionMode) ;
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wfindfirst32(const wchar_t *_Filename,struct _wfinddata32_t *_FindData);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wfindnext32(intptr_t _FindHandle,struct _wfinddata32_t *_FindData);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wunlink(const wchar_t *_Filename);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wrename(const wchar_t *_OldFilename,const wchar_t *_NewFilename);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wmktemp(wchar_t *_TemplateName) ;
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wfindfirst32i64(const wchar_t *_Filename,struct _wfinddata32i64_t *_FindData);
  intptr_t __attribute__((__cdecl__)) _wfindfirst64i32(const wchar_t *_Filename,struct _wfinddata64i32_t *_FindData);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wfindfirst64(const wchar_t *_Filename,struct _wfinddata64_t *_FindData);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wfindnext32i64(intptr_t _FindHandle,struct _wfinddata32i64_t *_FindData);
  int __attribute__((__cdecl__)) _wfindnext64i32(intptr_t _FindHandle,struct _wfinddata64i32_t *_FindData);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wfindnext64(intptr_t _FindHandle,struct _wfinddata64_t *_FindData);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wsopen_s(int *_FileHandle,const wchar_t *_Filename,int _OpenFlag,int _ShareFlag,int _PermissionFlag);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wopen(const wchar_t *_Filename,int _OpenFlag,...) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wsopen(const wchar_t *_Filename,int _OpenFlag,int _ShareFlag,...) ;




  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wsetlocale(int _Category,const wchar_t *_Locale);





  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wexecl(const wchar_t *_Filename,const wchar_t *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wexecle(const wchar_t *_Filename,const wchar_t *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wexeclp(const wchar_t *_Filename,const wchar_t *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wexeclpe(const wchar_t *_Filename,const wchar_t *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wexecv(const wchar_t *_Filename,const wchar_t *const *_ArgList);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wexecve(const wchar_t *_Filename,const wchar_t *const *_ArgList,const wchar_t *const *_Env);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wexecvp(const wchar_t *_Filename,const wchar_t *const *_ArgList);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wexecvpe(const wchar_t *_Filename,const wchar_t *const *_ArgList,const wchar_t *const *_Env);




  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wspawnl(int _Mode,const wchar_t *_Filename,const wchar_t *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wspawnle(int _Mode,const wchar_t *_Filename,const wchar_t *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wspawnlp(int _Mode,const wchar_t *_Filename,const wchar_t *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wspawnlpe(int _Mode,const wchar_t *_Filename,const wchar_t *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wspawnv(int _Mode,const wchar_t *_Filename,const wchar_t *const *_ArgList);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wspawnve(int _Mode,const wchar_t *_Filename,const wchar_t *const *_ArgList,const wchar_t *const *_Env);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wspawnvp(int _Mode,const wchar_t *_Filename,const wchar_t *const *_ArgList);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wspawnvpe(int _Mode,const wchar_t *_Filename,const wchar_t *const *_ArgList,const wchar_t *const *_Env);




  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wsystem(const wchar_t *_Command);
# 398 "D:/Programs/MinGW/x86_64-w64-mingw32/include/wchar.h" 3
  typedef unsigned short _ino_t;

  typedef unsigned short ino_t;





  typedef unsigned int _dev_t;

  typedef unsigned int dev_t;



# 1 "D:/Programs/MinGW/x86_64-w64-mingw32/include/_mingw_off_t.h" 1 3




  typedef long _off_t;

  typedef long off32_t;





  __extension__ typedef long long _off64_t;

  __extension__ typedef long long off64_t;
# 26 "D:/Programs/MinGW/x86_64-w64-mingw32/include/_mingw_off_t.h" 3
typedef off32_t off_t;
# 413 "D:/Programs/MinGW/x86_64-w64-mingw32/include/wchar.h" 2 3
# 1 "D:/Programs/MinGW/x86_64-w64-mingw32/include/_mingw_stat64.h" 1 3
# 25 "D:/Programs/MinGW/x86_64-w64-mingw32/include/_mingw_stat64.h" 3
  struct _stat32 {
    _dev_t st_dev;
   _ino_t st_ino;
    unsigned short st_mode;
    short st_nlink;
    short st_uid;
    short st_gid;
    _dev_t st_rdev;
    _off_t st_size;
    __time32_t st_atime;
    __time32_t st_mtime;
    __time32_t st_ctime;
  };


  struct stat {
    _dev_t st_dev;
    _ino_t st_ino;
    unsigned short st_mode;
    short st_nlink;
    short st_uid;
    short st_gid;
    _dev_t st_rdev;
    _off_t st_size;
    time_t st_atime;
    time_t st_mtime;
    time_t st_ctime;
  };


  struct _stat32i64 {
    _dev_t st_dev;
    _ino_t st_ino;
    unsigned short st_mode;
    short st_nlink;
    short st_uid;
    short st_gid;
    _dev_t st_rdev;
    __extension__ long long st_size;
    __time32_t st_atime;
    __time32_t st_mtime;
    __time32_t st_ctime;
  };

  struct _stat64i32 {
    _dev_t st_dev;
    _ino_t st_ino;
    unsigned short st_mode;
    short st_nlink;
    short st_uid;
    short st_gid;
    _dev_t st_rdev;
    _off_t st_size;
    __time64_t st_atime;
    __time64_t st_mtime;
    __time64_t st_ctime;
  };

  struct _stat64 {
    _dev_t st_dev;
    _ino_t st_ino;
    unsigned short st_mode;
    short st_nlink;
    short st_uid;
    short st_gid;
    _dev_t st_rdev;
    __extension__ long long st_size;
    __time64_t st_atime;
    __time64_t st_mtime;
    __time64_t st_ctime;
  };
# 414 "D:/Programs/MinGW/x86_64-w64-mingw32/include/wchar.h" 2 3




  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wstat32(const wchar_t *_Name,struct _stat32 *_Stat);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wstat32i64(const wchar_t *_Name,struct _stat32i64 *_Stat);
  int __attribute__((__cdecl__)) _wstat64i32(const wchar_t *_Name,struct _stat64i32 *_Stat);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wstat64(const wchar_t *_Name,struct _stat64 *_Stat);
# 432 "D:/Programs/MinGW/x86_64-w64-mingw32/include/wchar.h" 3
  __attribute__ ((__dllimport__)) wchar_t *_cgetws(wchar_t *_Buffer) ;
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _getwch(void);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _getwche(void);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _putwch(wchar_t _WCh);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _ungetwch(wint_t _WCh);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _cputws(const wchar_t *_String);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _cwprintf(const wchar_t * __restrict__ _Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _cwscanf(const wchar_t * __restrict__ _Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _cwscanf_l(const wchar_t * __restrict__ _Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vcwprintf(const wchar_t * __restrict__ _Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _cwprintf_p(const wchar_t * __restrict__ _Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vcwprintf_p(const wchar_t * __restrict__ _Format,va_list _ArgList);

  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _cwprintf_l(const wchar_t * __restrict__ _Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vcwprintf_l(const wchar_t * __restrict__ _Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _cwprintf_p_l(const wchar_t * __restrict__ _Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vcwprintf_p_l(const wchar_t * __restrict__ _Format,_locale_t _Locale,va_list _ArgList);

  wint_t __attribute__((__cdecl__)) _putwch_nolock(wchar_t _WCh);
  wint_t __attribute__((__cdecl__)) _getwch_nolock(void);
  wint_t __attribute__((__cdecl__)) _getwche_nolock(void);
  wint_t __attribute__((__cdecl__)) _ungetwch_nolock(wint_t _WCh);




  int __attribute__((__cdecl__)) __stdio_common_vswprintf_p(unsigned long long _Options, wchar_t *_Str, size_t _Len, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList);
  int __attribute__((__cdecl__)) __stdio_common_vfwprintf_p(unsigned long long _Options, FILE *_File, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList);





                                                     __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_swscanf(const wchar_t * __restrict__ _Src,const wchar_t * __restrict__ _Format,...);
                                                     __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_vswscanf (const wchar_t * __restrict__ _Str,const wchar_t * __restrict__ Format,va_list argp);
                                                     __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __mingw_wscanf(const wchar_t * __restrict__ _Format,...);
                                                     __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __mingw_vwscanf(const wchar_t * __restrict__ Format, va_list argp);
                                                     __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_fwscanf(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,...);
                                                     __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_vfwscanf (FILE * __restrict__ fp, const wchar_t * __restrict__ Format,va_list argp);


                                                      __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_fwprintf(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,...);
                                                      __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __mingw_wprintf(const wchar_t * __restrict__ _Format,...);
                                                      __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_vfwprintf(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,va_list _ArgList);
                                                     __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __mingw_vwprintf(const wchar_t * __restrict__ _Format,va_list _ArgList);
                                                      __attribute__ ((__nonnull__ (3)))
  int __attribute__((__cdecl__)) __mingw_snwprintf (wchar_t * __restrict__ s, size_t n, const wchar_t * __restrict__ format, ...);
                                                      __attribute__ ((__nonnull__ (3)))
  int __attribute__((__cdecl__)) __mingw_vsnwprintf (wchar_t * __restrict__ , size_t, const wchar_t * __restrict__ , va_list);
                                                      __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_swprintf(wchar_t * __restrict__ , const wchar_t * __restrict__ , ...);
                                                      __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_vswprintf(wchar_t * __restrict__ , const wchar_t * __restrict__ ,va_list);

                                                    __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __ms_swscanf(const wchar_t * __restrict__ _Src,const wchar_t * __restrict__ _Format,...);
                                                    __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __ms_wscanf(const wchar_t * __restrict__ _Format,...);
                                                    __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __ms_fwscanf(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,...);

                                                     __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __ms_fwprintf(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,...);
                                                     __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __ms_wprintf(const wchar_t * __restrict__ _Format,...);
                                                    __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __ms_vfwprintf(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,va_list _ArgList);
                                                    __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __ms_vwprintf(const wchar_t * __restrict__ _Format,va_list _ArgList);
                                                     __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __ms_swprintf(wchar_t * __restrict__ , const wchar_t * __restrict__ , ...);
                                                     __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __ms_vswprintf(wchar_t * __restrict__ , const wchar_t * __restrict__ ,va_list);


  int __attribute__((__cdecl__)) __stdio_common_vswprintf(unsigned long long options, wchar_t *str, size_t len, const wchar_t *format, _locale_t locale, va_list valist);
  int __attribute__((__cdecl__)) __stdio_common_vfwprintf(unsigned long long options, FILE *file, const wchar_t *format, _locale_t locale, va_list valist);
  int __attribute__((__cdecl__)) __stdio_common_vswscanf(unsigned long long options, const wchar_t *input, size_t length, const wchar_t *format, _locale_t locale, va_list valist);
  int __attribute__((__cdecl__)) __stdio_common_vfwscanf(unsigned long long options, FILE *file, const wchar_t *format, _locale_t locale, va_list valist);
# 644 "D:/Programs/MinGW/x86_64-w64-mingw32/include/wchar.h" 3
  inline __attribute__((__cdecl__))
  int __attribute__((__cdecl__)) fwscanf(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,...)
  {
    __builtin_va_list __ap;
    int __ret;
    __builtin_va_start(__ap, _Format);
    __ret = __stdio_common_vfwscanf(0x0002ULL, _File, _Format, __null, __ap);
    __builtin_va_end(__ap);
    return __ret;
  }
  inline __attribute__((__cdecl__))
  int __attribute__((__cdecl__)) swscanf(const wchar_t * __restrict__ _Src,const wchar_t * __restrict__ _Format,...)
  {
    __builtin_va_list __ap;
    int __ret;
    __builtin_va_start(__ap, _Format);
    __ret = __stdio_common_vswscanf(0x0002ULL, _Src, (size_t)-1, _Format, __null, __ap);
    __builtin_va_end(__ap);
    return __ret;
  }
  inline __attribute__((__cdecl__))
  int __attribute__((__cdecl__)) wscanf(const wchar_t * __restrict__ _Format,...)
  {
    __builtin_va_list __ap;
    int __ret;
    __builtin_va_start(__ap, _Format);
    __ret = __stdio_common_vfwscanf(0x0002ULL, (__acrt_iob_func(0)), _Format, __null, __ap);
    __builtin_va_end(__ap);
    return __ret;
  }
  inline __attribute__((__cdecl__))
  __attribute__ ((__nonnull__ (2)))
  int vfwscanf (FILE *__stream, const wchar_t *__format, va_list __local_argv)
  {
    return __stdio_common_vfwscanf(0x0002ULL, __stream, __format, __null, __local_argv);
  }

  inline __attribute__((__cdecl__))
  __attribute__ ((__nonnull__ (2)))
  int vswscanf (const wchar_t * __restrict__ __source, const wchar_t * __restrict__ __format, va_list __local_argv)
  {
    return __stdio_common_vswscanf(0x0002ULL, __source, (size_t)-1, __format, __null, __local_argv);
  }
  inline __attribute__((__cdecl__))
  __attribute__ ((__nonnull__ (1)))
  int vwscanf(const wchar_t *__format, va_list __local_argv)
  {
    return __stdio_common_vfwscanf(0x0002ULL, (__acrt_iob_func(0)), __format, __null, __local_argv);
  }

  int __attribute__((__cdecl__)) fwprintf(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,...);
  inline __attribute__((__cdecl__))
  int __attribute__((__cdecl__)) wprintf(const wchar_t * __restrict__ _Format,...)
  {
    __builtin_va_list __ap;
    int __ret;
    __builtin_va_start(__ap, _Format);
    __ret = __stdio_common_vfwprintf(0x0004ULL, (__acrt_iob_func(1)), _Format, __null, __ap);
    __builtin_va_end(__ap);
    return __ret;
  }
  inline __attribute__((__cdecl__))
  int __attribute__((__cdecl__)) vfwprintf(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,va_list _ArgList)
  {
    return __stdio_common_vfwprintf(0x0004ULL, _File, _Format, __null, _ArgList);
  }
  inline __attribute__((__cdecl__))
  int __attribute__((__cdecl__)) vwprintf(const wchar_t * __restrict__ _Format,va_list _ArgList)
  {
    return __stdio_common_vfwprintf(0x0004ULL, (__acrt_iob_func(1)), _Format, __null, _ArgList);
  }
# 762 "D:/Programs/MinGW/x86_64-w64-mingw32/include/wchar.h" 3
  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) _wfsopen(const wchar_t *_Filename,const wchar_t *_Mode,int _ShFlag);


  wint_t __attribute__((__cdecl__)) fgetwc(FILE *_File);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _fgetwchar(void);
  wint_t __attribute__((__cdecl__)) fputwc(wchar_t _Ch,FILE *_File);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _fputwchar(wchar_t _Ch);
  wint_t __attribute__((__cdecl__)) getwc(FILE *_File);
  wint_t __attribute__((__cdecl__)) getwchar(void);
  wint_t __attribute__((__cdecl__)) putwc(wchar_t _Ch,FILE *_File);
  wint_t __attribute__((__cdecl__)) putwchar(wchar_t _Ch);
  wint_t __attribute__((__cdecl__)) ungetwc(wint_t _Ch,FILE *_File);
  wchar_t *__attribute__((__cdecl__)) fgetws(wchar_t * __restrict__ _Dst,int _SizeInWords,FILE * __restrict__ _File);
  int __attribute__((__cdecl__)) fputws(const wchar_t * __restrict__ _Str,FILE * __restrict__ _File);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _getws(wchar_t *_String) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _putws(const wchar_t *_Str);


  inline __attribute__((__cdecl__))
  int __attribute__((__cdecl__)) _scwprintf(const wchar_t * __restrict__ _Format,...)
  {
    __builtin_va_list __ap;
    int __ret;
    __builtin_va_start(__ap, _Format);
    __ret = __stdio_common_vswprintf(0x0004ULL | 0x0002ULL, __null, 0, _Format, __null, __ap);
    __builtin_va_end(__ap);
    return __ret;
  }
  int __attribute__((__cdecl__)) _snwprintf(wchar_t * __restrict__ _Dest,size_t _Count,const wchar_t * __restrict__ _Format,...) ;
  inline __attribute__((__cdecl__))
  int __attribute__((__cdecl__)) _vsnwprintf(wchar_t * __restrict__ _Dest,size_t _Count,const wchar_t * __restrict__ _Format,va_list _Args)
  {
    return __stdio_common_vswprintf(0x0004ULL | 0x0001ULL, _Dest, _Count, _Format, __null, _Args);
  }


  inline __attribute__((__cdecl__))
  int snwprintf (wchar_t * __restrict__ s, size_t n, const wchar_t * __restrict__ format, ...)
  {
    __builtin_va_list __ap;
    int __ret;
    __builtin_va_start(__ap, format);
    __ret = __stdio_common_vswprintf(0x0004ULL | 0x0002ULL, s, n, format, __null, __ap);
    __builtin_va_end(__ap);
    return __ret;
  }
  inline __attribute__((__cdecl__))
  int __attribute__((__cdecl__)) vsnwprintf (wchar_t * __restrict__ s, size_t n, const wchar_t * __restrict__ format, va_list arg)
  {
    int __ret = __stdio_common_vswprintf(0x0004ULL, s, n, format, __null, arg);
    return __ret < 0 ? -1 : __ret;
  }
# 858 "D:/Programs/MinGW/x86_64-w64-mingw32/include/wchar.h" 3
  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _vfwscanf_l(FILE *_File, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
  {
    return __stdio_common_vfwscanf(0x0002ULL, _File, _Format, _Locale, _ArgList);
  }

  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _vwscanf_l(const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
  {
    return _vfwscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
  }

  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _fwscanf_l(FILE *_File, const wchar_t *_Format, _locale_t _Locale, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Locale);
    _Ret = _vfwscanf_l(_File, _Format, _Locale, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }
  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _wscanf_l(const wchar_t *_Format, _locale_t _Locale, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Locale);
    _Ret = _vfwscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }

  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _vsnwscanf_l(const wchar_t *_Src, size_t _MaxCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
  {
    return __stdio_common_vswscanf(0x0002ULL, _Src, _MaxCount, _Format, _Locale, _ArgList);
  }
  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _snwscanf_l(const wchar_t *_Src, size_t _MaxCount, const wchar_t *_Format, _locale_t _Locale, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Locale);
    _Ret = _vsnwscanf_l(_Src, _MaxCount, _Format, _Locale, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }
  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _snwscanf(const wchar_t *_Src, size_t _MaxCount, const wchar_t *_Format, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Format);
    _Ret = _vsnwscanf_l(_Src, _MaxCount, _Format, __null, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }

  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _vswscanf_l(const wchar_t *_Src, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
  {
    return __stdio_common_vswscanf(0x0002ULL, _Src, (size_t)-1, _Format, _Locale, _ArgList);
  }
  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _swscanf_l(const wchar_t *_Src, const wchar_t *_Format, _locale_t _Locale, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Locale);
    _Ret = _vswscanf_l(_Src, _Format, _Locale, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }

  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _vfwprintf_p_l(FILE *_File, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
  {
    return __stdio_common_vfwprintf_p(0x0004ULL, _File, _Format, _Locale, _ArgList);
  }
  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _vwprintf_p_l(const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
  {
    return _vfwprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
  }
  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _vfwprintf_p(FILE *_File, const wchar_t *_Format, va_list _ArgList)
  {
    return _vfwprintf_p_l(_File, _Format, __null, _ArgList);
  }
  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _vwprintf_p(const wchar_t *_Format, va_list _ArgList)
  {
    return _vfwprintf_p_l((__acrt_iob_func(1)), _Format, __null, _ArgList);
  }
  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _fwprintf_p_l(FILE *_File, const wchar_t *_Format, _locale_t _Locale, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Locale);
    _Ret = _vfwprintf_p_l(_File, _Format, _Locale, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }
  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _wprintf_p_l(const wchar_t *_Format, _locale_t _Locale, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Locale);
    _Ret = _vfwprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }
  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _fwprintf_p(FILE *_File, const wchar_t *_Format, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Format);
    _Ret = _vfwprintf_p_l(_File, _Format, __null, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }
  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _wprintf_p(const wchar_t *_Format, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Format);
    _Ret = _vfwprintf_p_l((__acrt_iob_func(1)), _Format, __null, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }

  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _vfwprintf_l(FILE *_File, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
  {
    return __stdio_common_vfwprintf(0x0004ULL, _File, _Format, _Locale, _ArgList);
  }
  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _vwprintf_l(const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
  {
    return _vfwprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
  }
  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _fwprintf_l(FILE *_File, const wchar_t *_Format, _locale_t _Locale, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Locale);
    _Ret = _vfwprintf_l(_File, _Format, _Locale, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }
  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _wprintf_l(const wchar_t *_Format, _locale_t _Locale, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Locale);
    _Ret = _vfwprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }

  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _vswprintf_p_l(wchar_t *_DstBuf, size_t _MaxCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
  {
    return __stdio_common_vswprintf_p(0x0004ULL, _DstBuf, _MaxCount, _Format, _Locale, _ArgList);
  }
  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _vswprintf_p(wchar_t *_DstBuf, size_t _MaxCount, const wchar_t *_Format, va_list _ArgList)
  {
    return _vswprintf_p_l(_DstBuf, _MaxCount, _Format, __null, _ArgList);
  }
  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _swprintf_p_l(wchar_t *_DstBuf, size_t _MaxCount, const wchar_t *_Format, _locale_t _Locale, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Locale);
    _Ret = _vswprintf_p_l(_DstBuf, _MaxCount, _Format, _Locale, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }
  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _swprintf_p(wchar_t *_DstBuf, size_t _MaxCount, const wchar_t *_Format, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Format);
    _Ret = _vswprintf_p_l(_DstBuf, _MaxCount, _Format, __null, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }

  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _vsnwprintf_l(wchar_t *_DstBuf, size_t _MaxCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
  {
    return __stdio_common_vswprintf(0x0004ULL | 0x0001ULL, _DstBuf, _MaxCount, _Format, _Locale, _ArgList);
  }
  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _snwprintf_l(wchar_t *_DstBuf, size_t _MaxCount, const wchar_t *_Format, _locale_t _Locale, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Locale);
    _Ret = _vsnwprintf_l(_DstBuf, _MaxCount, _Format, _Locale, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }

  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _vscwprintf_p_l(const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
  {
    return __stdio_common_vswprintf_p(0x0004ULL | 0x0002ULL, __null, 0, _Format, _Locale, _ArgList);
  }
  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _vscwprintf_p(const wchar_t *_Format, va_list _ArgList)
  {
    return _vscwprintf_p_l(_Format, __null, _ArgList);
  }
  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _scwprintf_p_l(const wchar_t *_Format, _locale_t _Locale, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Locale);
    _Ret = _vscwprintf_p_l(_Format, _Locale, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }
  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _scwprintf_p(const wchar_t *_Format, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Format);
    _Ret = _vscwprintf_p_l(_Format, __null, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }

  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _vscwprintf_l(const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
  {
    return __stdio_common_vswprintf(0x0004ULL | 0x0002ULL, __null, 0, _Format, _Locale, _ArgList);
  }
  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _vscwprintf(const wchar_t *_Format, va_list _ArgList)
  {
    return _vscwprintf_l(_Format, __null, _ArgList);
  }
  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _scwprintf_l(const wchar_t *_Format, _locale_t _Locale, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Locale);
    _Ret = _vscwprintf_l(_Format, _Locale, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }

  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _vswprintf_c_l(wchar_t *_DstBuf, size_t _MaxCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
  {
    return __stdio_common_vswprintf(0x0004ULL, _DstBuf, _MaxCount, _Format, _Locale, _ArgList);
  }
  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) __vswprintf_l(wchar_t *_DstBuf, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
  {
    return _vswprintf_c_l(_DstBuf, (size_t)-1, _Format, _Locale, _ArgList);
  }
  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _vswprintf_l(wchar_t *_DstBuf, size_t _MaxCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
  {
    return _vswprintf_c_l(_DstBuf, _MaxCount, _Format, _Locale, _ArgList);
  }
  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _vswprintf(wchar_t *_DstBuf, const wchar_t *_Format, va_list _ArgList)
  {
    return _vswprintf_c_l(_DstBuf, (size_t)-1, _Format, __null, _ArgList);
  }
  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _swprintf_c_l(wchar_t *_DstBuf, size_t _MaxCount, const wchar_t *_Format, _locale_t _Locale, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Locale);
    _Ret = _vswprintf_c_l(_DstBuf, _MaxCount, _Format, _Locale, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }
  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) __swprintf_l(wchar_t *_DstBuf, const wchar_t *_Format, _locale_t _Locale, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Locale);
    _Ret = _vswprintf_c_l(_DstBuf, (size_t)-1, _Format, _Locale, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }
  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _swprintf(wchar_t *_DstBuf, const wchar_t *_Format, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Format);
    _Ret = _vswprintf_c_l(_DstBuf, (size_t)-1, _Format, __null, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }
# 1167 "D:/Programs/MinGW/x86_64-w64-mingw32/include/wchar.h" 3
# 1 "D:/Programs/MinGW/x86_64-w64-mingw32/include/swprintf.inl" 1 3
# 12 "D:/Programs/MinGW/x86_64-w64-mingw32/include/swprintf.inl" 3
inline __attribute__((__cdecl__))
                                                      __attribute__ ((__nonnull__ (3)))
int vswprintf (wchar_t *__stream, size_t __count, const wchar_t *__format, __builtin_va_list __local_argv)
{
  return vsnwprintf( __stream, __count, __format, __local_argv );
}

inline __attribute__((__cdecl__))
                                                      __attribute__ ((__nonnull__ (3)))
int swprintf (wchar_t *__stream, size_t __count, const wchar_t *__format, ...)
{
  int __retval;
  __builtin_va_list __local_argv;

  __builtin_va_start( __local_argv, __format );
  __retval = vswprintf( __stream, __count, __format, __local_argv );
  __builtin_va_end( __local_argv );
  return __retval;
}



extern "C++" {

inline __attribute__((__cdecl__))
                                                      __attribute__ ((__nonnull__ (2)))
int vswprintf (wchar_t *__stream, const wchar_t *__format, __builtin_va_list __local_argv)
{



  return _vswprintf( __stream, __format, __local_argv );

}

inline __attribute__((__cdecl__))
                                                      __attribute__ ((__nonnull__ (2)))
int swprintf (wchar_t *__stream, const wchar_t *__format, ...)
{
  int __retval;
  __builtin_va_list __local_argv;

  __builtin_va_start( __local_argv, __format );
  __retval = vswprintf( __stream, __format, __local_argv );
  __builtin_va_end( __local_argv );
  return __retval;
}

}
# 1168 "D:/Programs/MinGW/x86_64-w64-mingw32/include/wchar.h" 2 3
# 1177 "D:/Programs/MinGW/x86_64-w64-mingw32/include/wchar.h" 3
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wtempnam(const wchar_t *_Directory,const wchar_t *_FilePrefix);
# 1187 "D:/Programs/MinGW/x86_64-w64-mingw32/include/wchar.h" 3
  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) _wfdopen(int _FileHandle ,const wchar_t *_Mode);
  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) _wfopen(const wchar_t * __restrict__ _Filename,const wchar_t * __restrict__ _Mode) ;
  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) _wfreopen(const wchar_t * __restrict__ _Filename,const wchar_t * __restrict__ _Mode,FILE * __restrict__ _OldFile) ;



  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _wperror(const wchar_t *_ErrMsg);

  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) _wpopen(const wchar_t *_Command,const wchar_t *_Mode);



  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wremove(const wchar_t *_Filename);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wtmpnam(wchar_t *_Buffer);

  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _fgetwc_nolock(FILE *_File);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _fputwc_nolock(wchar_t _Ch,FILE *_File);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _ungetwc_nolock(wint_t _Ch,FILE *_File);
# 1228 "D:/Programs/MinGW/x86_64-w64-mingw32/include/wchar.h" 3
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _itow(int _Value,wchar_t *_Dest,int _Radix) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _ltow(long _Value,wchar_t *_Dest,int _Radix) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _ultow(unsigned long _Value,wchar_t *_Dest,int _Radix) ;
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _wcstod_l(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr,_locale_t _Locale);

  double __attribute__((__cdecl__)) __mingw_wcstod(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr);
  float __attribute__((__cdecl__)) __mingw_wcstof(const wchar_t * __restrict__ nptr, wchar_t ** __restrict__ endptr);
  long double __attribute__((__cdecl__)) __mingw_wcstold(const wchar_t * __restrict__, wchar_t ** __restrict__);
# 1248 "D:/Programs/MinGW/x86_64-w64-mingw32/include/wchar.h" 3
  double __attribute__((__cdecl__)) wcstod(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr);
  float __attribute__((__cdecl__)) wcstof(const wchar_t * __restrict__ nptr, wchar_t ** __restrict__ endptr);


  long double __attribute__((__cdecl__)) wcstold (const wchar_t * __restrict__, wchar_t ** __restrict__);

  long __attribute__((__cdecl__)) wcstol(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr,int _Radix);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _wcstol_l(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr,int _Radix,_locale_t _Locale);
  unsigned long __attribute__((__cdecl__)) wcstoul(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr,int _Radix);
  __attribute__ ((__dllimport__)) unsigned long __attribute__((__cdecl__)) _wcstoul_l(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr,int _Radix,_locale_t _Locale);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wgetenv(const wchar_t *_VarName) ;




  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _wtof(const wchar_t *_Str);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _wtof_l(const wchar_t *_Str,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wtoi(const wchar_t *_Str);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wtoi_l(const wchar_t *_Str,_locale_t _Locale);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _wtol(const wchar_t *_Str);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _wtol_l(const wchar_t *_Str,_locale_t _Locale);

  __extension__ __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _i64tow(long long _Val,wchar_t *_DstBuf,int _Radix) ;
  __extension__ __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _ui64tow(unsigned long long _Val,wchar_t *_DstBuf,int _Radix);
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _wtoi64(const wchar_t *_Str);
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _wtoi64_l(const wchar_t *_Str,_locale_t _Locale);
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _wcstoi64(const wchar_t *_Str,wchar_t **_EndPtr,int _Radix);
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _wcstoi64_l(const wchar_t *_Str,wchar_t **_EndPtr,int _Radix,_locale_t _Locale);
  __extension__ __attribute__ ((__dllimport__)) unsigned long long __attribute__((__cdecl__)) _wcstoui64(const wchar_t *_Str,wchar_t **_EndPtr,int _Radix);
  __extension__ __attribute__ ((__dllimport__)) unsigned long long __attribute__((__cdecl__)) _wcstoui64_l(const wchar_t *_Str,wchar_t **_EndPtr,int _Radix,_locale_t _Locale);





  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wfullpath(wchar_t *_FullPath,const wchar_t *_Path,size_t _SizeInWords);
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _wmakepath(wchar_t *_ResultPath,const wchar_t *_Drive,const wchar_t *_Dir,const wchar_t *_Filename,const wchar_t *_Ext);




  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wputenv(const wchar_t *_EnvString);
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _wsearchenv(const wchar_t *_Filename,const wchar_t *_EnvVar,wchar_t *_ResultPath) ;
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _wsplitpath(const wchar_t *_FullPath,wchar_t *_Drive,wchar_t *_Dir,wchar_t *_Filename,wchar_t *_Ext) ;
# 1358 "D:/Programs/MinGW/x86_64-w64-mingw32/include/wchar.h" 3
  struct tm {
    int tm_sec;
    int tm_min;
    int tm_hour;
    int tm_mday;
    int tm_mon;
    int tm_year;
    int tm_wday;
    int tm_yday;
    int tm_isdst;
  };





  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wasctime(const struct tm *_Tm);
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wasctime_s (wchar_t *_Buf,size_t _SizeInWords,const struct tm *_Tm);
  wchar_t *__attribute__((__cdecl__)) _wctime32(const __time32_t *_Time) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wctime32_s (wchar_t *_Buf,size_t _SizeInWords,const __time32_t *_Time);
  size_t __attribute__((__cdecl__)) wcsftime(wchar_t * __restrict__ _Buf,size_t _SizeInWords,const wchar_t * __restrict__ _Format,const struct tm * __restrict__ _Tm);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _wcsftime_l(wchar_t * __restrict__ _Buf,size_t _SizeInWords,const wchar_t * __restrict__ _Format,const struct tm * __restrict__ _Tm,_locale_t _Locale);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wstrdate(wchar_t *_Buffer) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wstrdate_s (wchar_t *_Buf,size_t _SizeInWords);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wstrtime(wchar_t *_Buffer) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wstrtime_s (wchar_t *_Buf,size_t _SizeInWords);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wctime64(const __time64_t *_Time) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wctime64_s (wchar_t *_Buf,size_t _SizeInWords,const __time64_t *_Time);



  wchar_t *__attribute__((__cdecl__)) _wctime(const time_t *_Time) ;
# 1401 "D:/Programs/MinGW/x86_64-w64-mingw32/include/wchar.h" 3
  errno_t __attribute__((__cdecl__)) _wctime_s(wchar_t *, size_t, const time_t *);
# 1414 "D:/Programs/MinGW/x86_64-w64-mingw32/include/wchar.h" 3
  typedef struct _Mbstatet {
    unsigned long _Wchar;
    unsigned short _Byte, _State;
  } _Mbstatet;
  typedef _Mbstatet mbstate_t;



  typedef wchar_t _Wint_t;

  wint_t __attribute__((__cdecl__)) btowc(int);
  size_t __attribute__((__cdecl__)) mbrlen(const char * __restrict__ _Ch,size_t _SizeInBytes,mbstate_t * __restrict__ _State);
  size_t __attribute__((__cdecl__)) mbrtowc(wchar_t * __restrict__ _DstCh,const char * __restrict__ _SrcCh,size_t _SizeInBytes,mbstate_t * __restrict__ _State);
  size_t __attribute__((__cdecl__)) mbsrtowcs(wchar_t * __restrict__ _Dest,const char ** __restrict__ _PSrc,size_t _Count,mbstate_t * __restrict__ _State) ;
  size_t __attribute__((__cdecl__)) wcrtomb(char * __restrict__ _Dest,wchar_t _Source,mbstate_t * __restrict__ _State) ;
  size_t __attribute__((__cdecl__)) wcsrtombs(char * __restrict__ _Dest,const wchar_t ** __restrict__ _PSource,size_t _Count,mbstate_t * __restrict__ _State) ;
  int __attribute__((__cdecl__)) wctob(wint_t _WCh);


  wchar_t *__attribute__((__cdecl__)) wmemset(wchar_t *s, wchar_t c, size_t n);
  wchar_t *__attribute__((__cdecl__)) wmemchr(const wchar_t *s, wchar_t c, size_t n);
  int __attribute__((__cdecl__)) wmemcmp(const wchar_t *s1, const wchar_t *s2,size_t n);
  wchar_t *__attribute__((__cdecl__)) wmemcpy(wchar_t * __restrict__ s1,const wchar_t * __restrict__ s2,size_t n) ;
  wchar_t * __attribute__((__cdecl__)) wmempcpy (wchar_t *_Dst, const wchar_t *_Src, size_t _Size);
  wchar_t *__attribute__((__cdecl__)) wmemmove(wchar_t *s1, const wchar_t *s2, size_t n) ;
  int __attribute__((__cdecl__)) fwide(FILE *stream,int mode);


  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) mbsinit(const mbstate_t *_P) { return (!_P || _P->_Wchar == 0); }



  __extension__ long long __attribute__((__cdecl__)) wcstoll(const wchar_t * __restrict__ nptr,wchar_t ** __restrict__ endptr, int base);
  __extension__ unsigned long long __attribute__((__cdecl__)) wcstoull(const wchar_t * __restrict__ nptr,wchar_t ** __restrict__ endptr, int base);


  void *__attribute__((__cdecl__)) memmove(void *_Dst,const void *_Src,size_t _MaxCount);
  void *__attribute__((__cdecl__)) memcpy(void * __restrict__ _Dst,const void * __restrict__ _Src,size_t _MaxCount) ;
# 1503 "D:/Programs/MinGW/x86_64-w64-mingw32/include/wchar.h" 3
int __attribute__((__cdecl__)) __mingw_str_wide_utf8 (const wchar_t * const wptr, char **mbptr, size_t * buflen);
# 1517 "D:/Programs/MinGW/x86_64-w64-mingw32/include/wchar.h" 3
int __attribute__((__cdecl__)) __mingw_str_utf8_wide (const char *const mbptr, wchar_t ** wptr, size_t * buflen);
# 1526 "D:/Programs/MinGW/x86_64-w64-mingw32/include/wchar.h" 3
void __attribute__((__cdecl__)) __mingw_str_free(void *ptr);




}


#pragma pack(pop)

# 1 "D:/Programs/MinGW/x86_64-w64-mingw32/include/sec_api/wchar_s.h" 1 3
# 9 "D:/Programs/MinGW/x86_64-w64-mingw32/include/sec_api/wchar_s.h" 3
# 1 "D:/Programs/MinGW/x86_64-w64-mingw32/include/wchar.h" 1 3
# 10 "D:/Programs/MinGW/x86_64-w64-mingw32/include/sec_api/wchar_s.h" 2 3
# 21 "D:/Programs/MinGW/x86_64-w64-mingw32/include/sec_api/wchar_s.h" 3
extern "C" {




  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _waccess_s (const wchar_t *_Filename,int _AccessMode);
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wmktemp_s (wchar_t *_TemplateName,size_t _SizeInWords);




  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _cgetws_s (wchar_t *_Buffer,size_t _SizeInWords,size_t *_SizeRead);
  __attribute__((dllimport)) int __attribute__((__cdecl__)) _cwprintf_s (const wchar_t *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _cwscanf_s(const wchar_t *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _cwscanf_s_l(const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__((dllimport)) int __attribute__((__cdecl__)) _vcwprintf_s (const wchar_t *_Format,va_list _ArgList);
  __attribute__((dllimport)) int __attribute__((__cdecl__)) _cwprintf_s_l (const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__((dllimport)) int __attribute__((__cdecl__)) _vcwprintf_s_l (const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);




  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _getws_s(wchar_t *_Str,size_t _SizeInWords);
  extern "C++" { template <size_t __size> inline wchar_t* __attribute__((__cdecl__)) _getws_s(wchar_t (&_DstBuf)[__size]) { return _getws_s(_DstBuf,__size); } }


  int __attribute__((__cdecl__)) __stdio_common_vswprintf_s(unsigned long long _Options, wchar_t *_Str, size_t _Len, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList);
  int __attribute__((__cdecl__)) __stdio_common_vsnwprintf_s(unsigned long long _Options, wchar_t *_Str, size_t _Len, size_t _MaxCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList);
  int __attribute__((__cdecl__)) __stdio_common_vfwprintf_s(unsigned long long _Options, FILE *_File, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList);

  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _vfwscanf_s_l(FILE *_File, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
  {
    return __stdio_common_vfwscanf(0x0002ULL | 0x0001ULL, _File, _Format, _Locale, _ArgList);
  }

  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) vfwscanf_s(FILE* _File, const wchar_t *_Format, va_list _ArgList)
  {
    return _vfwscanf_s_l(_File, _Format, __null, _ArgList);
  }

  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _vwscanf_s_l(const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
  {
    return _vfwscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
  }

  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) vwscanf_s(const wchar_t *_Format, va_list _ArgList)
  {
    return _vfwscanf_s_l((__acrt_iob_func(0)), _Format, __null, _ArgList);
  }

  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _fwscanf_s_l(FILE *_File, const wchar_t *_Format, _locale_t _Locale, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Locale);
    _Ret = _vfwscanf_s_l(_File, _Format, _Locale, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }

  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) fwscanf_s(FILE *_File, const wchar_t *_Format, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Format);
    _Ret = _vfwscanf_s_l(_File, _Format, __null, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }

  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _wscanf_s_l(const wchar_t *_Format, _locale_t _Locale, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Locale);
    _Ret = _vfwscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }

  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) wscanf_s(const wchar_t *_Format, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Format);
    _Ret = _vfwscanf_s_l((__acrt_iob_func(0)), _Format, __null, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }

  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _vswscanf_s_l(const wchar_t *_Src, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
  {
    return __stdio_common_vswscanf(0x0002ULL | 0x0001ULL, _Src, (size_t)-1, _Format, _Locale, _ArgList);
  }

  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) vswscanf_s(const wchar_t *_Src, const wchar_t *_Format, va_list _ArgList)
  {
    return _vswscanf_s_l(_Src, _Format, __null, _ArgList);
  }

  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _swscanf_s_l(const wchar_t *_Src, const wchar_t *_Format, _locale_t _Locale, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Locale);
    _Ret = _vswscanf_s_l(_Src, _Format, _Locale, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }
  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) swscanf_s(const wchar_t *_Src, const wchar_t *_Format, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Format);
    _Ret = _vswscanf_s_l(_Src, _Format, __null, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }

  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _vsnwscanf_s_l(const wchar_t *_Src, size_t _MaxCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
  {
    return __stdio_common_vswscanf(0x0002ULL | 0x0001ULL, _Src, _MaxCount, _Format, _Locale, _ArgList);
  }
  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _snwscanf_s_l(const wchar_t *_Src, size_t _MaxCount, const wchar_t *_Format, _locale_t _Locale, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Locale);
    _Ret = _vsnwscanf_s_l(_Src, _MaxCount, _Format, _Locale, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }
  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _snwscanf_s(const wchar_t *_Src, size_t _MaxCount, const wchar_t *_Format, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Format);
    _Ret = _vsnwscanf_s_l(_Src, _MaxCount, _Format, __null, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }

  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _vfwprintf_s_l(FILE *_File, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
  {
    return __stdio_common_vfwprintf_s(0x0004ULL, _File, _Format, _Locale, _ArgList);
  }
  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _vwprintf_s_l(const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
  {
    return _vfwprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
  }
  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) vfwprintf_s(FILE *_File, const wchar_t *_Format, va_list _ArgList)
  {
    return _vfwprintf_s_l(_File, _Format, __null, _ArgList);
  }
  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) vwprintf_s(const wchar_t *_Format, va_list _ArgList)
  {
    return _vfwprintf_s_l((__acrt_iob_func(1)), _Format, __null, _ArgList);
  }
  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _fwprintf_s_l(FILE *_File, const wchar_t *_Format, _locale_t _Locale, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Locale);
    _Ret = _vfwprintf_s_l(_File, _Format, _Locale, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }
  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _wprintf_s_l(const wchar_t *_Format, _locale_t _Locale, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Locale);
    _Ret = _vfwprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }
  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) fwprintf_s(FILE *_File, const wchar_t *_Format, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Format);
    _Ret = _vfwprintf_s_l(_File, _Format, __null, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }
  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) wprintf_s(const wchar_t *_Format, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Format);
    _Ret = _vfwprintf_s_l((__acrt_iob_func(1)), _Format, __null, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }

  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _vswprintf_s_l(wchar_t *_DstBuf, size_t _DstSize, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
  {
    return __stdio_common_vswprintf_s(0x0004ULL, _DstBuf, _DstSize, _Format, _Locale, _ArgList);
  }
  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) vswprintf_s(wchar_t *_DstBuf, size_t _DstSize, const wchar_t *_Format, va_list _ArgList)
  {
    return _vswprintf_s_l(_DstBuf, _DstSize, _Format, __null, _ArgList);
  }
  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _swprintf_s_l(wchar_t *_DstBuf, size_t _DstSize, const wchar_t *_Format, _locale_t _Locale, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Locale);
    _Ret = _vswprintf_s_l(_DstBuf, _DstSize, _Format, _Locale, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }
  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) swprintf_s(wchar_t *_DstBuf, size_t _DstSize, const wchar_t *_Format, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Format);
    _Ret = _vswprintf_s_l(_DstBuf, _DstSize, _Format, __null, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }

  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _vsnwprintf_s_l(wchar_t *_DstBuf, size_t _DstSize, size_t _MaxCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
  {
    return __stdio_common_vsnwprintf_s(0x0004ULL, _DstBuf, _DstSize, _MaxCount, _Format, _Locale, _ArgList);
  }
  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _vsnwprintf_s(wchar_t *_DstBuf, size_t _DstSize, size_t _MaxCount, const wchar_t *_Format, va_list _ArgList)
  {
    return _vsnwprintf_s_l(_DstBuf, _DstSize, _MaxCount, _Format, __null, _ArgList);
  }
  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _snwprintf_s_l(wchar_t *_DstBuf, size_t _DstSize, size_t _MaxCount, const wchar_t *_Format, _locale_t _Locale, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Locale);
    _Ret = _vsnwprintf_s_l(_DstBuf, _DstSize, _MaxCount, _Format, _Locale, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }
  inline __attribute__((__cdecl__)) int __attribute__((__cdecl__)) _snwprintf_s(wchar_t *_DstBuf, size_t _DstSize, size_t _MaxCount, const wchar_t *_Format, ...)
  {
    __builtin_va_list _ArgList;
    int _Ret;
    __builtin_va_start(_ArgList, _Format);
    _Ret = _vsnwprintf_s_l(_DstBuf, _DstSize, _MaxCount, _Format, __null, _ArgList);
    __builtin_va_end(_ArgList);
    return _Ret;
  }
# 302 "D:/Programs/MinGW/x86_64-w64-mingw32/include/sec_api/wchar_s.h" 3
  extern "C++" { template <size_t __size> inline int __attribute__((__cdecl__)) vswprintf_s(wchar_t (&_Dst)[__size], const wchar_t* _Format, va_list _ArgList) { return vswprintf_s(_Dst,__size,_Format,_ArgList); } }
  extern "C++" { template <size_t __size> inline int __attribute__((__cdecl__)) swprintf_s(wchar_t (&_Dst)[__size], const wchar_t* _Format, ...) { va_list __vaargs; __builtin_va_start(__vaargs,_Format); int __retval = vswprintf_s(_Dst,__size,_Format,__vaargs); __builtin_va_end(__vaargs); return __retval; } }
  extern "C++" { template <size_t __size> inline int __attribute__((__cdecl__)) _vsnwprintf_s(wchar_t (&_DstBuf)[__size], size_t _MaxCount, const wchar_t* _Format, va_list _ArgList) { return _vsnwprintf_s(_DstBuf,__size,_MaxCount,_Format,_ArgList); } }
  extern "C++" { template <size_t __size> inline int __attribute__((__cdecl__)) _snwprintf_s(wchar_t (&_DstBuf)[__size], size_t _MaxCount, const wchar_t* _Format, ...) { va_list __vaargs; __builtin_va_start(__vaargs,_Format); int __retval = _vsnwprintf_s(_DstBuf,__size,_MaxCount,_Format,__vaargs); __builtin_va_end(__vaargs); return __retval; } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wfopen_s(FILE **_File,const wchar_t *_Filename,const wchar_t *_Mode);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wfreopen_s(FILE **_File,const wchar_t *_Filename,const wchar_t *_Mode,FILE *_OldFile);

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wtmpnam_s(wchar_t *_DstBuf,size_t _SizeInWords);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _wtmpnam_s(wchar_t (&_DstBuf)[__size]) { return _wtmpnam_s(_DstBuf,__size); } }
# 360 "D:/Programs/MinGW/x86_64-w64-mingw32/include/sec_api/wchar_s.h" 3
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wasctime_s (wchar_t *_Buf,size_t _SizeInWords,const struct tm *_Tm);
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wctime32_s (wchar_t *_Buf,size_t _SizeInWords,const __time32_t *_Time);
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wstrdate_s (wchar_t *_Buf,size_t _SizeInWords);
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wstrtime_s (wchar_t *_Buf,size_t _SizeInWords);
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wctime64_s (wchar_t *_Buf,size_t _SizeInWords,const __time64_t *_Time);
# 375 "D:/Programs/MinGW/x86_64-w64-mingw32/include/sec_api/wchar_s.h" 3
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) mbsrtowcs_s(size_t *_Retval,wchar_t *_Dst,size_t _SizeInWords,const char **_PSrc,size_t _N,mbstate_t *_State);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) mbsrtowcs_s(size_t* _Retval, wchar_t (&_Dst)[__size], const char** _PSrc, size_t _N, mbstate_t _State) { return mbsrtowcs_s(_Retval, _Dst, __size, _PSrc, _N, _State); } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) wcrtomb_s(size_t *_Retval,char *_Dst,size_t _SizeInBytes,wchar_t _Ch,mbstate_t *_State);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) wcrtomb_s(size_t* _Retval, char (&_Dst)[__size], wchar_t _Ch, mbstate_t _State) { return wcrtomb_s(_Retval, _Dst, __size, _Ch, _State); } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) wcsrtombs_s(size_t *_Retval,char *_Dst,size_t _SizeInBytes,const wchar_t **_Src,size_t _Size,mbstate_t *_State);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) wcsrtombs_s(size_t _Retval, char (&_Dst)[__size], const wchar_t** _Src, size_t _Size, mbstate_t _State) { return wcsrtombs_s(_Retval, _Dst, __size, _Src, _Size, _State); } }

  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) wmemcpy_s (wchar_t *_dest,size_t _numberOfElements,const wchar_t *_src,size_t _count);
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) wmemmove_s(wchar_t *_dest,size_t _numberOfElements,const wchar_t *_src,size_t _count);



}
# 1537 "D:/Programs/MinGW/x86_64-w64-mingw32/include/wchar.h" 2 3
# 41 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h" 2
# 311 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"

# 311 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
typedef int8_t Sint8;
# 320 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
typedef uint8_t Uint8;
# 329 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
typedef int16_t Sint16;
# 338 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
typedef uint16_t Uint16;
# 347 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
typedef int32_t Sint32;
# 356 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
typedef uint32_t Uint32;
# 367 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
typedef int64_t Sint64;
# 378 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
typedef uint64_t Uint64;
# 395 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
typedef Sint64 SDL_Time;
# 500 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
static_assert(sizeof(long long) == 8, "sizeof(long long) == 8");
# 576 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
static_assert(sizeof(bool) == 1, "sizeof(bool) == 1");
static_assert(sizeof(Uint8) == 1, "sizeof(Uint8) == 1");
static_assert(sizeof(Sint8) == 1, "sizeof(Sint8) == 1");
static_assert(sizeof(Uint16) == 2, "sizeof(Uint16) == 2");
static_assert(sizeof(Sint16) == 2, "sizeof(Sint16) == 2");
static_assert(sizeof(Uint32) == 4, "sizeof(Uint32) == 4");
static_assert(sizeof(Sint32) == 4, "sizeof(Sint32) == 4");
static_assert(sizeof(Uint64) == 8, "sizeof(Uint64) == 8");
static_assert(sizeof(Sint64) == 8, "sizeof(Sint64) == 8");
static_assert(sizeof(Uint64) <= sizeof(unsigned long long), "sizeof(Uint64) <= sizeof(unsigned long long)");
static_assert(sizeof(size_t) <= sizeof(unsigned long long), "sizeof(size_t) <= sizeof(unsigned long long)");
typedef struct SDL_alignment_test
{
    Uint8 a;
    void *b;
} SDL_alignment_test;
static_assert(sizeof(SDL_alignment_test) == (2 * sizeof(void *)), "sizeof(SDL_alignment_test) == (2 * sizeof(void *))");
static_assert((int)~(int)0 == (int)(-1), "(int)~(int)0 == (int)(-1)");
# 607 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
typedef enum SDL_DUMMY_ENUM
{
    DUMMY_ENUM_VALUE
} SDL_DUMMY_ENUM;

static_assert(sizeof(SDL_DUMMY_ENUM) == sizeof(int), "sizeof(SDL_DUMMY_ENUM) == sizeof(int)");




# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_begin_code.h" 1
# 618 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h" 2


extern "C" {
# 699 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern __attribute__((malloc)) void * SDL_malloc(size_t size);
# 720 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern __attribute__((malloc)) __attribute__((alloc_size(1, 2))) void * SDL_calloc(size_t nmemb, size_t size);
# 755 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern __attribute__((alloc_size(2))) void * SDL_realloc(void *mem, size_t size);
# 775 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern void SDL_free(void *mem);
# 794 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
typedef void *( *SDL_malloc_func)(size_t size);
# 815 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
typedef void *( *SDL_calloc_func)(size_t nmemb, size_t size);
# 836 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
typedef void *( *SDL_realloc_func)(void *mem, size_t size);
# 854 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
typedef void ( *SDL_free_func)(void *mem);
# 873 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern void SDL_GetOriginalMemoryFunctions(SDL_malloc_func *malloc_func,
                                                            SDL_calloc_func *calloc_func,
                                                            SDL_realloc_func *realloc_func,
                                                            SDL_free_func *free_func);
# 895 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern void SDL_GetMemoryFunctions(SDL_malloc_func *malloc_func,
                                                    SDL_calloc_func *calloc_func,
                                                    SDL_realloc_func *realloc_func,
                                                    SDL_free_func *free_func);
# 926 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern bool SDL_SetMemoryFunctions(SDL_malloc_func malloc_func,
                                                            SDL_calloc_func calloc_func,
                                                            SDL_realloc_func realloc_func,
                                                            SDL_free_func free_func);
# 953 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern __attribute__((malloc)) void * SDL_aligned_alloc(size_t alignment, size_t size);
# 971 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern void SDL_aligned_free(void *mem);
# 982 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern int SDL_GetNumAllocations(void);
# 997 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
typedef struct SDL_Environment SDL_Environment;
# 1020 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern SDL_Environment * SDL_GetEnvironment(void);
# 1042 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern SDL_Environment * SDL_CreateEnvironment(bool populated);
# 1062 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern const char * SDL_GetEnvironmentVariable(SDL_Environment *env, const char *name);
# 1083 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern char ** SDL_GetEnvironmentVariables(SDL_Environment *env);
# 1107 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern bool SDL_SetEnvironmentVariable(SDL_Environment *env, const char *name, const char *value, bool overwrite);
# 1128 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern bool SDL_UnsetEnvironmentVariable(SDL_Environment *env, const char *name);
# 1142 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern void SDL_DestroyEnvironment(SDL_Environment *env);
# 1157 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern const char * SDL_getenv(const char *name);
# 1176 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern const char * SDL_getenv_unsafe(const char *name);
# 1194 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern int SDL_setenv_unsafe(const char *name, const char *value, int overwrite);
# 1209 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern int SDL_unsetenv_unsafe(const char *name);
# 1225 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
typedef int ( *SDL_CompareCallback)(const void *a, const void *b);
# 1269 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern void SDL_qsort(void *base, size_t nmemb, size_t size, SDL_CompareCallback compare);
# 1317 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern void * SDL_bsearch(const void *key, const void *base, size_t nmemb, size_t size, SDL_CompareCallback compare);
# 1334 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
typedef int ( *SDL_CompareCallback_r)(void *userdata, const void *a, const void *b);
# 1385 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern void SDL_qsort_r(void *base, size_t nmemb, size_t size, SDL_CompareCallback_r compare, void *userdata);
# 1441 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern void * SDL_bsearch_r(const void *key, const void *base, size_t nmemb, size_t size, SDL_CompareCallback_r compare, void *userdata);

extern int SDL_abs(int x);
# 1463 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern int SDL_isalpha(int x);
# 1478 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern int SDL_isalnum(int x);
# 1493 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern int SDL_isblank(int x);
# 1508 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern int SDL_iscntrl(int x);
# 1523 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern int SDL_isdigit(int x);
# 1538 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern int SDL_isxdigit(int x);
# 1556 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern int SDL_ispunct(int x);
# 1578 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern int SDL_isspace(int x);
# 1593 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern int SDL_isupper(int x);
# 1608 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern int SDL_islower(int x);
# 1627 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern int SDL_isprint(int x);
# 1648 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern int SDL_isgraph(int x);
# 1666 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern int SDL_toupper(int x);
# 1684 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern int SDL_tolower(int x);

extern Uint16 SDL_crc16(Uint16 crc, const void *data, size_t len);
extern Uint32 SDL_crc32(Uint32 crc, const void *data, size_t len);
extern Uint32 SDL_murmur3_32(const void *data, size_t len, Uint32 seed);
# 1708 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern void * SDL_memcpy( void *dst, const void *src, size_t len);
# 1739 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern void * SDL_memmove( void *dst, const void *src, size_t len);
# 1749 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern void * SDL_memset( void *dst, int c, size_t len);
extern void * SDL_memset4(void *dst, Uint32 val, size_t dwords);
# 1764 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern int SDL_memcmp(const void *s1, const void *s2, size_t len);

extern size_t SDL_wcslen(const wchar_t *wstr);
extern size_t SDL_wcsnlen(const wchar_t *wstr, size_t maxlen);
# 1794 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern size_t SDL_wcslcpy( wchar_t *dst, const wchar_t *src, size_t maxlen);
# 1823 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern size_t SDL_wcslcat( wchar_t *dst, const wchar_t *src, size_t maxlen);

extern wchar_t * SDL_wcsdup(const wchar_t *wstr);
extern wchar_t * SDL_wcsstr(const wchar_t *haystack, const wchar_t *needle);
extern wchar_t * SDL_wcsnstr(const wchar_t *haystack, const wchar_t *needle, size_t maxlen);
# 1846 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern int SDL_wcscmp(const wchar_t *str1, const wchar_t *str2);
# 1877 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern int SDL_wcsncmp(const wchar_t *str1, const wchar_t *str2, size_t maxlen);
# 1907 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern int SDL_wcscasecmp(const wchar_t *str1, const wchar_t *str2);
# 1949 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern int SDL_wcsncasecmp(const wchar_t *str1, const wchar_t *str2, size_t maxlen);
# 1976 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern long SDL_wcstol(const wchar_t *str, wchar_t **endp, int base);

extern size_t SDL_strlen(const char *str);
extern size_t SDL_strnlen(const char *str, size_t maxlen);
# 2008 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern size_t SDL_strlcpy( char *dst, const char *src, size_t maxlen);
# 2036 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern size_t SDL_utf8strlcpy( char *dst, const char *src, size_t dst_bytes);
# 2064 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern size_t SDL_strlcat( char *dst, const char *src, size_t maxlen);

extern __attribute__((malloc)) char * SDL_strdup(const char *str);
extern __attribute__((malloc)) char * SDL_strndup(const char *str, size_t maxlen);
extern char * SDL_strrev(char *str);
# 2089 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern char * SDL_strupr(char *str);
# 2110 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern char * SDL_strlwr(char *str);

extern char * SDL_strchr(const char *str, int c);
extern char * SDL_strrchr(const char *str, int c);
extern char * SDL_strstr(const char *haystack, const char *needle);
extern char * SDL_strnstr(const char *haystack, const char *needle, size_t maxlen);
extern char * SDL_strcasestr(const char *haystack, const char *needle);
extern char * SDL_strtok_r(char *s1, const char *s2, char **saveptr);
extern size_t SDL_utf8strlen(const char *str);
extern size_t SDL_utf8strnlen(const char *str, size_t bytes);

extern char * SDL_itoa(int value, char *str, int radix);
extern char * SDL_uitoa(unsigned int value, char *str, int radix);
extern char * SDL_ltoa(long value, char *str, int radix);
extern char * SDL_ultoa(unsigned long value, char *str, int radix);
extern char * SDL_lltoa(long long value, char *str, int radix);
extern char * SDL_ulltoa(unsigned long long value, char *str, int radix);
# 2149 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern int SDL_atoi(const char *str);
# 2171 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern double SDL_atof(const char *str);
# 2205 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern long SDL_strtol(const char *str, char **endp, int base);
# 2238 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern unsigned long SDL_strtoul(const char *str, char **endp, int base);
# 2271 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern long long SDL_strtoll(const char *str, char **endp, int base);
# 2305 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern unsigned long long SDL_strtoull(const char *str, char **endp, int base);
# 2334 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern double SDL_strtod(const char *str, char **endp);
# 2354 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern int SDL_strcmp(const char *str1, const char *str2);
# 2384 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern int SDL_strncmp(const char *str1, const char *str2, size_t maxlen);
# 2412 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern int SDL_strcasecmp(const char *str1, const char *str2);
# 2452 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern int SDL_strncasecmp(const char *str1, const char *str2, size_t maxlen);
# 2470 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern char * SDL_strpbrk(const char *str, const char *breakset);
# 2530 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern Uint32 SDL_StepUTF8(const char **pstr, size_t *pslen);
# 2561 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern Uint32 SDL_StepBackUTF8(const char *start, const char **pstr);
# 2590 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern char * SDL_UCS4ToUTF8(Uint32 codepoint, char *dst);


extern int SDL_sscanf(const char *text, const char *fmt, ...) __attribute__ (( format( __scanf__, 2, 2 +1 )));
extern int SDL_vsscanf(const char *text, const char *fmt, va_list ap) __attribute__(( format( __scanf__, 2, 0 )));
extern int SDL_snprintf( char *text, size_t maxlen, const char *fmt, ...) __attribute__ (( format( __printf__, 3, 3 +1 )));
extern int SDL_swprintf( wchar_t *text, size_t maxlen, const wchar_t *fmt, ...) ;
extern int SDL_vsnprintf( char *text, size_t maxlen, const char *fmt, va_list ap) __attribute__(( format( __printf__, 3, 0 )));
extern int SDL_vswprintf( wchar_t *text, size_t maxlen, const wchar_t *fmt, va_list ap) ;
extern int SDL_asprintf(char **strp, const char *fmt, ...) __attribute__ (( format( __printf__, 2, 2 +1 )));
extern int SDL_vasprintf(char **strp, const char *fmt, va_list ap) __attribute__(( format( __printf__, 2, 0 )));
# 2620 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern void SDL_srand(Uint64 seed);
# 2654 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern Sint32 SDL_rand(Sint32 n);
# 2677 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern float SDL_randf(void);
# 2700 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern Uint32 SDL_rand_bits(void);
# 2735 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern Sint32 SDL_rand_r(Uint64 *state, Sint32 n);
# 2762 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern float SDL_randf_r(Uint64 *state);
# 2787 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern Uint32 SDL_rand_bits_r(Uint64 *state);
# 2825 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern double SDL_acos(double x);
# 2855 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern float SDL_acosf(float x);
# 2885 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern double SDL_asin(double x);
# 2915 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern float SDL_asinf(float x);
# 2947 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern double SDL_atan(double x);
# 2979 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern float SDL_atanf(float x);
# 3015 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern double SDL_atan2(double y, double x);
# 3051 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern float SDL_atan2f(float y, float x);
# 3079 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern double SDL_ceil(double x);
# 3107 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern float SDL_ceilf(float x);
# 3133 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern double SDL_copysign(double x, double y);
# 3159 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern float SDL_copysignf(float x, float y);
# 3187 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern double SDL_cos(double x);
# 3215 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern float SDL_cosf(float x);
# 3247 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern double SDL_exp(double x);
# 3279 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern float SDL_expf(float x);
# 3300 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern double SDL_fabs(double x);
# 3321 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern float SDL_fabsf(float x);
# 3349 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern double SDL_floor(double x);
# 3377 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern float SDL_floorf(float x);
# 3406 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern double SDL_trunc(double x);
# 3435 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern float SDL_truncf(float x);
# 3465 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern double SDL_fmod(double x, double y);
# 3495 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern float SDL_fmodf(float x, float y);
# 3509 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern int SDL_isinf(double x);
# 3523 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern int SDL_isinff(float x);
# 3537 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern int SDL_isnan(double x);
# 3551 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern int SDL_isnanf(float x);
# 3581 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern double SDL_log(double x);
# 3610 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern float SDL_logf(float x);
# 3640 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern double SDL_log10(double x);
# 3670 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern float SDL_log10f(float x);
# 3690 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern double SDL_modf(double x, double *y);
# 3710 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern float SDL_modff(float x, float *y);
# 3742 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern double SDL_pow(double x, double y);
# 3774 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern float SDL_powf(float x, float y);
# 3803 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern double SDL_round(double x);
# 3832 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern float SDL_roundf(float x);
# 3861 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern long SDL_lround(double x);
# 3890 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern long SDL_lroundf(float x);
# 3915 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern double SDL_scalbn(double x, int n);
# 3940 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern float SDL_scalbnf(float x, int n);
# 3968 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern double SDL_sin(double x);
# 3996 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern float SDL_sinf(float x);
# 4022 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern double SDL_sqrt(double x);
# 4048 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern float SDL_sqrtf(float x);
# 4078 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern double SDL_tan(double x);
# 4108 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern float SDL_tanf(float x);







typedef struct SDL_iconv_data_t *SDL_iconv_t;
# 4133 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern SDL_iconv_t SDL_iconv_open(const char *tocode,
                                                   const char *fromcode);
# 4148 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern int SDL_iconv_close(SDL_iconv_t cd);
# 4185 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern size_t SDL_iconv(SDL_iconv_t cd, const char **inbuf,
                                         size_t *inbytesleft, char **outbuf,
                                         size_t *outbytesleft);
# 4214 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
extern char * SDL_iconv_string(const char *tocode,
                                               const char *fromcode,
                                               const char *inbuf,
                                               size_t inbytesleft);
# 4310 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
__attribute__((always_inline)) static __inline__ bool SDL_size_mul_check_overflow(size_t a, size_t b, size_t *ret)
{
    if (a != 0 && b > 
# 4312 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h" 3 4
                     0xffffffffffffffffULL 
# 4312 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
                                  / a) {
        return false;
    }
    *ret = a * b;
    return true;
}






__attribute__((always_inline)) static __inline__ bool SDL_size_mul_check_overflow_builtin(size_t a, size_t b, size_t *ret)
{
    return (__builtin_mul_overflow(a, b, ret) == 0);
}
# 4349 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
__attribute__((always_inline)) static __inline__ bool SDL_size_add_check_overflow(size_t a, size_t b, size_t *ret)
{
    if (b > 
# 4351 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h" 3 4
           0xffffffffffffffffULL 
# 4351 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
                        - a) {
        return false;
    }
    *ret = a + b;
    return true;
}





__attribute__((always_inline)) static __inline__ bool SDL_size_add_check_overflow_builtin(size_t a, size_t b, size_t *ret)
{
    return (__builtin_add_overflow(a, b, ret) == 0);
}
# 4392 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h"
typedef void (*SDL_FunctionPointer)(void);




}

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_close_code.h" 1
# 4400 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_stdinc.h" 2
# 33 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_rect.h" 2
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_error.h" 1
# 53 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_error.h"
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_begin_code.h" 1
# 54 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_error.h" 2


extern "C" {
# 87 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_error.h"
extern bool SDL_SetError( const char *fmt, ...) __attribute__ (( format( __printf__, 1, 1 +1 )));
# 104 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_error.h"
extern bool SDL_SetErrorV( const char *fmt, va_list ap) __attribute__(( format( __printf__, 1, 0 )));
# 115 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_error.h"
extern bool SDL_OutOfMemory(void);
# 150 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_error.h"
extern const char * SDL_GetError(void);
# 162 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_error.h"
extern bool SDL_ClearError(void);
# 177 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_error.h"
}

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_close_code.h" 1
# 180 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_error.h" 2
# 34 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_rect.h" 2

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_begin_code.h" 1
# 36 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_rect.h" 2


extern "C" {
# 49 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_rect.h"
typedef struct SDL_Point
{
    int x;
    int y;
} SDL_Point;
# 63 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_rect.h"
typedef struct SDL_FPoint
{
    float x;
    float y;
} SDL_FPoint;
# 83 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_rect.h"
typedef struct SDL_Rect
{
    int x, y;
    int w, h;
} SDL_Rect;
# 106 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_rect.h"
typedef struct SDL_FRect
{
    float x;
    float y;
    float w;
    float h;
} SDL_FRect;
# 126 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_rect.h"
__attribute__((always_inline)) static __inline__ void SDL_RectToFRect(const SDL_Rect *rect, SDL_FRect *frect)
{
    frect->x = (float)rect->x;
    frect->y = (float)rect->y;
    frect->w = (float)rect->w;
    frect->h = (float)rect->h;
}
# 155 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_rect.h"
__attribute__((always_inline)) static __inline__ bool SDL_PointInRect(const SDL_Point *p, const SDL_Rect *r)
{
    return ( p && r && (p->x >= r->x) && (p->x < (r->x + r->w)) &&
             (p->y >= r->y) && (p->y < (r->y + r->h)) ) ? true : false;
}
# 179 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_rect.h"
__attribute__((always_inline)) static __inline__ bool SDL_RectEmpty(const SDL_Rect *r)
{
    return ((!r) || (r->w <= 0) || (r->h <= 0)) ? true : false;
}
# 203 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_rect.h"
__attribute__((always_inline)) static __inline__ bool SDL_RectsEqual(const SDL_Rect *a, const SDL_Rect *b)
{
    return (a && b && (a->x == b->x) && (a->y == b->y) &&
            (a->w == b->w) && (a->h == b->h)) ? true : false;
}
# 224 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_rect.h"
extern bool SDL_HasRectIntersection(const SDL_Rect *A, const SDL_Rect *B);
# 241 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_rect.h"
extern bool SDL_GetRectIntersection(const SDL_Rect *A, const SDL_Rect *B, SDL_Rect *result);
# 255 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_rect.h"
extern bool SDL_GetRectUnion(const SDL_Rect *A, const SDL_Rect *B, SDL_Rect *result);
# 274 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_rect.h"
extern bool SDL_GetRectEnclosingPoints(const SDL_Point *points, int count, const SDL_Rect *clip, SDL_Rect *result);
# 294 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_rect.h"
extern bool SDL_GetRectAndLineIntersection(const SDL_Rect *rect, int *X1, int *Y1, int *X2, int *Y2);
# 320 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_rect.h"
__attribute__((always_inline)) static __inline__ bool SDL_PointInRectFloat(const SDL_FPoint *p, const SDL_FRect *r)
{
    return ( p && r && (p->x >= r->x) && (p->x <= (r->x + r->w)) &&
             (p->y >= r->y) && (p->y <= (r->y + r->h)) ) ? true : false;
}
# 344 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_rect.h"
__attribute__((always_inline)) static __inline__ bool SDL_RectEmptyFloat(const SDL_FRect *r)
{
    return ((!r) || (r->w < 0.0f) || (r->h < 0.0f)) ? true : false;
}
# 374 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_rect.h"
__attribute__((always_inline)) static __inline__ bool SDL_RectsEqualEpsilon(const SDL_FRect *a, const SDL_FRect *b, const float epsilon)
{
    return (a && b && ((a == b) ||
            ((SDL_fabsf(a->x - b->x) <= epsilon) &&
            (SDL_fabsf(a->y - b->y) <= epsilon) &&
            (SDL_fabsf(a->w - b->w) <= epsilon) &&
            (SDL_fabsf(a->h - b->h) <= epsilon))))
            ? true : false;
}
# 409 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_rect.h"
__attribute__((always_inline)) static __inline__ bool SDL_RectsEqualFloat(const SDL_FRect *a, const SDL_FRect *b)
{
    return SDL_RectsEqualEpsilon(a, b, 1.1920928955078125e-07F);
}
# 427 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_rect.h"
extern bool SDL_HasRectIntersectionFloat(const SDL_FRect *A, const SDL_FRect *B);
# 444 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_rect.h"
extern bool SDL_GetRectIntersectionFloat(const SDL_FRect *A, const SDL_FRect *B, SDL_FRect *result);
# 458 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_rect.h"
extern bool SDL_GetRectUnionFloat(const SDL_FRect *A, const SDL_FRect *B, SDL_FRect *result);
# 478 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_rect.h"
extern bool SDL_GetRectEnclosingPointsFloat(const SDL_FPoint *points, int count, const SDL_FRect *clip, SDL_FRect *result);
# 499 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_rect.h"
extern bool SDL_GetRectAndLineIntersectionFloat(const SDL_FRect *rect, float *X1, float *Y1, float *X2, float *Y2);



}

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_close_code.h" 1
# 506 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_rect.h" 2
# 4 "D:/Institute/Third_year/PZ_Networks/1_3/Client/Entities/Entity/Entity.h" 2
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h" 1
# 54 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_blendmode.h" 1
# 35 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_blendmode.h"
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_begin_code.h" 1
# 36 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_blendmode.h" 2


extern "C" {
# 52 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_blendmode.h"
typedef Uint32 SDL_BlendMode;
# 69 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_blendmode.h"
typedef enum SDL_BlendOperation
{
    SDL_BLENDOPERATION_ADD = 0x1,
    SDL_BLENDOPERATION_SUBTRACT = 0x2,
    SDL_BLENDOPERATION_REV_SUBTRACT = 0x3,
    SDL_BLENDOPERATION_MINIMUM = 0x4,
    SDL_BLENDOPERATION_MAXIMUM = 0x5
} SDL_BlendOperation;
# 88 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_blendmode.h"
typedef enum SDL_BlendFactor
{
    SDL_BLENDFACTOR_ZERO = 0x1,
    SDL_BLENDFACTOR_ONE = 0x2,
    SDL_BLENDFACTOR_SRC_COLOR = 0x3,
    SDL_BLENDFACTOR_ONE_MINUS_SRC_COLOR = 0x4,
    SDL_BLENDFACTOR_SRC_ALPHA = 0x5,
    SDL_BLENDFACTOR_ONE_MINUS_SRC_ALPHA = 0x6,
    SDL_BLENDFACTOR_DST_COLOR = 0x7,
    SDL_BLENDFACTOR_ONE_MINUS_DST_COLOR = 0x8,
    SDL_BLENDFACTOR_DST_ALPHA = 0x9,
    SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA = 0xA
} SDL_BlendFactor;
# 187 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_blendmode.h"
extern SDL_BlendMode SDL_ComposeCustomBlendMode(SDL_BlendFactor srcColorFactor,
                                                                 SDL_BlendFactor dstColorFactor,
                                                                 SDL_BlendOperation colorOperation,
                                                                 SDL_BlendFactor srcAlphaFactor,
                                                                 SDL_BlendFactor dstAlphaFactor,
                                                                 SDL_BlendOperation alphaOperation);



}

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_close_code.h" 1
# 199 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_blendmode.h" 2
# 55 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h" 2

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_events.h" 1
# 32 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_events.h"
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h" 1
# 92 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_endian.h" 1
# 122 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_endian.h"
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_begin_code.h" 1
# 123 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_endian.h" 2


extern "C" {
# 314 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_endian.h"
__attribute__((always_inline)) static __inline__ float SDL_SwapFloat(float x)
{
    union {
        float f;
        Uint32 ui32;
    } swapper;
    swapper.f = x;
    swapper.ui32 = __builtin_bswap32(swapper.ui32);
    return swapper.f;
}
# 531 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_endian.h"
}

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_close_code.h" 1
# 534 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_endian.h" 2
# 93 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h" 2

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mutex.h" 1
# 32 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mutex.h"
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_atomic.h" 1
# 56 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_atomic.h"
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_begin_code.h" 1
# 57 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_atomic.h" 2



extern "C" {
# 82 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_atomic.h"
typedef int SDL_SpinLock;
# 98 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_atomic.h"
extern bool SDL_TryLockSpinlock(SDL_SpinLock *lock);
# 113 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_atomic.h"
extern void SDL_LockSpinlock(SDL_SpinLock *lock);
# 130 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_atomic.h"
extern void SDL_UnlockSpinlock(SDL_SpinLock *lock);
# 194 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_atomic.h"
extern void SDL_MemoryBarrierReleaseFunction(void);
# 209 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_atomic.h"
extern void SDL_MemoryBarrierAcquireFunction(void);
# 328 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_atomic.h"
typedef struct SDL_AtomicInt { int value; } SDL_AtomicInt;
# 348 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_atomic.h"
extern bool SDL_CompareAndSwapAtomicInt(SDL_AtomicInt *a, int oldval, int newval);
# 368 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_atomic.h"
extern int SDL_SetAtomicInt(SDL_AtomicInt *a, int v);
# 385 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_atomic.h"
extern int SDL_GetAtomicInt(SDL_AtomicInt *a);
# 406 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_atomic.h"
extern int SDL_AddAtomicInt(SDL_AtomicInt *a, int v);
# 470 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_atomic.h"
typedef struct SDL_AtomicU32 { Uint32 value; } SDL_AtomicU32;
# 490 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_atomic.h"
extern bool SDL_CompareAndSwapAtomicU32(SDL_AtomicU32 *a, Uint32 oldval, Uint32 newval);
# 510 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_atomic.h"
extern Uint32 SDL_SetAtomicU32(SDL_AtomicU32 *a, Uint32 v);
# 527 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_atomic.h"
extern Uint32 SDL_GetAtomicU32(SDL_AtomicU32 *a);
# 548 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_atomic.h"
extern bool SDL_CompareAndSwapAtomicPointer(void **a, void *oldval, void *newval);
# 567 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_atomic.h"
extern void * SDL_SetAtomicPointer(void **a, void *v);
# 585 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_atomic.h"
extern void * SDL_GetAtomicPointer(void **a);



}


# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_close_code.h" 1
# 593 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_atomic.h" 2
# 33 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mutex.h" 2

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_thread.h" 1
# 33 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_thread.h"
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_properties.h" 1
# 55 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_properties.h"
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_begin_code.h" 1
# 56 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_properties.h" 2


extern "C" {







typedef Uint32 SDL_PropertiesID;






typedef enum SDL_PropertyType
{
    SDL_PROPERTY_TYPE_INVALID,
    SDL_PROPERTY_TYPE_POINTER,
    SDL_PROPERTY_TYPE_STRING,
    SDL_PROPERTY_TYPE_NUMBER,
    SDL_PROPERTY_TYPE_FLOAT,
    SDL_PROPERTY_TYPE_BOOLEAN
} SDL_PropertyType;
# 91 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_properties.h"
extern SDL_PropertiesID SDL_GetGlobalProperties(void);
# 107 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_properties.h"
extern SDL_PropertiesID SDL_CreateProperties(void);
# 126 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_properties.h"
extern bool SDL_CopyProperties(SDL_PropertiesID src, SDL_PropertiesID dst);
# 150 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_properties.h"
extern bool SDL_LockProperties(SDL_PropertiesID props);
# 163 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_properties.h"
extern void SDL_UnlockProperties(SDL_PropertiesID props);
# 187 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_properties.h"
typedef void ( *SDL_CleanupPropertyCallback)(void *userdata, void *value);
# 218 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_properties.h"
extern bool SDL_SetPointerPropertyWithCleanup(SDL_PropertiesID props, const char *name, void *value, SDL_CleanupPropertyCallback cleanup, void *userdata);
# 241 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_properties.h"
extern bool SDL_SetPointerProperty(SDL_PropertiesID props, const char *name, void *value);
# 261 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_properties.h"
extern bool SDL_SetStringProperty(SDL_PropertiesID props, const char *name, const char *value);
# 278 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_properties.h"
extern bool SDL_SetNumberProperty(SDL_PropertiesID props, const char *name, Sint64 value);
# 295 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_properties.h"
extern bool SDL_SetFloatProperty(SDL_PropertiesID props, const char *name, float value);
# 312 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_properties.h"
extern bool SDL_SetBooleanProperty(SDL_PropertiesID props, const char *name, bool value);
# 327 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_properties.h"
extern bool SDL_HasProperty(SDL_PropertiesID props, const char *name);
# 343 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_properties.h"
extern SDL_PropertyType SDL_GetPropertyType(SDL_PropertiesID props, const char *name);
# 376 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_properties.h"
extern void * SDL_GetPointerProperty(SDL_PropertiesID props, const char *name, void *default_value);
# 400 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_properties.h"
extern const char * SDL_GetStringProperty(SDL_PropertiesID props, const char *name, const char *default_value);
# 422 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_properties.h"
extern Sint64 SDL_GetNumberProperty(SDL_PropertiesID props, const char *name, Sint64 default_value);
# 444 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_properties.h"
extern float SDL_GetFloatProperty(SDL_PropertiesID props, const char *name, float default_value);
# 466 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_properties.h"
extern bool SDL_GetBooleanProperty(SDL_PropertiesID props, const char *name, bool default_value);
# 480 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_properties.h"
extern bool SDL_ClearProperty(SDL_PropertiesID props, const char *name);
# 499 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_properties.h"
typedef void ( *SDL_EnumeratePropertiesCallback)(void *userdata, SDL_PropertiesID props, const char *name);
# 517 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_properties.h"
extern bool SDL_EnumerateProperties(SDL_PropertiesID props, SDL_EnumeratePropertiesCallback callback, void *userdata);
# 535 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_properties.h"
extern void SDL_DestroyProperties(SDL_PropertiesID props);



}

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_close_code.h" 1
# 542 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_properties.h" 2
# 34 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_thread.h" 2





# 1 "D:/Programs/MinGW/x86_64-w64-mingw32/include/process.h" 1 3
# 10 "D:/Programs/MinGW/x86_64-w64-mingw32/include/process.h" 3
# 1 "D:/Programs/MinGW/x86_64-w64-mingw32/include/corecrt_startup.h" 1 3
# 11 "D:/Programs/MinGW/x86_64-w64-mingw32/include/corecrt_startup.h" 3

# 11 "D:/Programs/MinGW/x86_64-w64-mingw32/include/corecrt_startup.h" 3
extern "C" {


__attribute__ ((__dllimport__)) char **__attribute__((__cdecl__)) __p__acmdln(void);


__attribute__ ((__dllimport__)) wchar_t **__attribute__((__cdecl__)) __p__wcmdln(void);


typedef void (__attribute__((__cdecl__)) *_PVFV)(void);
typedef int (__attribute__((__cdecl__)) *_PIFV)(void);
typedef void (__attribute__((__cdecl__)) *_PVFI)(int);

typedef struct _onexit_table_t {
    _PVFV* _first;
    _PVFV* _last;
    _PVFV* _end;
} _onexit_table_t;

typedef int (__attribute__((__cdecl__)) *_onexit_t)(void);

__attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _initialize_onexit_table(_onexit_table_t*);
__attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _register_onexit_function(_onexit_table_t*,_onexit_t);
__attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _execute_onexit_table(_onexit_table_t*);
__attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _crt_atexit(_PVFV func);
__attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _crt_at_quick_exit(_PVFV func);


}
# 11 "D:/Programs/MinGW/x86_64-w64-mingw32/include/process.h" 2 3


# 1 "D:/Programs/MinGW/x86_64-w64-mingw32/include/sys/types.h" 1 3
# 62 "D:/Programs/MinGW/x86_64-w64-mingw32/include/sys/types.h" 3
__extension__
typedef long long _pid_t;




typedef _pid_t pid_t;





typedef unsigned short _mode_t;


typedef _mode_t mode_t;






typedef unsigned int useconds_t;




struct timespec {
  time_t tv_sec;
  long tv_nsec;
};

struct itimerspec {
  struct timespec it_interval;
  struct timespec it_value;
};





__extension__
typedef unsigned long long _sigset_t;
# 14 "D:/Programs/MinGW/x86_64-w64-mingw32/include/process.h" 2 3



extern "C" {
# 32 "D:/Programs/MinGW/x86_64-w64-mingw32/include/process.h" 3
  typedef void (__attribute__((__cdecl__)) *_beginthread_proc_type)(void *);
  typedef unsigned (__attribute__((__stdcall__)) *_beginthreadex_proc_type)(void *);

  __attribute__ ((__dllimport__)) uintptr_t __attribute__((__cdecl__)) _beginthread(_beginthread_proc_type _StartAddress,unsigned _StackSize,void *_ArgList);
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _endthread(void) __attribute__ ((__noreturn__));
  __attribute__ ((__dllimport__)) uintptr_t __attribute__((__cdecl__)) _beginthreadex(void *_Security,unsigned _StackSize,_beginthreadex_proc_type _StartAddress,void *_ArgList,unsigned _InitFlag,unsigned *_ThrdAddr);
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _endthreadex(unsigned _Retval) __attribute__ ((__noreturn__));



  void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) exit(int _Code) __attribute__ ((__noreturn__));
  void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _exit(int _Code) __attribute__ ((__noreturn__));

  void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) quick_exit(int _Code) __attribute__ ((__noreturn__));




  void __attribute__((__cdecl__)) _Exit(int) __attribute__ ((__noreturn__));






       

  void __attribute__((__cdecl__)) __attribute__ ((__noreturn__)) abort(void);
       



  typedef void (__attribute__((__stdcall__)) *_tls_callback_type)(void*,unsigned long,void*);
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _register_thread_local_exe_atexit_callback(_tls_callback_type callback);

  void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _cexit(void);
  void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _c_exit(void);

  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _getpid(void);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _cwait(int *_TermStat,intptr_t _ProcHandle,int _Action);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _execl(const char *_Filename,const char *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _execle(const char *_Filename,const char *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _execlp(const char *_Filename,const char *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _execlpe(const char *_Filename,const char *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _execv(const char *_Filename,const char *const *_ArgList);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _execve(const char *_Filename,const char *const *_ArgList,const char *const *_Env);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _execvp(const char *_Filename,const char *const *_ArgList);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _execvpe(const char *_Filename,const char *const *_ArgList,const char *const *_Env);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _spawnl(int _Mode,const char *_Filename,const char *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _spawnle(int _Mode,const char *_Filename,const char *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _spawnlp(int _Mode,const char *_Filename,const char *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _spawnlpe(int _Mode,const char *_Filename,const char *_ArgList,...);



  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _spawnv(int _Mode,const char *_Filename,const char *const *_ArgList);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _spawnve(int _Mode,const char *_Filename,const char *const *_ArgList,const char *const *_Env);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _spawnvp(int _Mode,const char *_Filename,const char *const *_ArgList);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _spawnvpe(int _Mode,const char *_Filename,const char *const *_ArgList,const char *const *_Env);




  int __attribute__((__cdecl__)) system(const char *_Command);
# 129 "D:/Programs/MinGW/x86_64-w64-mingw32/include/process.h" 3
  intptr_t __attribute__((__cdecl__)) _loaddll(char *_Filename);
  int __attribute__((__cdecl__)) _unloaddll(intptr_t _Handle);
  int (__attribute__((__cdecl__)) *__attribute__((__cdecl__)) _getdllprocaddr(intptr_t _Handle,char *_ProcedureName,intptr_t _Ordinal))(void);
# 161 "D:/Programs/MinGW/x86_64-w64-mingw32/include/process.h" 3
  int __attribute__((__cdecl__)) getpid(void) ;



  intptr_t __attribute__((__cdecl__)) cwait(int *_TermStat,intptr_t _ProcHandle,int _Action) ;

  int __attribute__((__cdecl__)) execl(const char *_Filename,const char *_ArgList,...) ;
  int __attribute__((__cdecl__)) execle(const char *_Filename,const char *_ArgList,...) ;
  int __attribute__((__cdecl__)) execlp(const char *_Filename,const char *_ArgList,...) ;
  int __attribute__((__cdecl__)) execlpe(const char *_Filename,const char *_ArgList,...) ;






  intptr_t __attribute__((__cdecl__)) spawnl(int,const char *_Filename,const char *_ArgList,...) ;
  intptr_t __attribute__((__cdecl__)) spawnle(int,const char *_Filename,const char *_ArgList,...) ;
  intptr_t __attribute__((__cdecl__)) spawnlp(int,const char *_Filename,const char *_ArgList,...) ;
  intptr_t __attribute__((__cdecl__)) spawnlpe(int,const char *_Filename,const char *_ArgList,...) ;





  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) execv(const char *_Filename,char *const _ArgList[]) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) execve(const char *_Filename,char *const _ArgList[],char *const _Env[]) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) execvp(const char *_Filename,char *const _ArgList[]) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) execvpe(const char *_Filename,char *const _ArgList[],char *const _Env[]) ;






  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) spawnv(int,const char *_Filename,char *const _ArgList[]) ;
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) spawnve(int,const char *_Filename,char *const _ArgList[],char *const _Env[]) ;
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) spawnvp(int,const char *_Filename,char *const _ArgList[]) ;
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) spawnvpe(int,const char *_Filename,char *const _ArgList[],char *const _Env[]) ;




}
# 40 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_thread.h" 2


# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_begin_code.h" 1
# 43 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_thread.h" 2



# 45 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_thread.h"
extern "C" {
# 58 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_thread.h"
typedef struct SDL_Thread SDL_Thread;
# 72 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_thread.h"
typedef Uint64 SDL_ThreadID;
# 85 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_thread.h"
typedef SDL_AtomicInt SDL_TLSID;
# 98 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_thread.h"
typedef enum SDL_ThreadPriority {
    SDL_THREAD_PRIORITY_LOW,
    SDL_THREAD_PRIORITY_NORMAL,
    SDL_THREAD_PRIORITY_HIGH,
    SDL_THREAD_PRIORITY_TIME_CRITICAL
} SDL_ThreadPriority;
# 113 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_thread.h"
typedef int ( * SDL_ThreadFunction) (void *data);
# 304 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_thread.h"
extern SDL_Thread * SDL_CreateThreadRuntime(SDL_ThreadFunction fn, const char *name, void *data, SDL_FunctionPointer pfnBeginThread, SDL_FunctionPointer pfnEndThread);
# 318 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_thread.h"
extern SDL_Thread * SDL_CreateThreadWithPropertiesRuntime(SDL_PropertiesID props, SDL_FunctionPointer pfnBeginThread, SDL_FunctionPointer pfnEndThread);
# 338 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_thread.h"
extern const char * SDL_GetThreadName(SDL_Thread *thread);
# 356 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_thread.h"
extern SDL_ThreadID SDL_GetCurrentThreadID(void);
# 373 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_thread.h"
extern SDL_ThreadID SDL_GetThreadID(SDL_Thread *thread);
# 388 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_thread.h"
extern bool SDL_SetCurrentThreadPriority(SDL_ThreadPriority priority);
# 423 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_thread.h"
extern void SDL_WaitThread(SDL_Thread *thread, int *status);
# 459 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_thread.h"
extern void SDL_DetachThread(SDL_Thread *thread);
# 474 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_thread.h"
extern void * SDL_GetTLS(SDL_TLSID *id);
# 487 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_thread.h"
typedef void ( *SDL_TLSDestructorCallback)(void *value);
# 515 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_thread.h"
extern bool SDL_SetTLS(SDL_TLSID *id, const void *value, SDL_TLSDestructorCallback destructor);
# 528 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_thread.h"
extern void SDL_CleanupTLS(void);



}

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_close_code.h" 1
# 535 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_thread.h" 2
# 35 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mutex.h" 2
# 114 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mutex.h"
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_begin_code.h" 1
# 115 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mutex.h" 2


extern "C" {
# 137 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mutex.h"
typedef struct SDL_Mutex SDL_Mutex;
# 159 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mutex.h"
extern SDL_Mutex * SDL_CreateMutex(void);
# 183 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mutex.h"
extern void SDL_LockMutex(SDL_Mutex *mutex) ;
# 204 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mutex.h"
extern bool SDL_TryLockMutex(SDL_Mutex *mutex) ;
# 223 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mutex.h"
extern void SDL_UnlockMutex(SDL_Mutex *mutex) ;
# 240 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mutex.h"
extern void SDL_DestroyMutex(SDL_Mutex *mutex);
# 268 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mutex.h"
typedef struct SDL_RWLock SDL_RWLock;
# 310 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mutex.h"
extern SDL_RWLock * SDL_CreateRWLock(void);
# 347 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mutex.h"
extern void SDL_LockRWLockForReading(SDL_RWLock *rwlock) ;
# 378 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mutex.h"
extern void SDL_LockRWLockForWriting(SDL_RWLock *rwlock) ;
# 403 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mutex.h"
extern bool SDL_TryLockRWLockForReading(SDL_RWLock *rwlock) ;
# 433 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mutex.h"
extern bool SDL_TryLockRWLockForWriting(SDL_RWLock *rwlock) ;
# 458 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mutex.h"
extern void SDL_UnlockRWLock(SDL_RWLock *rwlock) ;
# 475 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mutex.h"
extern void SDL_DestroyRWLock(SDL_RWLock *rwlock);
# 499 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mutex.h"
typedef struct SDL_Semaphore SDL_Semaphore;
# 523 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mutex.h"
extern SDL_Semaphore * SDL_CreateSemaphore(Uint32 initial_value);
# 537 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mutex.h"
extern void SDL_DestroySemaphore(SDL_Semaphore *sem);
# 557 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mutex.h"
extern void SDL_WaitSemaphore(SDL_Semaphore *sem);
# 576 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mutex.h"
extern bool SDL_TryWaitSemaphore(SDL_Semaphore *sem);
# 596 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mutex.h"
extern bool SDL_WaitSemaphoreTimeout(SDL_Semaphore *sem, Sint32 timeoutMS);
# 609 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mutex.h"
extern void SDL_SignalSemaphore(SDL_Semaphore *sem);
# 619 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mutex.h"
extern Uint32 SDL_GetSemaphoreValue(SDL_Semaphore *sem);
# 642 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mutex.h"
typedef struct SDL_Condition SDL_Condition;
# 658 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mutex.h"
extern SDL_Condition * SDL_CreateCondition(void);
# 669 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mutex.h"
extern void SDL_DestroyCondition(SDL_Condition *cond);
# 684 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mutex.h"
extern void SDL_SignalCondition(SDL_Condition *cond);
# 699 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mutex.h"
extern void SDL_BroadcastCondition(SDL_Condition *cond);
# 727 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mutex.h"
extern void SDL_WaitCondition(SDL_Condition *cond, SDL_Mutex *mutex);
# 757 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mutex.h"
extern bool SDL_WaitConditionTimeout(SDL_Condition *cond,
                                                SDL_Mutex *mutex, Sint32 timeoutMS);
# 772 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mutex.h"
typedef enum SDL_InitStatus
{
    SDL_INIT_STATUS_UNINITIALIZED,
    SDL_INIT_STATUS_INITIALIZING,
    SDL_INIT_STATUS_INITIALIZED,
    SDL_INIT_STATUS_UNINITIALIZING
} SDL_InitStatus;
# 836 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mutex.h"
typedef struct SDL_InitState
{
    SDL_AtomicInt status;
    SDL_ThreadID thread;
    void *reserved;
} SDL_InitState;
# 864 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mutex.h"
extern bool SDL_ShouldInit(SDL_InitState *state);
# 885 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mutex.h"
extern bool SDL_ShouldQuit(SDL_InitState *state);
# 904 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mutex.h"
extern void SDL_SetInitialized(SDL_InitState *state, bool initialized);





}

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_close_code.h" 1
# 913 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mutex.h" 2
# 95 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h" 2

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h" 1
# 42 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h"
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_begin_code.h" 1
# 43 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h" 2


extern "C" {







typedef enum SDL_IOStatus
{
    SDL_IO_STATUS_READY,
    SDL_IO_STATUS_ERROR,
    SDL_IO_STATUS_EOF,
    SDL_IO_STATUS_NOT_READY,
    SDL_IO_STATUS_READONLY,
    SDL_IO_STATUS_WRITEONLY
} SDL_IOStatus;
# 71 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h"
typedef enum SDL_IOWhence
{
    SDL_IO_SEEK_SET,
    SDL_IO_SEEK_CUR,
    SDL_IO_SEEK_END
} SDL_IOWhence;
# 92 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h"
typedef struct SDL_IOStreamInterface
{

    Uint32 version;






    Sint64 ( *size)(void *userdata);







    Sint64 ( *seek)(void *userdata, Sint64 offset, SDL_IOWhence whence);
# 122 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h"
    size_t ( *read)(void *userdata, void *ptr, size_t size, SDL_IOStatus *status);
# 134 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h"
    size_t ( *write)(void *userdata, const void *ptr, size_t size, SDL_IOStatus *status);
# 145 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h"
    bool ( *flush)(void *userdata, SDL_IOStatus *status);
# 158 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h"
    bool ( *close)(void *userdata);

} SDL_IOStreamInterface;







static_assert((sizeof(void *) == 4 && sizeof(SDL_IOStreamInterface) == 28) || (sizeof(void *) == 8 && sizeof(SDL_IOStreamInterface) == 56), "(sizeof(void *) == 4 && sizeof(SDL_IOStreamInterface) == 28) || (sizeof(void *) == 8 && sizeof(SDL_IOStreamInterface) == 56)")

                                                                 ;
# 182 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h"
typedef struct SDL_IOStream SDL_IOStream;
# 272 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h"
extern SDL_IOStream * SDL_IOFromFile(const char *file, const char *mode);
# 316 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h"
extern SDL_IOStream * SDL_IOFromMem(void *mem, size_t size);
# 358 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h"
extern SDL_IOStream * SDL_IOFromConstMem(const void *mem, size_t size);
# 386 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h"
extern SDL_IOStream * SDL_IOFromDynamicMem(void);
# 419 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h"
extern SDL_IOStream * SDL_OpenIO(const SDL_IOStreamInterface *iface, void *userdata);
# 449 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h"
extern bool SDL_CloseIO(SDL_IOStream *context);
# 460 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h"
extern SDL_PropertiesID SDL_GetIOProperties(SDL_IOStream *context);
# 481 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h"
extern SDL_IOStatus SDL_GetIOStatus(SDL_IOStream *context);
# 493 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h"
extern Sint64 SDL_GetIOSize(SDL_IOStream *context);
# 520 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h"
extern Sint64 SDL_SeekIO(SDL_IOStream *context, Sint64 offset, SDL_IOWhence whence);
# 538 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h"
extern Sint64 SDL_TellIO(SDL_IOStream *context);
# 560 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h"
extern size_t SDL_ReadIO(SDL_IOStream *context, void *ptr, size_t size);
# 590 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h"
extern size_t SDL_WriteIO(SDL_IOStream *context, const void *ptr, size_t size);
# 609 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h"
extern size_t SDL_IOprintf(SDL_IOStream *context, const char *fmt, ...) __attribute__ (( format( __printf__, 2, 2 +1 )));
# 627 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h"
extern size_t SDL_IOvprintf(SDL_IOStream *context, const char *fmt, va_list ap) __attribute__(( format( __printf__, 2, 0 )));
# 645 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h"
extern bool SDL_FlushIO(SDL_IOStream *context);
# 668 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h"
extern void * SDL_LoadFile_IO(SDL_IOStream *src, size_t *datasize, bool closeio);
# 688 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h"
extern void * SDL_LoadFile(const char *file, size_t *datasize);
# 707 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h"
extern bool SDL_ReadU8(SDL_IOStream *src, Uint8 *value);
# 719 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h"
extern bool SDL_ReadS8(SDL_IOStream *src, Sint8 *value);
# 735 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h"
extern bool SDL_ReadU16LE(SDL_IOStream *src, Uint16 *value);
# 751 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h"
extern bool SDL_ReadS16LE(SDL_IOStream *src, Sint16 *value);
# 767 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h"
extern bool SDL_ReadU16BE(SDL_IOStream *src, Uint16 *value);
# 783 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h"
extern bool SDL_ReadS16BE(SDL_IOStream *src, Sint16 *value);
# 799 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h"
extern bool SDL_ReadU32LE(SDL_IOStream *src, Uint32 *value);
# 815 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h"
extern bool SDL_ReadS32LE(SDL_IOStream *src, Sint32 *value);
# 831 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h"
extern bool SDL_ReadU32BE(SDL_IOStream *src, Uint32 *value);
# 847 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h"
extern bool SDL_ReadS32BE(SDL_IOStream *src, Sint32 *value);
# 863 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h"
extern bool SDL_ReadU64LE(SDL_IOStream *src, Uint64 *value);
# 879 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h"
extern bool SDL_ReadS64LE(SDL_IOStream *src, Sint64 *value);
# 895 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h"
extern bool SDL_ReadU64BE(SDL_IOStream *src, Uint64 *value);
# 911 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h"
extern bool SDL_ReadS64BE(SDL_IOStream *src, Sint64 *value);
# 931 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h"
extern bool SDL_WriteU8(SDL_IOStream *dst, Uint8 value);
# 943 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h"
extern bool SDL_WriteS8(SDL_IOStream *dst, Sint8 value);
# 960 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h"
extern bool SDL_WriteU16LE(SDL_IOStream *dst, Uint16 value);
# 977 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h"
extern bool SDL_WriteS16LE(SDL_IOStream *dst, Sint16 value);
# 993 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h"
extern bool SDL_WriteU16BE(SDL_IOStream *dst, Uint16 value);
# 1009 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h"
extern bool SDL_WriteS16BE(SDL_IOStream *dst, Sint16 value);
# 1026 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h"
extern bool SDL_WriteU32LE(SDL_IOStream *dst, Uint32 value);
# 1043 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h"
extern bool SDL_WriteS32LE(SDL_IOStream *dst, Sint32 value);
# 1059 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h"
extern bool SDL_WriteU32BE(SDL_IOStream *dst, Uint32 value);
# 1075 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h"
extern bool SDL_WriteS32BE(SDL_IOStream *dst, Sint32 value);
# 1092 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h"
extern bool SDL_WriteU64LE(SDL_IOStream *dst, Uint64 value);
# 1109 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h"
extern bool SDL_WriteS64LE(SDL_IOStream *dst, Sint64 value);
# 1125 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h"
extern bool SDL_WriteU64BE(SDL_IOStream *dst, Uint64 value);
# 1141 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h"
extern bool SDL_WriteS64BE(SDL_IOStream *dst, Sint64 value);





}

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_close_code.h" 1
# 1150 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_iostream.h" 2
# 97 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h" 2

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_begin_code.h" 1
# 99 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h" 2


extern "C" {
# 127 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
typedef enum SDL_AudioFormat
{
    SDL_AUDIO_UNKNOWN = 0x0000u,
    SDL_AUDIO_U8 = 0x0008u,

    SDL_AUDIO_S8 = 0x8008u,

    SDL_AUDIO_S16LE = 0x8010u,

    SDL_AUDIO_S16BE = 0x9010u,

    SDL_AUDIO_S32LE = 0x8020u,

    SDL_AUDIO_S32BE = 0x9020u,

    SDL_AUDIO_F32LE = 0x8120u,

    SDL_AUDIO_F32BE = 0x9120u,




    SDL_AUDIO_S16 = SDL_AUDIO_S16LE,
    SDL_AUDIO_S32 = SDL_AUDIO_S32LE,
    SDL_AUDIO_F32 = SDL_AUDIO_F32LE





} SDL_AudioFormat;
# 280 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
typedef Uint32 SDL_AudioDeviceID;
# 311 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
typedef struct SDL_AudioSpec
{
    SDL_AudioFormat format;
    int channels;
    int freq;
} SDL_AudioSpec;
# 357 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
typedef struct SDL_AudioStream SDL_AudioStream;
# 391 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
extern int SDL_GetNumAudioDrivers(void);
# 415 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
extern const char * SDL_GetAudioDriver(int index);
# 432 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
extern const char * SDL_GetCurrentAudioDriver(void);
# 461 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
extern SDL_AudioDeviceID * SDL_GetAudioPlaybackDevices(int *count);
# 490 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
extern SDL_AudioDeviceID * SDL_GetAudioRecordingDevices(int *count);
# 507 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
extern const char * SDL_GetAudioDeviceName(SDL_AudioDeviceID devid);
# 542 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
extern bool SDL_GetAudioDeviceFormat(SDL_AudioDeviceID devid, SDL_AudioSpec *spec, int *sample_frames);
# 565 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
extern int * SDL_GetAudioDeviceChannelMap(SDL_AudioDeviceID devid, int *count);
# 641 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
extern SDL_AudioDeviceID SDL_OpenAudioDevice(SDL_AudioDeviceID devid, const SDL_AudioSpec *spec);
# 672 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
extern bool SDL_PauseAudioDevice(SDL_AudioDeviceID dev);
# 700 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
extern bool SDL_ResumeAudioDevice(SDL_AudioDeviceID dev);
# 722 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
extern bool SDL_AudioDevicePaused(SDL_AudioDeviceID dev);
# 745 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
extern float SDL_GetAudioDeviceGain(SDL_AudioDeviceID devid);
# 780 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
extern bool SDL_SetAudioDeviceGain(SDL_AudioDeviceID devid, float gain);
# 801 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
extern void SDL_CloseAudioDevice(SDL_AudioDeviceID devid);
# 838 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
extern bool SDL_BindAudioStreams(SDL_AudioDeviceID devid, SDL_AudioStream **streams, int num_streams);
# 859 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
extern bool SDL_BindAudioStream(SDL_AudioDeviceID devid, SDL_AudioStream *stream);
# 879 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
extern void SDL_UnbindAudioStreams(SDL_AudioStream **streams, int num_streams);
# 895 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
extern void SDL_UnbindAudioStream(SDL_AudioStream *stream);
# 915 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
extern SDL_AudioDeviceID SDL_GetAudioStreamDevice(SDL_AudioStream *stream);
# 937 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
extern SDL_AudioStream * SDL_CreateAudioStream(const SDL_AudioSpec *src_spec, const SDL_AudioSpec *dst_spec);
# 948 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
extern SDL_PropertiesID SDL_GetAudioStreamProperties(SDL_AudioStream *stream);
# 966 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
extern bool SDL_GetAudioStreamFormat(SDL_AudioStream *stream, SDL_AudioSpec *src_spec, SDL_AudioSpec *dst_spec);
# 997 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
extern bool SDL_SetAudioStreamFormat(SDL_AudioStream *stream, const SDL_AudioSpec *src_spec, const SDL_AudioSpec *dst_spec);
# 1013 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
extern float SDL_GetAudioStreamFrequencyRatio(SDL_AudioStream *stream);
# 1041 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
extern bool SDL_SetAudioStreamFrequencyRatio(SDL_AudioStream *stream, float ratio);
# 1062 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
extern float SDL_GetAudioStreamGain(SDL_AudioStream *stream);
# 1087 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
extern bool SDL_SetAudioStreamGain(SDL_AudioStream *stream, float gain);
# 1111 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
extern int * SDL_GetAudioStreamInputChannelMap(SDL_AudioStream *stream, int *count);
# 1135 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
extern int * SDL_GetAudioStreamOutputChannelMap(SDL_AudioStream *stream, int *count);
# 1186 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
extern bool SDL_SetAudioStreamInputChannelMap(SDL_AudioStream *stream, const int *chmap, int count);
# 1233 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
extern bool SDL_SetAudioStreamOutputChannelMap(SDL_AudioStream *stream, const int *chmap, int count);
# 1263 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
extern bool SDL_PutAudioStreamData(SDL_AudioStream *stream, const void *buf, int len);
# 1293 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
extern int SDL_GetAudioStreamData(SDL_AudioStream *stream, void *buf, int len);
# 1319 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
extern int SDL_GetAudioStreamAvailable(SDL_AudioStream *stream);
# 1358 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
extern int SDL_GetAudioStreamQueued(SDL_AudioStream *stream);
# 1379 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
extern bool SDL_FlushAudioStream(SDL_AudioStream *stream);
# 1400 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
extern bool SDL_ClearAudioStream(SDL_AudioStream *stream);
# 1424 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
extern bool SDL_PauseAudioStreamDevice(SDL_AudioStream *stream);
# 1444 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
extern bool SDL_ResumeAudioStreamDevice(SDL_AudioStream *stream);
# 1472 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
extern bool SDL_LockAudioStream(SDL_AudioStream *stream);
# 1491 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
extern bool SDL_UnlockAudioStream(SDL_AudioStream *stream);
# 1533 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
typedef void ( *SDL_AudioStreamCallback)(void *userdata, SDL_AudioStream *stream, int additional_amount, int total_amount);
# 1579 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
extern bool SDL_SetAudioStreamGetCallback(SDL_AudioStream *stream, SDL_AudioStreamCallback callback, void *userdata);
# 1628 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
extern bool SDL_SetAudioStreamPutCallback(SDL_AudioStream *stream, SDL_AudioStreamCallback callback, void *userdata);
# 1650 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
extern void SDL_DestroyAudioStream(SDL_AudioStream *stream);
# 1713 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
extern SDL_AudioStream * SDL_OpenAudioDeviceStream(SDL_AudioDeviceID devid, const SDL_AudioSpec *spec, SDL_AudioStreamCallback callback, void *userdata);
# 1750 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
typedef void ( *SDL_AudioPostmixCallback)(void *userdata, const SDL_AudioSpec *spec, float *buffer, int buflen);
# 1804 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
extern bool SDL_SetAudioPostmixCallback(SDL_AudioDeviceID devid, SDL_AudioPostmixCallback callback, void *userdata);
# 1885 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
extern bool SDL_LoadWAV_IO(SDL_IOStream *src, bool closeio, SDL_AudioSpec *spec, Uint8 **audio_buf, Uint32 *audio_len);
# 1921 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
extern bool SDL_LoadWAV(const char *path, SDL_AudioSpec *spec, Uint8 **audio_buf, Uint32 *audio_len);
# 1957 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
extern bool SDL_MixAudio(Uint8 *dst, const Uint8 *src, SDL_AudioFormat format, Uint32 len, float volume);
# 1987 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
extern bool SDL_ConvertAudioSamples(const SDL_AudioSpec *src_spec, const Uint8 *src_data, int src_len, const SDL_AudioSpec *dst_spec, Uint8 **dst_data, int *dst_len);
# 2000 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
extern const char * SDL_GetAudioFormatName(SDL_AudioFormat format);
# 2016 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h"
extern int SDL_GetSilenceValueForFormat(SDL_AudioFormat format);




}

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_close_code.h" 1
# 2024 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_audio.h" 2
# 33 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_events.h" 2
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_camera.h" 1
# 38 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_camera.h"
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_pixels.h" 1
# 35 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_pixels.h"
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_begin_code.h" 1
# 36 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_pixels.h" 2


extern "C" {
# 82 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_pixels.h"
typedef enum SDL_PixelType
{
    SDL_PIXELTYPE_UNKNOWN,
    SDL_PIXELTYPE_INDEX1,
    SDL_PIXELTYPE_INDEX4,
    SDL_PIXELTYPE_INDEX8,
    SDL_PIXELTYPE_PACKED8,
    SDL_PIXELTYPE_PACKED16,
    SDL_PIXELTYPE_PACKED32,
    SDL_PIXELTYPE_ARRAYU8,
    SDL_PIXELTYPE_ARRAYU16,
    SDL_PIXELTYPE_ARRAYU32,
    SDL_PIXELTYPE_ARRAYF16,
    SDL_PIXELTYPE_ARRAYF32,

    SDL_PIXELTYPE_INDEX2
} SDL_PixelType;






typedef enum SDL_BitmapOrder
{
    SDL_BITMAPORDER_NONE,
    SDL_BITMAPORDER_4321,
    SDL_BITMAPORDER_1234
} SDL_BitmapOrder;






typedef enum SDL_PackedOrder
{
    SDL_PACKEDORDER_NONE,
    SDL_PACKEDORDER_XRGB,
    SDL_PACKEDORDER_RGBX,
    SDL_PACKEDORDER_ARGB,
    SDL_PACKEDORDER_RGBA,
    SDL_PACKEDORDER_XBGR,
    SDL_PACKEDORDER_BGRX,
    SDL_PACKEDORDER_ABGR,
    SDL_PACKEDORDER_BGRA
} SDL_PackedOrder;






typedef enum SDL_ArrayOrder
{
    SDL_ARRAYORDER_NONE,
    SDL_ARRAYORDER_RGB,
    SDL_ARRAYORDER_RGBA,
    SDL_ARRAYORDER_ARGB,
    SDL_ARRAYORDER_BGR,
    SDL_ARRAYORDER_BGRA,
    SDL_ARRAYORDER_ABGR
} SDL_ArrayOrder;






typedef enum SDL_PackedLayout
{
    SDL_PACKEDLAYOUT_NONE,
    SDL_PACKEDLAYOUT_332,
    SDL_PACKEDLAYOUT_4444,
    SDL_PACKEDLAYOUT_1555,
    SDL_PACKEDLAYOUT_5551,
    SDL_PACKEDLAYOUT_565,
    SDL_PACKEDLAYOUT_8888,
    SDL_PACKEDLAYOUT_2101010,
    SDL_PACKEDLAYOUT_1010102
} SDL_PackedLayout;
# 264 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_pixels.h"
typedef enum SDL_PixelFormat
{
    SDL_PIXELFORMAT_UNKNOWN = 0,
    SDL_PIXELFORMAT_INDEX1LSB = 0x11100100u,

    SDL_PIXELFORMAT_INDEX1MSB = 0x11200100u,

    SDL_PIXELFORMAT_INDEX2LSB = 0x1c100200u,

    SDL_PIXELFORMAT_INDEX2MSB = 0x1c200200u,

    SDL_PIXELFORMAT_INDEX4LSB = 0x12100400u,

    SDL_PIXELFORMAT_INDEX4MSB = 0x12200400u,

    SDL_PIXELFORMAT_INDEX8 = 0x13000801u,

    SDL_PIXELFORMAT_RGB332 = 0x14110801u,

    SDL_PIXELFORMAT_XRGB4444 = 0x15120c02u,

    SDL_PIXELFORMAT_XBGR4444 = 0x15520c02u,

    SDL_PIXELFORMAT_XRGB1555 = 0x15130f02u,

    SDL_PIXELFORMAT_XBGR1555 = 0x15530f02u,

    SDL_PIXELFORMAT_ARGB4444 = 0x15321002u,

    SDL_PIXELFORMAT_RGBA4444 = 0x15421002u,

    SDL_PIXELFORMAT_ABGR4444 = 0x15721002u,

    SDL_PIXELFORMAT_BGRA4444 = 0x15821002u,

    SDL_PIXELFORMAT_ARGB1555 = 0x15331002u,

    SDL_PIXELFORMAT_RGBA5551 = 0x15441002u,

    SDL_PIXELFORMAT_ABGR1555 = 0x15731002u,

    SDL_PIXELFORMAT_BGRA5551 = 0x15841002u,

    SDL_PIXELFORMAT_RGB565 = 0x15151002u,

    SDL_PIXELFORMAT_BGR565 = 0x15551002u,

    SDL_PIXELFORMAT_RGB24 = 0x17101803u,

    SDL_PIXELFORMAT_BGR24 = 0x17401803u,

    SDL_PIXELFORMAT_XRGB8888 = 0x16161804u,

    SDL_PIXELFORMAT_RGBX8888 = 0x16261804u,

    SDL_PIXELFORMAT_XBGR8888 = 0x16561804u,

    SDL_PIXELFORMAT_BGRX8888 = 0x16661804u,

    SDL_PIXELFORMAT_ARGB8888 = 0x16362004u,

    SDL_PIXELFORMAT_RGBA8888 = 0x16462004u,

    SDL_PIXELFORMAT_ABGR8888 = 0x16762004u,

    SDL_PIXELFORMAT_BGRA8888 = 0x16862004u,

    SDL_PIXELFORMAT_XRGB2101010 = 0x16172004u,

    SDL_PIXELFORMAT_XBGR2101010 = 0x16572004u,

    SDL_PIXELFORMAT_ARGB2101010 = 0x16372004u,

    SDL_PIXELFORMAT_ABGR2101010 = 0x16772004u,

    SDL_PIXELFORMAT_RGB48 = 0x18103006u,

    SDL_PIXELFORMAT_BGR48 = 0x18403006u,

    SDL_PIXELFORMAT_RGBA64 = 0x18204008u,

    SDL_PIXELFORMAT_ARGB64 = 0x18304008u,

    SDL_PIXELFORMAT_BGRA64 = 0x18504008u,

    SDL_PIXELFORMAT_ABGR64 = 0x18604008u,

    SDL_PIXELFORMAT_RGB48_FLOAT = 0x1a103006u,

    SDL_PIXELFORMAT_BGR48_FLOAT = 0x1a403006u,

    SDL_PIXELFORMAT_RGBA64_FLOAT = 0x1a204008u,

    SDL_PIXELFORMAT_ARGB64_FLOAT = 0x1a304008u,

    SDL_PIXELFORMAT_BGRA64_FLOAT = 0x1a504008u,

    SDL_PIXELFORMAT_ABGR64_FLOAT = 0x1a604008u,

    SDL_PIXELFORMAT_RGB96_FLOAT = 0x1b10600cu,

    SDL_PIXELFORMAT_BGR96_FLOAT = 0x1b40600cu,

    SDL_PIXELFORMAT_RGBA128_FLOAT = 0x1b208010u,

    SDL_PIXELFORMAT_ARGB128_FLOAT = 0x1b308010u,

    SDL_PIXELFORMAT_BGRA128_FLOAT = 0x1b508010u,

    SDL_PIXELFORMAT_ABGR128_FLOAT = 0x1b608010u,


    SDL_PIXELFORMAT_YV12 = 0x32315659u,

    SDL_PIXELFORMAT_IYUV = 0x56555949u,

    SDL_PIXELFORMAT_YUY2 = 0x32595559u,

    SDL_PIXELFORMAT_UYVY = 0x59565955u,

    SDL_PIXELFORMAT_YVYU = 0x55595659u,

    SDL_PIXELFORMAT_NV12 = 0x3231564eu,

    SDL_PIXELFORMAT_NV21 = 0x3132564eu,

    SDL_PIXELFORMAT_P010 = 0x30313050u,

    SDL_PIXELFORMAT_EXTERNAL_OES = 0x2053454fu,
# 406 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_pixels.h"
    SDL_PIXELFORMAT_RGBA32 = SDL_PIXELFORMAT_ABGR8888,
    SDL_PIXELFORMAT_ARGB32 = SDL_PIXELFORMAT_BGRA8888,
    SDL_PIXELFORMAT_BGRA32 = SDL_PIXELFORMAT_ARGB8888,
    SDL_PIXELFORMAT_ABGR32 = SDL_PIXELFORMAT_RGBA8888,
    SDL_PIXELFORMAT_RGBX32 = SDL_PIXELFORMAT_XBGR8888,
    SDL_PIXELFORMAT_XRGB32 = SDL_PIXELFORMAT_BGRX8888,
    SDL_PIXELFORMAT_BGRX32 = SDL_PIXELFORMAT_XRGB8888,
    SDL_PIXELFORMAT_XBGR32 = SDL_PIXELFORMAT_RGBX8888

} SDL_PixelFormat;
# 446 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_pixels.h"
typedef enum SDL_ColorType
{
    SDL_COLOR_TYPE_UNKNOWN = 0,
    SDL_COLOR_TYPE_RGB = 1,
    SDL_COLOR_TYPE_YCBCR = 2
} SDL_ColorType;







typedef enum SDL_ColorRange
{
    SDL_COLOR_RANGE_UNKNOWN = 0,
    SDL_COLOR_RANGE_LIMITED = 1,
    SDL_COLOR_RANGE_FULL = 2
} SDL_ColorRange;







typedef enum SDL_ColorPrimaries
{
    SDL_COLOR_PRIMARIES_UNKNOWN = 0,
    SDL_COLOR_PRIMARIES_BT709 = 1,
    SDL_COLOR_PRIMARIES_UNSPECIFIED = 2,
    SDL_COLOR_PRIMARIES_BT470M = 4,
    SDL_COLOR_PRIMARIES_BT470BG = 5,
    SDL_COLOR_PRIMARIES_BT601 = 6,
    SDL_COLOR_PRIMARIES_SMPTE240 = 7,
    SDL_COLOR_PRIMARIES_GENERIC_FILM = 8,
    SDL_COLOR_PRIMARIES_BT2020 = 9,
    SDL_COLOR_PRIMARIES_XYZ = 10,
    SDL_COLOR_PRIMARIES_SMPTE431 = 11,
    SDL_COLOR_PRIMARIES_SMPTE432 = 12,
    SDL_COLOR_PRIMARIES_EBU3213 = 22,
    SDL_COLOR_PRIMARIES_CUSTOM = 31
} SDL_ColorPrimaries;
# 497 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_pixels.h"
typedef enum SDL_TransferCharacteristics
{
    SDL_TRANSFER_CHARACTERISTICS_UNKNOWN = 0,
    SDL_TRANSFER_CHARACTERISTICS_BT709 = 1,
    SDL_TRANSFER_CHARACTERISTICS_UNSPECIFIED = 2,
    SDL_TRANSFER_CHARACTERISTICS_GAMMA22 = 4,
    SDL_TRANSFER_CHARACTERISTICS_GAMMA28 = 5,
    SDL_TRANSFER_CHARACTERISTICS_BT601 = 6,
    SDL_TRANSFER_CHARACTERISTICS_SMPTE240 = 7,
    SDL_TRANSFER_CHARACTERISTICS_LINEAR = 8,
    SDL_TRANSFER_CHARACTERISTICS_LOG100 = 9,
    SDL_TRANSFER_CHARACTERISTICS_LOG100_SQRT10 = 10,
    SDL_TRANSFER_CHARACTERISTICS_IEC61966 = 11,
    SDL_TRANSFER_CHARACTERISTICS_BT1361 = 12,
    SDL_TRANSFER_CHARACTERISTICS_SRGB = 13,
    SDL_TRANSFER_CHARACTERISTICS_BT2020_10BIT = 14,
    SDL_TRANSFER_CHARACTERISTICS_BT2020_12BIT = 15,
    SDL_TRANSFER_CHARACTERISTICS_PQ = 16,
    SDL_TRANSFER_CHARACTERISTICS_SMPTE428 = 17,
    SDL_TRANSFER_CHARACTERISTICS_HLG = 18,
    SDL_TRANSFER_CHARACTERISTICS_CUSTOM = 31
} SDL_TransferCharacteristics;
# 527 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_pixels.h"
typedef enum SDL_MatrixCoefficients
{
    SDL_MATRIX_COEFFICIENTS_IDENTITY = 0,
    SDL_MATRIX_COEFFICIENTS_BT709 = 1,
    SDL_MATRIX_COEFFICIENTS_UNSPECIFIED = 2,
    SDL_MATRIX_COEFFICIENTS_FCC = 4,
    SDL_MATRIX_COEFFICIENTS_BT470BG = 5,
    SDL_MATRIX_COEFFICIENTS_BT601 = 6,
    SDL_MATRIX_COEFFICIENTS_SMPTE240 = 7,
    SDL_MATRIX_COEFFICIENTS_YCGCO = 8,
    SDL_MATRIX_COEFFICIENTS_BT2020_NCL = 9,
    SDL_MATRIX_COEFFICIENTS_BT2020_CL = 10,
    SDL_MATRIX_COEFFICIENTS_SMPTE2085 = 11,
    SDL_MATRIX_COEFFICIENTS_CHROMA_DERIVED_NCL = 12,
    SDL_MATRIX_COEFFICIENTS_CHROMA_DERIVED_CL = 13,
    SDL_MATRIX_COEFFICIENTS_ICTCP = 14,
    SDL_MATRIX_COEFFICIENTS_CUSTOM = 31
} SDL_MatrixCoefficients;






typedef enum SDL_ChromaLocation
{
    SDL_CHROMA_LOCATION_NONE = 0,
    SDL_CHROMA_LOCATION_LEFT = 1,
    SDL_CHROMA_LOCATION_CENTER = 2,
    SDL_CHROMA_LOCATION_TOPLEFT = 3
} SDL_ChromaLocation;
# 593 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_pixels.h"
typedef enum SDL_Colorspace
{
    SDL_COLORSPACE_UNKNOWN = 0,


    SDL_COLORSPACE_SRGB = 0x120005a0u,
# 607 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_pixels.h"
    SDL_COLORSPACE_SRGB_LINEAR = 0x12000500u,
# 616 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_pixels.h"
    SDL_COLORSPACE_HDR10 = 0x12002600u,







    SDL_COLORSPACE_JPEG = 0x220004c6u,







    SDL_COLORSPACE_BT601_LIMITED = 0x211018c6u,







    SDL_COLORSPACE_BT601_FULL = 0x221018c6u,







    SDL_COLORSPACE_BT709_LIMITED = 0x21100421u,







    SDL_COLORSPACE_BT709_FULL = 0x22100421u,







    SDL_COLORSPACE_BT2020_LIMITED = 0x21102609u,







    SDL_COLORSPACE_BT2020_FULL = 0x22102609u,







    SDL_COLORSPACE_RGB_DEFAULT = SDL_COLORSPACE_SRGB,
    SDL_COLORSPACE_YUV_DEFAULT = SDL_COLORSPACE_JPEG
} SDL_Colorspace;
# 694 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_pixels.h"
typedef struct SDL_Color
{
    Uint8 r;
    Uint8 g;
    Uint8 b;
    Uint8 a;
} SDL_Color;







typedef struct SDL_FColor
{
    float r;
    float g;
    float b;
    float a;
} SDL_FColor;
# 723 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_pixels.h"
typedef struct SDL_Palette
{
    int ncolors;
    SDL_Color *colors;
    Uint32 version;
    int refcount;
} SDL_Palette;






typedef struct SDL_PixelFormatDetails
{
    SDL_PixelFormat format;
    Uint8 bits_per_pixel;
    Uint8 bytes_per_pixel;
    Uint8 padding[2];
    Uint32 Rmask;
    Uint32 Gmask;
    Uint32 Bmask;
    Uint32 Amask;
    Uint8 Rbits;
    Uint8 Gbits;
    Uint8 Bbits;
    Uint8 Abits;
    Uint8 Rshift;
    Uint8 Gshift;
    Uint8 Bshift;
    Uint8 Ashift;
} SDL_PixelFormatDetails;
# 767 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_pixels.h"
extern const char * SDL_GetPixelFormatName(SDL_PixelFormat format);
# 787 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_pixels.h"
extern bool SDL_GetMasksForPixelFormat(SDL_PixelFormat format, int *bpp, Uint32 *Rmask, Uint32 *Gmask, Uint32 *Bmask, Uint32 *Amask);
# 809 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_pixels.h"
extern SDL_PixelFormat SDL_GetPixelFormatForMasks(int bpp, Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask);
# 826 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_pixels.h"
extern const SDL_PixelFormatDetails * SDL_GetPixelFormatDetails(SDL_PixelFormat format);
# 846 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_pixels.h"
extern SDL_Palette * SDL_CreatePalette(int ncolors);
# 863 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_pixels.h"
extern bool SDL_SetPaletteColors(SDL_Palette *palette, const SDL_Color *colors, int firstcolor, int ncolors);
# 877 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_pixels.h"
extern void SDL_DestroyPalette(SDL_Palette *palette);
# 915 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_pixels.h"
extern Uint32 SDL_MapRGB(const SDL_PixelFormatDetails *format, const SDL_Palette *palette, Uint8 r, Uint8 g, Uint8 b);
# 954 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_pixels.h"
extern Uint32 SDL_MapRGBA(const SDL_PixelFormatDetails *format, const SDL_Palette *palette, Uint8 r, Uint8 g, Uint8 b, Uint8 a);
# 982 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_pixels.h"
extern void SDL_GetRGB(Uint32 pixel, const SDL_PixelFormatDetails *format, const SDL_Palette *palette, Uint8 *r, Uint8 *g, Uint8 *b);
# 1014 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_pixels.h"
extern void SDL_GetRGBA(Uint32 pixel, const SDL_PixelFormatDetails *format, const SDL_Palette *palette, Uint8 *r, Uint8 *g, Uint8 *b, Uint8 *a);




}

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_close_code.h" 1
# 1022 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_pixels.h" 2
# 39 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_camera.h" 2

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h" 1
# 51 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_begin_code.h" 1
# 52 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h" 2


extern "C" {
# 64 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
typedef Uint32 SDL_SurfaceFlags;
# 83 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
typedef enum SDL_ScaleMode
{
    SDL_SCALEMODE_NEAREST,
    SDL_SCALEMODE_LINEAR
} SDL_ScaleMode;






typedef enum SDL_FlipMode
{
    SDL_FLIP_NONE,
    SDL_FLIP_HORIZONTAL,
    SDL_FLIP_VERTICAL
} SDL_FlipMode;
# 123 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
struct SDL_Surface
{
    SDL_SurfaceFlags flags;
    SDL_PixelFormat format;
    int w;
    int h;
    int pitch;
    void *pixels;

    int refcount;

    void *reserved;
};


typedef struct SDL_Surface SDL_Surface;
# 156 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern SDL_Surface * SDL_CreateSurface(int width, int height, SDL_PixelFormat format);
# 184 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern SDL_Surface * SDL_CreateSurfaceFrom(int width, int height, SDL_PixelFormat format, void *pixels, int pitch);
# 199 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern void SDL_DestroySurface(SDL_Surface *surface);
# 227 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern SDL_PropertiesID SDL_GetSurfaceProperties(SDL_Surface *surface);
# 249 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern bool SDL_SetSurfaceColorspace(SDL_Surface *surface, SDL_Colorspace colorspace);
# 266 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern SDL_Colorspace SDL_GetSurfaceColorspace(SDL_Surface *surface);
# 294 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern SDL_Palette * SDL_CreateSurfacePalette(SDL_Surface *surface);
# 311 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern bool SDL_SetSurfacePalette(SDL_Surface *surface, SDL_Palette *palette);
# 324 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern SDL_Palette * SDL_GetSurfacePalette(SDL_Surface *surface);
# 349 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern bool SDL_AddSurfaceAlternateImage(SDL_Surface *surface, SDL_Surface *image);
# 363 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern bool SDL_SurfaceHasAlternateImages(SDL_Surface *surface);
# 388 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern SDL_Surface ** SDL_GetSurfaceImages(SDL_Surface *surface, int *count);
# 404 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern void SDL_RemoveSurfaceAlternateImages(SDL_Surface *surface);
# 427 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern bool SDL_LockSurface(SDL_Surface *surface);
# 438 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern void SDL_UnlockSurface(SDL_Surface *surface);
# 458 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern SDL_Surface * SDL_LoadBMP_IO(SDL_IOStream *src, bool closeio);
# 476 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern SDL_Surface * SDL_LoadBMP(const char *file);
# 499 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern bool SDL_SaveBMP_IO(SDL_Surface *surface, SDL_IOStream *dst, bool closeio);
# 520 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern bool SDL_SaveBMP(SDL_Surface *surface, const char *file);
# 539 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern bool SDL_SetSurfaceRLE(SDL_Surface *surface, bool enabled);
# 553 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern bool SDL_SurfaceHasRLE(SDL_Surface *surface);
# 577 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern bool SDL_SetSurfaceColorKey(SDL_Surface *surface, bool enabled, Uint32 key);
# 592 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern bool SDL_SurfaceHasColorKey(SDL_Surface *surface);
# 612 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern bool SDL_GetSurfaceColorKey(SDL_Surface *surface, Uint32 *key);
# 635 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern bool SDL_SetSurfaceColorMod(SDL_Surface *surface, Uint8 r, Uint8 g, Uint8 b);
# 653 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern bool SDL_GetSurfaceColorMod(SDL_Surface *surface, Uint8 *r, Uint8 *g, Uint8 *b);
# 673 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern bool SDL_SetSurfaceAlphaMod(SDL_Surface *surface, Uint8 alpha);
# 688 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern bool SDL_GetSurfaceAlphaMod(SDL_Surface *surface, Uint8 *alpha);
# 706 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern bool SDL_SetSurfaceBlendMode(SDL_Surface *surface, SDL_BlendMode blendMode);
# 720 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern bool SDL_GetSurfaceBlendMode(SDL_Surface *surface, SDL_BlendMode *blendMode);
# 741 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern bool SDL_SetSurfaceClipRect(SDL_Surface *surface, const SDL_Rect *rect);
# 760 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern bool SDL_GetSurfaceClipRect(SDL_Surface *surface, SDL_Rect *rect);
# 772 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern bool SDL_FlipSurface(SDL_Surface *surface, SDL_FlipMode flip);
# 790 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern SDL_Surface * SDL_DuplicateSurface(SDL_Surface *surface);
# 809 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern SDL_Surface * SDL_ScaleSurface(SDL_Surface *surface, int width, int height, SDL_ScaleMode scaleMode);
# 835 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern SDL_Surface * SDL_ConvertSurface(SDL_Surface *surface, SDL_PixelFormat format);
# 862 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern SDL_Surface * SDL_ConvertSurfaceAndColorspace(SDL_Surface *surface, SDL_PixelFormat format, SDL_Palette *palette, SDL_Colorspace colorspace, SDL_PropertiesID props);
# 882 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern bool SDL_ConvertPixels(int width, int height, SDL_PixelFormat src_format, const void *src, int src_pitch, SDL_PixelFormat dst_format, void *dst, int dst_pitch);
# 911 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern bool SDL_ConvertPixelsAndColorspace(int width, int height, SDL_PixelFormat src_format, SDL_Colorspace src_colorspace, SDL_PropertiesID src_properties, const void *src, int src_pitch, SDL_PixelFormat dst_format, SDL_Colorspace dst_colorspace, SDL_PropertiesID dst_properties, void *dst, int dst_pitch);
# 933 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern bool SDL_PremultiplyAlpha(int width, int height, SDL_PixelFormat src_format, const void *src, int src_pitch, SDL_PixelFormat dst_format, void *dst, int dst_pitch, bool linear);
# 948 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern bool SDL_PremultiplySurfaceAlpha(SDL_Surface *surface, bool linear);
# 968 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern bool SDL_ClearSurface(SDL_Surface *surface, float r, float g, float b, float a);
# 993 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern bool SDL_FillSurfaceRect(SDL_Surface *dst, const SDL_Rect *rect, Uint32 color);
# 1018 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern bool SDL_FillSurfaceRects(SDL_Surface *dst, const SDL_Rect *rects, int count, Uint32 color);
# 1093 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern bool SDL_BlitSurface(SDL_Surface *src, const SDL_Rect *srcrect, SDL_Surface *dst, const SDL_Rect *dstrect);
# 1118 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern bool SDL_BlitSurfaceUnchecked(SDL_Surface *src, const SDL_Rect *srcrect, SDL_Surface *dst, const SDL_Rect *dstrect);
# 1143 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern bool SDL_BlitSurfaceScaled(SDL_Surface *src, const SDL_Rect *srcrect, SDL_Surface *dst, const SDL_Rect *dstrect, SDL_ScaleMode scaleMode);
# 1169 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern bool SDL_BlitSurfaceUncheckedScaled(SDL_Surface *src, const SDL_Rect *srcrect, SDL_Surface *dst, const SDL_Rect *dstrect, SDL_ScaleMode scaleMode);
# 1195 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern bool SDL_BlitSurfaceTiled(SDL_Surface *src, const SDL_Rect *srcrect, SDL_Surface *dst, const SDL_Rect *dstrect);
# 1225 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern bool SDL_BlitSurfaceTiledWithScale(SDL_Surface *src, const SDL_Rect *srcrect, float scale, SDL_ScaleMode scaleMode, SDL_Surface *dst, const SDL_Rect *dstrect);
# 1262 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern bool SDL_BlitSurface9Grid(SDL_Surface *src, const SDL_Rect *srcrect, int left_width, int right_width, int top_height, int bottom_height, float scale, SDL_ScaleMode scaleMode, SDL_Surface *dst, const SDL_Rect *dstrect);
# 1292 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern Uint32 SDL_MapSurfaceRGB(SDL_Surface *surface, Uint8 r, Uint8 g, Uint8 b);
# 1323 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern Uint32 SDL_MapSurfaceRGBA(SDL_Surface *surface, Uint8 r, Uint8 g, Uint8 b, Uint8 a);
# 1350 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern bool SDL_ReadSurfacePixel(SDL_Surface *surface, int x, int y, Uint8 *r, Uint8 *g, Uint8 *b, Uint8 *a);
# 1374 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern bool SDL_ReadSurfacePixelFloat(SDL_Surface *surface, int x, int y, float *r, float *g, float *b, float *a);
# 1397 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern bool SDL_WriteSurfacePixel(SDL_Surface *surface, int x, int y, Uint8 r, Uint8 g, Uint8 b, Uint8 a);
# 1417 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h"
extern bool SDL_WriteSurfacePixelFloat(SDL_Surface *surface, int x, int y, float r, float g, float b, float a);



}

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_close_code.h" 1
# 1424 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_surface.h" 2
# 41 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_camera.h" 2

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_begin_code.h" 1
# 43 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_camera.h" 2


extern "C" {
# 60 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_camera.h"
typedef Uint32 SDL_CameraID;






typedef struct SDL_Camera SDL_Camera;
# 80 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_camera.h"
typedef struct SDL_CameraSpec
{
    SDL_PixelFormat format;
    SDL_Colorspace colorspace;
    int width;
    int height;
    int framerate_numerator;
    int framerate_denominator;
} SDL_CameraSpec;
# 97 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_camera.h"
typedef enum SDL_CameraPosition
{
    SDL_CAMERA_POSITION_UNKNOWN,
    SDL_CAMERA_POSITION_FRONT_FACING,
    SDL_CAMERA_POSITION_BACK_FACING
} SDL_CameraPosition;
# 126 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_camera.h"
extern int SDL_GetNumCameraDrivers(void);
# 150 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_camera.h"
extern const char * SDL_GetCameraDriver(int index);
# 166 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_camera.h"
extern const char * SDL_GetCurrentCameraDriver(void);
# 183 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_camera.h"
extern SDL_CameraID * SDL_GetCameras(int *count);
# 222 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_camera.h"
extern SDL_CameraSpec ** SDL_GetCameraSupportedFormats(SDL_CameraID devid, int *count);
# 237 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_camera.h"
extern const char * SDL_GetCameraName(SDL_CameraID instance_id);
# 256 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_camera.h"
extern SDL_CameraPosition SDL_GetCameraPosition(SDL_CameraID instance_id);
# 303 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_camera.h"
extern SDL_Camera * SDL_OpenCamera(SDL_CameraID instance_id, const SDL_CameraSpec *spec);
# 336 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_camera.h"
extern int SDL_GetCameraPermissionState(SDL_Camera *camera);
# 351 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_camera.h"
extern SDL_CameraID SDL_GetCameraID(SDL_Camera *camera);
# 364 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_camera.h"
extern SDL_PropertiesID SDL_GetCameraProperties(SDL_Camera *camera);
# 390 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_camera.h"
extern bool SDL_GetCameraFormat(SDL_Camera *camera, SDL_CameraSpec *spec);
# 433 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_camera.h"
extern SDL_Surface * SDL_AcquireCameraFrame(SDL_Camera *camera, Uint64 *timestampNS);
# 461 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_camera.h"
extern void SDL_ReleaseCameraFrame(SDL_Camera *camera, SDL_Surface *frame);
# 477 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_camera.h"
extern void SDL_CloseCamera(SDL_Camera *camera);



}

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_close_code.h" 1
# 484 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_camera.h" 2
# 34 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_events.h" 2

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h" 1
# 61 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_guid.h" 1
# 36 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_guid.h"
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_begin_code.h" 1
# 37 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_guid.h" 2


extern "C" {
# 59 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_guid.h"
typedef struct SDL_GUID {
    Uint8 data[16];
} SDL_GUID;
# 76 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_guid.h"
extern void SDL_GUIDToString(SDL_GUID guid, char *pszGUID, int cbGUID);
# 92 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_guid.h"
extern SDL_GUID SDL_StringToGUID(const char *pchGUID);



}

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_close_code.h" 1
# 99 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_guid.h" 2
# 62 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h" 2

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h" 1
# 60 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_power.h" 1
# 34 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_power.h"
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_begin_code.h" 1
# 35 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_power.h" 2


extern "C" {
# 47 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_power.h"
typedef enum SDL_PowerState
{
    SDL_POWERSTATE_ERROR = -1,
    SDL_POWERSTATE_UNKNOWN,
    SDL_POWERSTATE_ON_BATTERY,
    SDL_POWERSTATE_NO_BATTERY,
    SDL_POWERSTATE_CHARGING,
    SDL_POWERSTATE_CHARGED
} SDL_PowerState;
# 85 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_power.h"
extern SDL_PowerState SDL_GetPowerInfo(int *seconds, int *percent);



}

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_close_code.h" 1
# 92 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_power.h" 2
# 61 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h" 2

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_sensor.h" 1
# 39 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_sensor.h"
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_begin_code.h" 1
# 40 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_sensor.h" 2



extern "C" {



typedef struct SDL_Sensor SDL_Sensor;
# 57 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_sensor.h"
typedef Uint32 SDL_SensorID;
# 125 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_sensor.h"
typedef enum SDL_SensorType
{
    SDL_SENSOR_INVALID = -1,
    SDL_SENSOR_UNKNOWN,
    SDL_SENSOR_ACCEL,
    SDL_SENSOR_GYRO,
    SDL_SENSOR_ACCEL_L,
    SDL_SENSOR_GYRO_L,
    SDL_SENSOR_ACCEL_R,
    SDL_SENSOR_GYRO_R
} SDL_SensorType;
# 151 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_sensor.h"
extern SDL_SensorID * SDL_GetSensors(int *count);
# 163 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_sensor.h"
extern const char * SDL_GetSensorNameForID(SDL_SensorID instance_id);
# 176 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_sensor.h"
extern SDL_SensorType SDL_GetSensorTypeForID(SDL_SensorID instance_id);
# 189 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_sensor.h"
extern int SDL_GetSensorNonPortableTypeForID(SDL_SensorID instance_id);
# 200 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_sensor.h"
extern SDL_Sensor * SDL_OpenSensor(SDL_SensorID instance_id);
# 211 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_sensor.h"
extern SDL_Sensor * SDL_GetSensorFromID(SDL_SensorID instance_id);
# 222 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_sensor.h"
extern SDL_PropertiesID SDL_GetSensorProperties(SDL_Sensor *sensor);
# 233 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_sensor.h"
extern const char * SDL_GetSensorName(SDL_Sensor *sensor);
# 244 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_sensor.h"
extern SDL_SensorType SDL_GetSensorType(SDL_Sensor *sensor);
# 254 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_sensor.h"
extern int SDL_GetSensorNonPortableType(SDL_Sensor *sensor);
# 265 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_sensor.h"
extern SDL_SensorID SDL_GetSensorID(SDL_Sensor *sensor);
# 280 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_sensor.h"
extern bool SDL_GetSensorData(SDL_Sensor *sensor, float *data, int num_values);
# 289 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_sensor.h"
extern void SDL_CloseSensor(SDL_Sensor *sensor);
# 302 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_sensor.h"
extern void SDL_UpdateSensors(void);





}


# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_close_code.h" 1
# 312 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_sensor.h" 2
# 63 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h" 2

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_begin_code.h" 1
# 65 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h" 2


extern "C" {
# 86 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
typedef struct SDL_Joystick SDL_Joystick;
# 98 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
typedef Uint32 SDL_JoystickID;
# 112 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
typedef enum SDL_JoystickType
{
    SDL_JOYSTICK_TYPE_UNKNOWN,
    SDL_JOYSTICK_TYPE_GAMEPAD,
    SDL_JOYSTICK_TYPE_WHEEL,
    SDL_JOYSTICK_TYPE_ARCADE_STICK,
    SDL_JOYSTICK_TYPE_FLIGHT_STICK,
    SDL_JOYSTICK_TYPE_DANCE_PAD,
    SDL_JOYSTICK_TYPE_GUITAR,
    SDL_JOYSTICK_TYPE_DRUM_KIT,
    SDL_JOYSTICK_TYPE_ARCADE_PAD,
    SDL_JOYSTICK_TYPE_THROTTLE,
    SDL_JOYSTICK_TYPE_COUNT
} SDL_JoystickType;
# 135 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
typedef enum SDL_JoystickConnectionState
{
    SDL_JOYSTICK_CONNECTION_INVALID = -1,
    SDL_JOYSTICK_CONNECTION_UNKNOWN,
    SDL_JOYSTICK_CONNECTION_WIRED,
    SDL_JOYSTICK_CONNECTION_WIRELESS
} SDL_JoystickConnectionState;
# 175 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern void SDL_LockJoysticks(void) ;






extern void SDL_UnlockJoysticks(void) ;
# 193 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern bool SDL_HasJoystick(void);
# 209 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern SDL_JoystickID * SDL_GetJoysticks(int *count);
# 225 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern const char * SDL_GetJoystickNameForID(SDL_JoystickID instance_id);
# 241 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern const char * SDL_GetJoystickPathForID(SDL_JoystickID instance_id);
# 256 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern int SDL_GetJoystickPlayerIndexForID(SDL_JoystickID instance_id);
# 272 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern SDL_GUID SDL_GetJoystickGUIDForID(SDL_JoystickID instance_id);
# 289 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern Uint16 SDL_GetJoystickVendorForID(SDL_JoystickID instance_id);
# 306 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern Uint16 SDL_GetJoystickProductForID(SDL_JoystickID instance_id);
# 323 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern Uint16 SDL_GetJoystickProductVersionForID(SDL_JoystickID instance_id);
# 340 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern SDL_JoystickType SDL_GetJoystickTypeForID(SDL_JoystickID instance_id);
# 356 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern SDL_Joystick * SDL_OpenJoystick(SDL_JoystickID instance_id);
# 367 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern SDL_Joystick * SDL_GetJoystickFromID(SDL_JoystickID instance_id);
# 381 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern SDL_Joystick * SDL_GetJoystickFromPlayerIndex(int player_index);
# 390 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
typedef struct SDL_VirtualJoystickTouchpadDesc
{
    Uint16 nfingers;
    Uint16 padding[3];
} SDL_VirtualJoystickTouchpadDesc;
# 403 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
typedef struct SDL_VirtualJoystickSensorDesc
{
    SDL_SensorType type;
    float rate;
} SDL_VirtualJoystickSensorDesc;
# 422 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
typedef struct SDL_VirtualJoystickDesc
{
    Uint32 version;
    Uint16 type;
    Uint16 padding;
    Uint16 vendor_id;
    Uint16 product_id;
    Uint16 naxes;
    Uint16 nbuttons;
    Uint16 nballs;
    Uint16 nhats;
    Uint16 ntouchpads;
    Uint16 nsensors;
    Uint16 padding2[2];
    Uint32 button_mask;

    Uint32 axis_mask;

    const char *name;
    const SDL_VirtualJoystickTouchpadDesc *touchpads;
    const SDL_VirtualJoystickSensorDesc *sensors;

    void *userdata;
    void ( *Update)(void *userdata);
    void ( *SetPlayerIndex)(void *userdata, int player_index);
    bool ( *Rumble)(void *userdata, Uint16 low_frequency_rumble, Uint16 high_frequency_rumble);
    bool ( *RumbleTriggers)(void *userdata, Uint16 left_rumble, Uint16 right_rumble);
    bool ( *SetLED)(void *userdata, Uint8 red, Uint8 green, Uint8 blue);
    bool ( *SendEffect)(void *userdata, const void *data, int size);
    bool ( *SetSensorsEnabled)(void *userdata, bool enabled);
    void ( *Cleanup)(void *userdata);
} SDL_VirtualJoystickDesc;







static_assert((sizeof(void *) == 4 && sizeof(SDL_VirtualJoystickDesc) == 84) || (sizeof(void *) == 8 && sizeof(SDL_VirtualJoystickDesc) == 136), "(sizeof(void *) == 4 && sizeof(SDL_VirtualJoystickDesc) == 84) || (sizeof(void *) == 8 && sizeof(SDL_VirtualJoystickDesc) == 136)")

                                                                    ;
# 476 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern SDL_JoystickID SDL_AttachVirtualJoystick(const SDL_VirtualJoystickDesc *desc);
# 490 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern bool SDL_DetachVirtualJoystick(SDL_JoystickID instance_id);
# 500 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern bool SDL_IsJoystickVirtual(SDL_JoystickID instance_id);
# 523 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern bool SDL_SetJoystickVirtualAxis(SDL_Joystick *joystick, int axis, Sint16 value);
# 543 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern bool SDL_SetJoystickVirtualBall(SDL_Joystick *joystick, int ball, Sint16 xrel, Sint16 yrel);
# 562 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern bool SDL_SetJoystickVirtualButton(SDL_Joystick *joystick, int button, bool down);
# 581 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern bool SDL_SetJoystickVirtualHat(SDL_Joystick *joystick, int hat, Uint8 value);
# 607 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern bool SDL_SetJoystickVirtualTouchpad(SDL_Joystick *joystick, int touchpad, int finger, bool down, float x, float y, float pressure);
# 629 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern bool SDL_SendJoystickVirtualSensorData(SDL_Joystick *joystick, SDL_SensorType type, Uint64 sensor_timestamp, const float *data, int num_values);
# 653 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern SDL_PropertiesID SDL_GetJoystickProperties(SDL_Joystick *joystick);
# 672 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern const char * SDL_GetJoystickName(SDL_Joystick *joystick);
# 685 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern const char * SDL_GetJoystickPath(SDL_Joystick *joystick);
# 700 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern int SDL_GetJoystickPlayerIndex(SDL_Joystick *joystick);
# 715 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern bool SDL_SetJoystickPlayerIndex(SDL_Joystick *joystick, int player_index);
# 732 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern SDL_GUID SDL_GetJoystickGUID(SDL_Joystick *joystick);
# 746 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern Uint16 SDL_GetJoystickVendor(SDL_Joystick *joystick);
# 760 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern Uint16 SDL_GetJoystickProduct(SDL_Joystick *joystick);
# 774 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern Uint16 SDL_GetJoystickProductVersion(SDL_Joystick *joystick);
# 787 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern Uint16 SDL_GetJoystickFirmwareVersion(SDL_Joystick *joystick);
# 800 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern const char * SDL_GetJoystickSerial(SDL_Joystick *joystick);
# 812 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern SDL_JoystickType SDL_GetJoystickType(SDL_Joystick *joystick);
# 831 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern void SDL_GetJoystickGUIDInfo(SDL_GUID guid, Uint16 *vendor, Uint16 *product, Uint16 *version, Uint16 *crc16);
# 842 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern bool SDL_JoystickConnected(SDL_Joystick *joystick);
# 853 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern SDL_JoystickID SDL_GetJoystickID(SDL_Joystick *joystick);
# 873 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern int SDL_GetNumJoystickAxes(SDL_Joystick *joystick);
# 894 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern int SDL_GetNumJoystickBalls(SDL_Joystick *joystick);
# 910 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern int SDL_GetNumJoystickHats(SDL_Joystick *joystick);
# 926 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern int SDL_GetNumJoystickButtons(SDL_Joystick *joystick);
# 942 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern void SDL_SetJoystickEventsEnabled(bool enabled);
# 957 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern bool SDL_JoystickEventsEnabled(void);
# 967 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern void SDL_UpdateJoysticks(void);
# 991 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern Sint16 SDL_GetJoystickAxis(SDL_Joystick *joystick, int axis);
# 1007 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern bool SDL_GetJoystickAxisInitialState(SDL_Joystick *joystick, int axis, Sint16 *state);
# 1028 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern bool SDL_GetJoystickBall(SDL_Joystick *joystick, int ball, int *dx, int *dy);
# 1043 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern Uint8 SDL_GetJoystickHat(SDL_Joystick *joystick, int hat);
# 1067 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern bool SDL_GetJoystickButton(SDL_Joystick *joystick, int button);
# 1088 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern bool SDL_RumbleJoystick(SDL_Joystick *joystick, Uint16 low_frequency_rumble, Uint16 high_frequency_rumble, Uint32 duration_ms);
# 1117 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern bool SDL_RumbleJoystickTriggers(SDL_Joystick *joystick, Uint16 left_rumble, Uint16 right_rumble, Uint32 duration_ms);
# 1137 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern bool SDL_SetJoystickLED(SDL_Joystick *joystick, Uint8 red, Uint8 green, Uint8 blue);
# 1150 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern bool SDL_SendJoystickEffect(SDL_Joystick *joystick, const void *data, int size);
# 1161 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern void SDL_CloseJoystick(SDL_Joystick *joystick);
# 1173 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern SDL_JoystickConnectionState SDL_GetJoystickConnectionState(SDL_Joystick *joystick);
# 1194 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h"
extern SDL_PowerState SDL_GetJoystickPowerInfo(SDL_Joystick *joystick, int *percent);



}

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_close_code.h" 1
# 1201 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_joystick.h" 2
# 64 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h" 2




# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_begin_code.h" 1
# 69 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h" 2


extern "C" {







typedef struct SDL_Gamepad SDL_Gamepad;
# 90 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
typedef enum SDL_GamepadType
{
    SDL_GAMEPAD_TYPE_UNKNOWN = 0,
    SDL_GAMEPAD_TYPE_STANDARD,
    SDL_GAMEPAD_TYPE_XBOX360,
    SDL_GAMEPAD_TYPE_XBOXONE,
    SDL_GAMEPAD_TYPE_PS3,
    SDL_GAMEPAD_TYPE_PS4,
    SDL_GAMEPAD_TYPE_PS5,
    SDL_GAMEPAD_TYPE_NINTENDO_SWITCH_PRO,
    SDL_GAMEPAD_TYPE_NINTENDO_SWITCH_JOYCON_LEFT,
    SDL_GAMEPAD_TYPE_NINTENDO_SWITCH_JOYCON_RIGHT,
    SDL_GAMEPAD_TYPE_NINTENDO_SWITCH_JOYCON_PAIR,
    SDL_GAMEPAD_TYPE_COUNT
} SDL_GamepadType;
# 129 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
typedef enum SDL_GamepadButton
{
    SDL_GAMEPAD_BUTTON_INVALID = -1,
    SDL_GAMEPAD_BUTTON_SOUTH,
    SDL_GAMEPAD_BUTTON_EAST,
    SDL_GAMEPAD_BUTTON_WEST,
    SDL_GAMEPAD_BUTTON_NORTH,
    SDL_GAMEPAD_BUTTON_BACK,
    SDL_GAMEPAD_BUTTON_GUIDE,
    SDL_GAMEPAD_BUTTON_START,
    SDL_GAMEPAD_BUTTON_LEFT_STICK,
    SDL_GAMEPAD_BUTTON_RIGHT_STICK,
    SDL_GAMEPAD_BUTTON_LEFT_SHOULDER,
    SDL_GAMEPAD_BUTTON_RIGHT_SHOULDER,
    SDL_GAMEPAD_BUTTON_DPAD_UP,
    SDL_GAMEPAD_BUTTON_DPAD_DOWN,
    SDL_GAMEPAD_BUTTON_DPAD_LEFT,
    SDL_GAMEPAD_BUTTON_DPAD_RIGHT,
    SDL_GAMEPAD_BUTTON_MISC1,
    SDL_GAMEPAD_BUTTON_RIGHT_PADDLE1,
    SDL_GAMEPAD_BUTTON_LEFT_PADDLE1,
    SDL_GAMEPAD_BUTTON_RIGHT_PADDLE2,
    SDL_GAMEPAD_BUTTON_LEFT_PADDLE2,
    SDL_GAMEPAD_BUTTON_TOUCHPAD,
    SDL_GAMEPAD_BUTTON_MISC2,
    SDL_GAMEPAD_BUTTON_MISC3,
    SDL_GAMEPAD_BUTTON_MISC4,
    SDL_GAMEPAD_BUTTON_MISC5,
    SDL_GAMEPAD_BUTTON_MISC6,
    SDL_GAMEPAD_BUTTON_COUNT
} SDL_GamepadButton;
# 172 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
typedef enum SDL_GamepadButtonLabel
{
    SDL_GAMEPAD_BUTTON_LABEL_UNKNOWN,
    SDL_GAMEPAD_BUTTON_LABEL_A,
    SDL_GAMEPAD_BUTTON_LABEL_B,
    SDL_GAMEPAD_BUTTON_LABEL_X,
    SDL_GAMEPAD_BUTTON_LABEL_Y,
    SDL_GAMEPAD_BUTTON_LABEL_CROSS,
    SDL_GAMEPAD_BUTTON_LABEL_CIRCLE,
    SDL_GAMEPAD_BUTTON_LABEL_SQUARE,
    SDL_GAMEPAD_BUTTON_LABEL_TRIANGLE
} SDL_GamepadButtonLabel;
# 199 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
typedef enum SDL_GamepadAxis
{
    SDL_GAMEPAD_AXIS_INVALID = -1,
    SDL_GAMEPAD_AXIS_LEFTX,
    SDL_GAMEPAD_AXIS_LEFTY,
    SDL_GAMEPAD_AXIS_RIGHTX,
    SDL_GAMEPAD_AXIS_RIGHTY,
    SDL_GAMEPAD_AXIS_LEFT_TRIGGER,
    SDL_GAMEPAD_AXIS_RIGHT_TRIGGER,
    SDL_GAMEPAD_AXIS_COUNT
} SDL_GamepadAxis;
# 221 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
typedef enum SDL_GamepadBindingType
{
    SDL_GAMEPAD_BINDTYPE_NONE = 0,
    SDL_GAMEPAD_BINDTYPE_BUTTON,
    SDL_GAMEPAD_BINDTYPE_AXIS,
    SDL_GAMEPAD_BINDTYPE_HAT
} SDL_GamepadBindingType;
# 244 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
typedef struct SDL_GamepadBinding
{
    SDL_GamepadBindingType input_type;
    union
    {
        int button;

        struct
        {
            int axis;
            int axis_min;
            int axis_max;
        } axis;

        struct
        {
            int hat;
            int hat_mask;
        } hat;

    } input;

    SDL_GamepadBindingType output_type;
    union
    {
        SDL_GamepadButton button;

        struct
        {
            SDL_GamepadAxis axis;
            int axis_min;
            int axis_max;
        } axis;

    } output;
} SDL_GamepadBinding;
# 315 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern int SDL_AddGamepadMapping(const char *mapping);
# 349 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern int SDL_AddGamepadMappingsFromIO(SDL_IOStream *src, bool closeio);
# 377 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern int SDL_AddGamepadMappingsFromFile(const char *file);
# 389 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern bool SDL_ReloadGamepadMappings(void);
# 403 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern char ** SDL_GetGamepadMappings(int *count);
# 418 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern char * SDL_GetGamepadMappingForGUID(SDL_GUID guid);
# 437 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern char * SDL_GetGamepadMapping(SDL_Gamepad *gamepad);
# 455 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern bool SDL_SetGamepadMapping(SDL_JoystickID instance_id, const char *mapping);
# 466 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern bool SDL_HasGamepad(void);
# 482 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern SDL_JoystickID * SDL_GetGamepads(int *count);
# 496 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern bool SDL_IsGamepad(SDL_JoystickID instance_id);
# 512 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern const char * SDL_GetGamepadNameForID(SDL_JoystickID instance_id);
# 528 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern const char * SDL_GetGamepadPathForID(SDL_JoystickID instance_id);
# 543 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern int SDL_GetGamepadPlayerIndexForID(SDL_JoystickID instance_id);
# 559 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern SDL_GUID SDL_GetGamepadGUIDForID(SDL_JoystickID instance_id);
# 576 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern Uint16 SDL_GetGamepadVendorForID(SDL_JoystickID instance_id);
# 593 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern Uint16 SDL_GetGamepadProductForID(SDL_JoystickID instance_id);
# 610 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern Uint16 SDL_GetGamepadProductVersionForID(SDL_JoystickID instance_id);
# 626 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern SDL_GamepadType SDL_GetGamepadTypeForID(SDL_JoystickID instance_id);
# 642 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern SDL_GamepadType SDL_GetRealGamepadTypeForID(SDL_JoystickID instance_id);
# 658 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern char * SDL_GetGamepadMappingForID(SDL_JoystickID instance_id);
# 672 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern SDL_Gamepad * SDL_OpenGamepad(SDL_JoystickID instance_id);
# 684 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern SDL_Gamepad * SDL_GetGamepadFromID(SDL_JoystickID instance_id);
# 697 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern SDL_Gamepad * SDL_GetGamepadFromPlayerIndex(int player_index);
# 724 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern SDL_PropertiesID SDL_GetGamepadProperties(SDL_Gamepad *gamepad);
# 742 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern SDL_JoystickID SDL_GetGamepadID(SDL_Gamepad *gamepad);
# 756 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern const char * SDL_GetGamepadName(SDL_Gamepad *gamepad);
# 770 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern const char * SDL_GetGamepadPath(SDL_Gamepad *gamepad);
# 783 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern SDL_GamepadType SDL_GetGamepadType(SDL_Gamepad *gamepad);
# 796 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern SDL_GamepadType SDL_GetRealGamepadType(SDL_Gamepad *gamepad);
# 810 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern int SDL_GetGamepadPlayerIndex(SDL_Gamepad *gamepad);
# 825 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern bool SDL_SetGamepadPlayerIndex(SDL_Gamepad *gamepad, int player_index);
# 839 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern Uint16 SDL_GetGamepadVendor(SDL_Gamepad *gamepad);
# 853 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern Uint16 SDL_GetGamepadProduct(SDL_Gamepad *gamepad);
# 867 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern Uint16 SDL_GetGamepadProductVersion(SDL_Gamepad *gamepad);
# 879 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern Uint16 SDL_GetGamepadFirmwareVersion(SDL_Gamepad *gamepad);
# 891 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern const char * SDL_GetGamepadSerial(SDL_Gamepad *gamepad);
# 904 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern Uint64 SDL_GetGamepadSteamHandle(SDL_Gamepad *gamepad);
# 916 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern SDL_JoystickConnectionState SDL_GetGamepadConnectionState(SDL_Gamepad *gamepad);
# 936 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern SDL_PowerState SDL_GetGamepadPowerInfo(SDL_Gamepad *gamepad, int *percent);
# 948 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern bool SDL_GamepadConnected(SDL_Gamepad *gamepad);
# 968 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern SDL_Joystick * SDL_GetGamepadJoystick(SDL_Gamepad *gamepad);
# 983 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern void SDL_SetGamepadEventsEnabled(bool enabled);
# 997 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern bool SDL_GamepadEventsEnabled(void);
# 1011 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern SDL_GamepadBinding ** SDL_GetGamepadBindings(SDL_Gamepad *gamepad, int *count);
# 1022 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern void SDL_UpdateGamepads(void);
# 1040 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern SDL_GamepadType SDL_GetGamepadTypeFromString(const char *str);
# 1054 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern const char * SDL_GetGamepadStringForType(SDL_GamepadType type);
# 1076 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern SDL_GamepadAxis SDL_GetGamepadAxisFromString(const char *str);
# 1090 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern const char * SDL_GetGamepadStringForAxis(SDL_GamepadAxis axis);
# 1107 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern bool SDL_GamepadHasAxis(SDL_Gamepad *gamepad, SDL_GamepadAxis axis);
# 1131 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern Sint16 SDL_GetGamepadAxis(SDL_Gamepad *gamepad, SDL_GamepadAxis axis);
# 1149 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern SDL_GamepadButton SDL_GetGamepadButtonFromString(const char *str);
# 1163 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern const char * SDL_GetGamepadStringForButton(SDL_GamepadButton button);
# 1179 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern bool SDL_GamepadHasButton(SDL_Gamepad *gamepad, SDL_GamepadButton button);
# 1193 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern bool SDL_GetGamepadButton(SDL_Gamepad *gamepad, SDL_GamepadButton button);
# 1206 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern SDL_GamepadButtonLabel SDL_GetGamepadButtonLabelForType(SDL_GamepadType type, SDL_GamepadButton button);
# 1219 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern SDL_GamepadButtonLabel SDL_GetGamepadButtonLabel(SDL_Gamepad *gamepad, SDL_GamepadButton button);
# 1231 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern int SDL_GetNumGamepadTouchpads(SDL_Gamepad *gamepad);
# 1246 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern int SDL_GetNumGamepadTouchpadFingers(SDL_Gamepad *gamepad, int touchpad);
# 1268 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern bool SDL_GetGamepadTouchpadFinger(SDL_Gamepad *gamepad, int touchpad, int finger, bool *down, float *x, float *y, float *pressure);
# 1283 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern bool SDL_GamepadHasSensor(SDL_Gamepad *gamepad, SDL_SensorType type);
# 1299 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern bool SDL_SetGamepadSensorEnabled(SDL_Gamepad *gamepad, SDL_SensorType type, bool enabled);
# 1312 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern bool SDL_GamepadSensorEnabled(SDL_Gamepad *gamepad, SDL_SensorType type);
# 1323 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern float SDL_GetGamepadSensorDataRate(SDL_Gamepad *gamepad, SDL_SensorType type);
# 1340 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern bool SDL_GetGamepadSensorData(SDL_Gamepad *gamepad, SDL_SensorType type, float *data, int num_values);
# 1362 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern bool SDL_RumbleGamepad(SDL_Gamepad *gamepad, Uint16 low_frequency_rumble, Uint16 high_frequency_rumble, Uint32 duration_ms);
# 1390 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern bool SDL_RumbleGamepadTriggers(SDL_Gamepad *gamepad, Uint16 left_rumble, Uint16 right_rumble, Uint32 duration_ms);
# 1410 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern bool SDL_SetGamepadLED(SDL_Gamepad *gamepad, Uint8 red, Uint8 green, Uint8 blue);
# 1423 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern bool SDL_SendGamepadEffect(SDL_Gamepad *gamepad, const void *data, int size);
# 1435 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern void SDL_CloseGamepad(SDL_Gamepad *gamepad);
# 1449 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern const char * SDL_GetGamepadAppleSFSymbolsNameForButton(SDL_Gamepad *gamepad, SDL_GamepadButton button);
# 1462 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h"
extern const char * SDL_GetGamepadAppleSFSymbolsNameForAxis(SDL_Gamepad *gamepad, SDL_GamepadAxis axis);




}

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_close_code.h" 1
# 1470 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gamepad.h" 2
# 36 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_events.h" 2

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_keyboard.h" 1
# 33 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_keyboard.h"
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_keycode.h" 1
# 32 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_keycode.h"
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_scancode.h" 1
# 47 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_scancode.h"
typedef enum SDL_Scancode
{
    SDL_SCANCODE_UNKNOWN = 0,
# 58 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_scancode.h"
    SDL_SCANCODE_A = 4,
    SDL_SCANCODE_B = 5,
    SDL_SCANCODE_C = 6,
    SDL_SCANCODE_D = 7,
    SDL_SCANCODE_E = 8,
    SDL_SCANCODE_F = 9,
    SDL_SCANCODE_G = 10,
    SDL_SCANCODE_H = 11,
    SDL_SCANCODE_I = 12,
    SDL_SCANCODE_J = 13,
    SDL_SCANCODE_K = 14,
    SDL_SCANCODE_L = 15,
    SDL_SCANCODE_M = 16,
    SDL_SCANCODE_N = 17,
    SDL_SCANCODE_O = 18,
    SDL_SCANCODE_P = 19,
    SDL_SCANCODE_Q = 20,
    SDL_SCANCODE_R = 21,
    SDL_SCANCODE_S = 22,
    SDL_SCANCODE_T = 23,
    SDL_SCANCODE_U = 24,
    SDL_SCANCODE_V = 25,
    SDL_SCANCODE_W = 26,
    SDL_SCANCODE_X = 27,
    SDL_SCANCODE_Y = 28,
    SDL_SCANCODE_Z = 29,

    SDL_SCANCODE_1 = 30,
    SDL_SCANCODE_2 = 31,
    SDL_SCANCODE_3 = 32,
    SDL_SCANCODE_4 = 33,
    SDL_SCANCODE_5 = 34,
    SDL_SCANCODE_6 = 35,
    SDL_SCANCODE_7 = 36,
    SDL_SCANCODE_8 = 37,
    SDL_SCANCODE_9 = 38,
    SDL_SCANCODE_0 = 39,

    SDL_SCANCODE_RETURN = 40,
    SDL_SCANCODE_ESCAPE = 41,
    SDL_SCANCODE_BACKSPACE = 42,
    SDL_SCANCODE_TAB = 43,
    SDL_SCANCODE_SPACE = 44,

    SDL_SCANCODE_MINUS = 45,
    SDL_SCANCODE_EQUALS = 46,
    SDL_SCANCODE_LEFTBRACKET = 47,
    SDL_SCANCODE_RIGHTBRACKET = 48,
    SDL_SCANCODE_BACKSLASH = 49,
# 120 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_scancode.h"
    SDL_SCANCODE_NONUSHASH = 50,
# 132 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_scancode.h"
    SDL_SCANCODE_SEMICOLON = 51,
    SDL_SCANCODE_APOSTROPHE = 52,
    SDL_SCANCODE_GRAVE = 53,
# 151 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_scancode.h"
    SDL_SCANCODE_COMMA = 54,
    SDL_SCANCODE_PERIOD = 55,
    SDL_SCANCODE_SLASH = 56,

    SDL_SCANCODE_CAPSLOCK = 57,

    SDL_SCANCODE_F1 = 58,
    SDL_SCANCODE_F2 = 59,
    SDL_SCANCODE_F3 = 60,
    SDL_SCANCODE_F4 = 61,
    SDL_SCANCODE_F5 = 62,
    SDL_SCANCODE_F6 = 63,
    SDL_SCANCODE_F7 = 64,
    SDL_SCANCODE_F8 = 65,
    SDL_SCANCODE_F9 = 66,
    SDL_SCANCODE_F10 = 67,
    SDL_SCANCODE_F11 = 68,
    SDL_SCANCODE_F12 = 69,

    SDL_SCANCODE_PRINTSCREEN = 70,
    SDL_SCANCODE_SCROLLLOCK = 71,
    SDL_SCANCODE_PAUSE = 72,
    SDL_SCANCODE_INSERT = 73,

    SDL_SCANCODE_HOME = 74,
    SDL_SCANCODE_PAGEUP = 75,
    SDL_SCANCODE_DELETE = 76,
    SDL_SCANCODE_END = 77,
    SDL_SCANCODE_PAGEDOWN = 78,
    SDL_SCANCODE_RIGHT = 79,
    SDL_SCANCODE_LEFT = 80,
    SDL_SCANCODE_DOWN = 81,
    SDL_SCANCODE_UP = 82,

    SDL_SCANCODE_NUMLOCKCLEAR = 83,

    SDL_SCANCODE_KP_DIVIDE = 84,
    SDL_SCANCODE_KP_MULTIPLY = 85,
    SDL_SCANCODE_KP_MINUS = 86,
    SDL_SCANCODE_KP_PLUS = 87,
    SDL_SCANCODE_KP_ENTER = 88,
    SDL_SCANCODE_KP_1 = 89,
    SDL_SCANCODE_KP_2 = 90,
    SDL_SCANCODE_KP_3 = 91,
    SDL_SCANCODE_KP_4 = 92,
    SDL_SCANCODE_KP_5 = 93,
    SDL_SCANCODE_KP_6 = 94,
    SDL_SCANCODE_KP_7 = 95,
    SDL_SCANCODE_KP_8 = 96,
    SDL_SCANCODE_KP_9 = 97,
    SDL_SCANCODE_KP_0 = 98,
    SDL_SCANCODE_KP_PERIOD = 99,

    SDL_SCANCODE_NONUSBACKSLASH = 100,
# 214 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_scancode.h"
    SDL_SCANCODE_APPLICATION = 101,
    SDL_SCANCODE_POWER = 102,


    SDL_SCANCODE_KP_EQUALS = 103,
    SDL_SCANCODE_F13 = 104,
    SDL_SCANCODE_F14 = 105,
    SDL_SCANCODE_F15 = 106,
    SDL_SCANCODE_F16 = 107,
    SDL_SCANCODE_F17 = 108,
    SDL_SCANCODE_F18 = 109,
    SDL_SCANCODE_F19 = 110,
    SDL_SCANCODE_F20 = 111,
    SDL_SCANCODE_F21 = 112,
    SDL_SCANCODE_F22 = 113,
    SDL_SCANCODE_F23 = 114,
    SDL_SCANCODE_F24 = 115,
    SDL_SCANCODE_EXECUTE = 116,
    SDL_SCANCODE_HELP = 117,
    SDL_SCANCODE_MENU = 118,
    SDL_SCANCODE_SELECT = 119,
    SDL_SCANCODE_STOP = 120,
    SDL_SCANCODE_AGAIN = 121,
    SDL_SCANCODE_UNDO = 122,
    SDL_SCANCODE_CUT = 123,
    SDL_SCANCODE_COPY = 124,
    SDL_SCANCODE_PASTE = 125,
    SDL_SCANCODE_FIND = 126,
    SDL_SCANCODE_MUTE = 127,
    SDL_SCANCODE_VOLUMEUP = 128,
    SDL_SCANCODE_VOLUMEDOWN = 129,




    SDL_SCANCODE_KP_COMMA = 133,
    SDL_SCANCODE_KP_EQUALSAS400 = 134,

    SDL_SCANCODE_INTERNATIONAL1 = 135,

    SDL_SCANCODE_INTERNATIONAL2 = 136,
    SDL_SCANCODE_INTERNATIONAL3 = 137,
    SDL_SCANCODE_INTERNATIONAL4 = 138,
    SDL_SCANCODE_INTERNATIONAL5 = 139,
    SDL_SCANCODE_INTERNATIONAL6 = 140,
    SDL_SCANCODE_INTERNATIONAL7 = 141,
    SDL_SCANCODE_INTERNATIONAL8 = 142,
    SDL_SCANCODE_INTERNATIONAL9 = 143,
    SDL_SCANCODE_LANG1 = 144,
    SDL_SCANCODE_LANG2 = 145,
    SDL_SCANCODE_LANG3 = 146,
    SDL_SCANCODE_LANG4 = 147,
    SDL_SCANCODE_LANG5 = 148,
    SDL_SCANCODE_LANG6 = 149,
    SDL_SCANCODE_LANG7 = 150,
    SDL_SCANCODE_LANG8 = 151,
    SDL_SCANCODE_LANG9 = 152,

    SDL_SCANCODE_ALTERASE = 153,
    SDL_SCANCODE_SYSREQ = 154,
    SDL_SCANCODE_CANCEL = 155,
    SDL_SCANCODE_CLEAR = 156,
    SDL_SCANCODE_PRIOR = 157,
    SDL_SCANCODE_RETURN2 = 158,
    SDL_SCANCODE_SEPARATOR = 159,
    SDL_SCANCODE_OUT = 160,
    SDL_SCANCODE_OPER = 161,
    SDL_SCANCODE_CLEARAGAIN = 162,
    SDL_SCANCODE_CRSEL = 163,
    SDL_SCANCODE_EXSEL = 164,

    SDL_SCANCODE_KP_00 = 176,
    SDL_SCANCODE_KP_000 = 177,
    SDL_SCANCODE_THOUSANDSSEPARATOR = 178,
    SDL_SCANCODE_DECIMALSEPARATOR = 179,
    SDL_SCANCODE_CURRENCYUNIT = 180,
    SDL_SCANCODE_CURRENCYSUBUNIT = 181,
    SDL_SCANCODE_KP_LEFTPAREN = 182,
    SDL_SCANCODE_KP_RIGHTPAREN = 183,
    SDL_SCANCODE_KP_LEFTBRACE = 184,
    SDL_SCANCODE_KP_RIGHTBRACE = 185,
    SDL_SCANCODE_KP_TAB = 186,
    SDL_SCANCODE_KP_BACKSPACE = 187,
    SDL_SCANCODE_KP_A = 188,
    SDL_SCANCODE_KP_B = 189,
    SDL_SCANCODE_KP_C = 190,
    SDL_SCANCODE_KP_D = 191,
    SDL_SCANCODE_KP_E = 192,
    SDL_SCANCODE_KP_F = 193,
    SDL_SCANCODE_KP_XOR = 194,
    SDL_SCANCODE_KP_POWER = 195,
    SDL_SCANCODE_KP_PERCENT = 196,
    SDL_SCANCODE_KP_LESS = 197,
    SDL_SCANCODE_KP_GREATER = 198,
    SDL_SCANCODE_KP_AMPERSAND = 199,
    SDL_SCANCODE_KP_DBLAMPERSAND = 200,
    SDL_SCANCODE_KP_VERTICALBAR = 201,
    SDL_SCANCODE_KP_DBLVERTICALBAR = 202,
    SDL_SCANCODE_KP_COLON = 203,
    SDL_SCANCODE_KP_HASH = 204,
    SDL_SCANCODE_KP_SPACE = 205,
    SDL_SCANCODE_KP_AT = 206,
    SDL_SCANCODE_KP_EXCLAM = 207,
    SDL_SCANCODE_KP_MEMSTORE = 208,
    SDL_SCANCODE_KP_MEMRECALL = 209,
    SDL_SCANCODE_KP_MEMCLEAR = 210,
    SDL_SCANCODE_KP_MEMADD = 211,
    SDL_SCANCODE_KP_MEMSUBTRACT = 212,
    SDL_SCANCODE_KP_MEMMULTIPLY = 213,
    SDL_SCANCODE_KP_MEMDIVIDE = 214,
    SDL_SCANCODE_KP_PLUSMINUS = 215,
    SDL_SCANCODE_KP_CLEAR = 216,
    SDL_SCANCODE_KP_CLEARENTRY = 217,
    SDL_SCANCODE_KP_BINARY = 218,
    SDL_SCANCODE_KP_OCTAL = 219,
    SDL_SCANCODE_KP_DECIMAL = 220,
    SDL_SCANCODE_KP_HEXADECIMAL = 221,

    SDL_SCANCODE_LCTRL = 224,
    SDL_SCANCODE_LSHIFT = 225,
    SDL_SCANCODE_LALT = 226,
    SDL_SCANCODE_LGUI = 227,
    SDL_SCANCODE_RCTRL = 228,
    SDL_SCANCODE_RSHIFT = 229,
    SDL_SCANCODE_RALT = 230,
    SDL_SCANCODE_RGUI = 231,

    SDL_SCANCODE_MODE = 257,
# 359 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_scancode.h"
    SDL_SCANCODE_SLEEP = 258,
    SDL_SCANCODE_WAKE = 259,

    SDL_SCANCODE_CHANNEL_INCREMENT = 260,
    SDL_SCANCODE_CHANNEL_DECREMENT = 261,

    SDL_SCANCODE_MEDIA_PLAY = 262,
    SDL_SCANCODE_MEDIA_PAUSE = 263,
    SDL_SCANCODE_MEDIA_RECORD = 264,
    SDL_SCANCODE_MEDIA_FAST_FORWARD = 265,
    SDL_SCANCODE_MEDIA_REWIND = 266,
    SDL_SCANCODE_MEDIA_NEXT_TRACK = 267,
    SDL_SCANCODE_MEDIA_PREVIOUS_TRACK = 268,
    SDL_SCANCODE_MEDIA_STOP = 269,
    SDL_SCANCODE_MEDIA_EJECT = 270,
    SDL_SCANCODE_MEDIA_PLAY_PAUSE = 271,
    SDL_SCANCODE_MEDIA_SELECT = 272,

    SDL_SCANCODE_AC_NEW = 273,
    SDL_SCANCODE_AC_OPEN = 274,
    SDL_SCANCODE_AC_CLOSE = 275,
    SDL_SCANCODE_AC_EXIT = 276,
    SDL_SCANCODE_AC_SAVE = 277,
    SDL_SCANCODE_AC_PRINT = 278,
    SDL_SCANCODE_AC_PROPERTIES = 279,

    SDL_SCANCODE_AC_SEARCH = 280,
    SDL_SCANCODE_AC_HOME = 281,
    SDL_SCANCODE_AC_BACK = 282,
    SDL_SCANCODE_AC_FORWARD = 283,
    SDL_SCANCODE_AC_STOP = 284,
    SDL_SCANCODE_AC_REFRESH = 285,
    SDL_SCANCODE_AC_BOOKMARKS = 286,
# 403 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_scancode.h"
    SDL_SCANCODE_SOFTLEFT = 287,



    SDL_SCANCODE_SOFTRIGHT = 288,



    SDL_SCANCODE_CALL = 289,
    SDL_SCANCODE_ENDCALL = 290,





    SDL_SCANCODE_RESERVED = 400,

    SDL_SCANCODE_COUNT = 512

} SDL_Scancode;
# 33 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_keycode.h" 2
# 47 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_keycode.h"
typedef Uint32 SDL_Keycode;
# 306 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_keycode.h"
typedef Uint16 SDL_Keymod;
# 34 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_keyboard.h" 2



# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h" 1
# 59 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_begin_code.h" 1
# 60 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h" 2


extern "C" {
# 75 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
typedef Uint32 SDL_DisplayID;
# 84 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
typedef Uint32 SDL_WindowID;
# 108 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
typedef enum SDL_SystemTheme
{
    SDL_SYSTEM_THEME_UNKNOWN,
    SDL_SYSTEM_THEME_LIGHT,
    SDL_SYSTEM_THEME_DARK
} SDL_SystemTheme;


typedef struct SDL_DisplayModeData SDL_DisplayModeData;
# 129 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
typedef struct SDL_DisplayMode
{
    SDL_DisplayID displayID;
    SDL_PixelFormat format;
    int w;
    int h;
    float pixel_density;
    float refresh_rate;
    int refresh_rate_numerator;
    int refresh_rate_denominator;

    SDL_DisplayModeData *internal;

} SDL_DisplayMode;






typedef enum SDL_DisplayOrientation
{
    SDL_ORIENTATION_UNKNOWN,
    SDL_ORIENTATION_LANDSCAPE,
    SDL_ORIENTATION_LANDSCAPE_FLIPPED,
    SDL_ORIENTATION_PORTRAIT,
    SDL_ORIENTATION_PORTRAIT_FLIPPED
} SDL_DisplayOrientation;
# 165 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
typedef struct SDL_Window SDL_Window;
# 179 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
typedef Uint64 SDL_WindowFlags;
# 235 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
typedef enum SDL_FlashOperation
{
    SDL_FLASH_CANCEL,
    SDL_FLASH_BRIEFLY,
    SDL_FLASH_UNTIL_FOCUSED
} SDL_FlashOperation;
# 249 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
typedef struct SDL_GLContextState *SDL_GLContext;






typedef void *SDL_EGLDisplay;
typedef void *SDL_EGLConfig;
typedef void *SDL_EGLSurface;
typedef intptr_t SDL_EGLAttrib;
typedef int SDL_EGLint;
# 285 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
typedef SDL_EGLAttrib *( *SDL_EGLAttribArrayCallback)(void *userdata);
# 316 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
typedef SDL_EGLint *( *SDL_EGLIntArrayCallback)(void *userdata, SDL_EGLDisplay display, SDL_EGLConfig config);
# 335 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
typedef enum SDL_GLattr
{
    SDL_GL_RED_SIZE,
    SDL_GL_GREEN_SIZE,
    SDL_GL_BLUE_SIZE,
    SDL_GL_ALPHA_SIZE,
    SDL_GL_BUFFER_SIZE,
    SDL_GL_DOUBLEBUFFER,
    SDL_GL_DEPTH_SIZE,
    SDL_GL_STENCIL_SIZE,
    SDL_GL_ACCUM_RED_SIZE,
    SDL_GL_ACCUM_GREEN_SIZE,
    SDL_GL_ACCUM_BLUE_SIZE,
    SDL_GL_ACCUM_ALPHA_SIZE,
    SDL_GL_STEREO,
    SDL_GL_MULTISAMPLEBUFFERS,
    SDL_GL_MULTISAMPLESAMPLES,
    SDL_GL_ACCELERATED_VISUAL,
    SDL_GL_RETAINED_BACKING,
    SDL_GL_CONTEXT_MAJOR_VERSION,
    SDL_GL_CONTEXT_MINOR_VERSION,
    SDL_GL_CONTEXT_FLAGS,
    SDL_GL_CONTEXT_PROFILE_MASK,
    SDL_GL_SHARE_WITH_CURRENT_CONTEXT,
    SDL_GL_FRAMEBUFFER_SRGB_CAPABLE,
    SDL_GL_CONTEXT_RELEASE_BEHAVIOR,
    SDL_GL_CONTEXT_RESET_NOTIFICATION,
    SDL_GL_CONTEXT_NO_ERROR,
    SDL_GL_FLOATBUFFERS,
    SDL_GL_EGL_PLATFORM
} SDL_GLattr;






typedef enum SDL_GLprofile
{
    SDL_GL_CONTEXT_PROFILE_CORE = 0x0001,
    SDL_GL_CONTEXT_PROFILE_COMPATIBILITY = 0x0002,
    SDL_GL_CONTEXT_PROFILE_ES = 0x0004
} SDL_GLprofile;






typedef enum SDL_GLcontextFlag
{
    SDL_GL_CONTEXT_DEBUG_FLAG = 0x0001,
    SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG = 0x0002,
    SDL_GL_CONTEXT_ROBUST_ACCESS_FLAG = 0x0004,
    SDL_GL_CONTEXT_RESET_ISOLATION_FLAG = 0x0008
} SDL_GLcontextFlag;







typedef enum SDL_GLcontextReleaseFlag
{
    SDL_GL_CONTEXT_RELEASE_BEHAVIOR_NONE = 0x0000,
    SDL_GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH = 0x0001
} SDL_GLcontextReleaseFlag;






typedef enum SDL_GLContextResetNotification
{
    SDL_GL_CONTEXT_RESET_NO_NOTIFICATION = 0x0000,
    SDL_GL_CONTEXT_RESET_LOSE_CONTEXT = 0x0001
} SDL_GLContextResetNotification;
# 426 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern int SDL_GetNumVideoDrivers(void);
# 445 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern const char * SDL_GetVideoDriver(int index);
# 462 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern const char * SDL_GetCurrentVideoDriver(void);
# 471 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern SDL_SystemTheme SDL_GetSystemTheme(void);
# 484 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern SDL_DisplayID * SDL_GetDisplays(int *count);
# 496 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern SDL_DisplayID SDL_GetPrimaryDisplay(void);
# 522 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern SDL_PropertiesID SDL_GetDisplayProperties(SDL_DisplayID displayID);
# 538 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern const char * SDL_GetDisplayName(SDL_DisplayID displayID);
# 555 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_GetDisplayBounds(SDL_DisplayID displayID, SDL_Rect *rect);
# 579 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_GetDisplayUsableBounds(SDL_DisplayID displayID, SDL_Rect *rect);
# 592 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern SDL_DisplayOrientation SDL_GetNaturalDisplayOrientation(SDL_DisplayID displayID);
# 605 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern SDL_DisplayOrientation SDL_GetCurrentDisplayOrientation(SDL_DisplayID displayID);
# 623 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern float SDL_GetDisplayContentScale(SDL_DisplayID displayID);
# 649 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern SDL_DisplayMode ** SDL_GetFullscreenDisplayModes(SDL_DisplayID displayID, int *count);
# 678 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_GetClosestFullscreenDisplayMode(SDL_DisplayID displayID, int w, int h, float refresh_rate, bool include_high_density_modes, SDL_DisplayMode *mode);
# 697 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern const SDL_DisplayMode * SDL_GetDesktopDisplayMode(SDL_DisplayID displayID);
# 716 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern const SDL_DisplayMode * SDL_GetCurrentDisplayMode(SDL_DisplayID displayID);
# 730 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern SDL_DisplayID SDL_GetDisplayForPoint(const SDL_Point *point);
# 745 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern SDL_DisplayID SDL_GetDisplayForRect(const SDL_Rect *rect);
# 760 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern SDL_DisplayID SDL_GetDisplayForWindow(SDL_Window *window);
# 777 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern float SDL_GetWindowPixelDensity(SDL_Window *window);
# 799 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern float SDL_GetWindowDisplayScale(SDL_Window *window);
# 832 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_SetWindowFullscreenMode(SDL_Window *window, const SDL_DisplayMode *mode);
# 846 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern const SDL_DisplayMode * SDL_GetWindowFullscreenMode(SDL_Window *window);
# 859 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern void * SDL_GetWindowICCProfile(SDL_Window *window, size_t *size);
# 871 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern SDL_PixelFormat SDL_GetWindowPixelFormat(SDL_Window *window);
# 885 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern SDL_Window ** SDL_GetWindows(int *count);
# 969 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern SDL_Window * SDL_CreateWindow(const char *title, int w, int h, SDL_WindowFlags flags);
# 1029 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern SDL_Window * SDL_CreatePopupWindow(SDL_Window *parent, int offset_x, int offset_y, int w, int h, SDL_WindowFlags flags);
# 1146 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern SDL_Window * SDL_CreateWindowWithProperties(SDL_PropertiesID props);
# 1197 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern SDL_WindowID SDL_GetWindowID(SDL_Window *window);
# 1213 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern SDL_Window * SDL_GetWindowFromID(SDL_WindowID id);
# 1226 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern SDL_Window * SDL_GetWindowParent(SDL_Window *window);
# 1339 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern SDL_PropertiesID SDL_GetWindowProperties(SDL_Window *window);
# 1391 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern SDL_WindowFlags SDL_GetWindowFlags(SDL_Window *window);
# 1407 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_SetWindowTitle(SDL_Window *window, const char *title);
# 1420 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern const char * SDL_GetWindowTitle(SDL_Window *window);
# 1442 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_SetWindowIcon(SDL_Window *window, SDL_Surface *icon);
# 1482 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_SetWindowPosition(SDL_Window *window, int x, int y);
# 1505 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_GetWindowPosition(SDL_Window *window, int *x, int *y);
# 1541 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_SetWindowSize(SDL_Window *window, int w, int h);
# 1562 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_GetWindowSize(SDL_Window *window, int *w, int *h);
# 1582 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_GetWindowSafeArea(SDL_Window *window, SDL_Rect *rect);
# 1621 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_SetWindowAspectRatio(SDL_Window *window, float min_aspect, float max_aspect);
# 1638 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_GetWindowAspectRatio(SDL_Window *window, float *min_aspect, float *max_aspect);
# 1673 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_GetWindowBordersSize(SDL_Window *window, int *top, int *left, int *bottom, int *right);
# 1691 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_GetWindowSizeInPixels(SDL_Window *window, int *w, int *h);
# 1707 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_SetWindowMinimumSize(SDL_Window *window, int min_w, int min_h);
# 1725 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_GetWindowMinimumSize(SDL_Window *window, int *w, int *h);
# 1741 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_SetWindowMaximumSize(SDL_Window *window, int max_w, int max_h);
# 1759 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_GetWindowMaximumSize(SDL_Window *window, int *w, int *h);
# 1779 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_SetWindowBordered(SDL_Window *window, bool bordered);
# 1799 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_SetWindowResizable(SDL_Window *window, bool resizable);
# 1816 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_SetWindowAlwaysOnTop(SDL_Window *window, bool on_top);
# 1830 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_ShowWindow(SDL_Window *window);
# 1843 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_HideWindow(SDL_Window *window);
# 1861 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_RaiseWindow(SDL_Window *window);
# 1893 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_MaximizeWindow(SDL_Window *window);
# 1917 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_MinimizeWindow(SDL_Window *window);
# 1942 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_RestoreWindow(SDL_Window *window);
# 1971 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_SetWindowFullscreen(SDL_Window *window, bool fullscreen);
# 2000 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_SyncWindow(SDL_Window *window);
# 2013 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_WindowHasSurface(SDL_Window *window);
# 2040 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern SDL_Surface * SDL_GetWindowSurface(SDL_Window *window);
# 2064 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_SetWindowSurfaceVSync(SDL_Window *window, int vsync);
# 2082 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_GetWindowSurfaceVSync(SDL_Window *window, int *vsync);
# 2101 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_UpdateWindowSurface(SDL_Window *window);
# 2128 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_UpdateWindowSurfaceRects(SDL_Window *window, const SDL_Rect *rects, int numrects);
# 2142 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_DestroyWindowSurface(SDL_Window *window);
# 2173 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_SetWindowKeyboardGrab(SDL_Window *window, bool grabbed);
# 2190 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_SetWindowMouseGrab(SDL_Window *window, bool grabbed);
# 2202 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_GetWindowKeyboardGrab(SDL_Window *window);
# 2214 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_GetWindowMouseGrab(SDL_Window *window);
# 2226 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern SDL_Window * SDL_GetGrabbedWindow(void);
# 2245 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_SetWindowMouseRect(SDL_Window *window, const SDL_Rect *rect);
# 2258 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern const SDL_Rect * SDL_GetWindowMouseRect(SDL_Window *window);
# 2277 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_SetWindowOpacity(SDL_Window *window, float opacity);
# 2293 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern float SDL_GetWindowOpacity(SDL_Window *window);
# 2325 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_SetWindowParent(SDL_Window *window, SDL_Window *parent);
# 2342 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_SetWindowModal(SDL_Window *window, bool modal);
# 2354 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_SetWindowFocusable(SDL_Window *window, bool focusable);
# 2378 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_ShowWindowSystemMenu(SDL_Window *window, int x, int y);
# 2387 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
typedef enum SDL_HitTestResult
{
    SDL_HITTEST_NORMAL,
    SDL_HITTEST_DRAGGABLE,
    SDL_HITTEST_RESIZE_TOPLEFT,
    SDL_HITTEST_RESIZE_TOP,
    SDL_HITTEST_RESIZE_TOPRIGHT,
    SDL_HITTEST_RESIZE_RIGHT,
    SDL_HITTEST_RESIZE_BOTTOMRIGHT,
    SDL_HITTEST_RESIZE_BOTTOM,
    SDL_HITTEST_RESIZE_BOTTOMLEFT,
    SDL_HITTEST_RESIZE_LEFT
} SDL_HitTestResult;
# 2411 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
typedef SDL_HitTestResult ( *SDL_HitTest)(SDL_Window *win,
                                                 const SDL_Point *area,
                                                 void *data);
# 2455 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_SetWindowHitTest(SDL_Window *window, SDL_HitTest callback, void *callback_data);
# 2481 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_SetWindowShape(SDL_Window *window, SDL_Surface *shape);
# 2493 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_FlashWindow(SDL_Window *window, SDL_FlashOperation operation);
# 2509 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern void SDL_DestroyWindow(SDL_Window *window);
# 2526 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_ScreenSaverEnabled(void);
# 2539 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_EnableScreenSaver(void);
# 2558 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_DisableScreenSaver(void);
# 2586 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_GL_LoadLibrary(const char *path);
# 2639 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern SDL_FunctionPointer SDL_GL_GetProcAddress(const char *proc);
# 2656 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern SDL_FunctionPointer SDL_EGL_GetProcAddress(const char *proc);
# 2665 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern void SDL_GL_UnloadLibrary(void);
# 2686 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_GL_ExtensionSupported(const char *extension);
# 2696 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern void SDL_GL_ResetAttributes(void);
# 2717 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_GL_SetAttribute(SDL_GLattr attr, int value);
# 2733 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_GL_GetAttribute(SDL_GLattr attr, int *value);
# 2755 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern SDL_GLContext SDL_GL_CreateContext(SDL_Window *window);
# 2771 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_GL_MakeCurrent(SDL_Window *window, SDL_GLContext context);
# 2781 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern SDL_Window * SDL_GL_GetCurrentWindow(void);
# 2793 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern SDL_GLContext SDL_GL_GetCurrentContext(void);
# 2803 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern SDL_EGLDisplay SDL_EGL_GetCurrentDisplay(void);
# 2813 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern SDL_EGLConfig SDL_EGL_GetCurrentConfig(void);
# 2824 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern SDL_EGLSurface SDL_EGL_GetWindowSurface(SDL_Window *window);
# 2844 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern void SDL_EGL_SetAttributeCallbacks(SDL_EGLAttribArrayCallback platformAttribCallback,
                                                               SDL_EGLIntArrayCallback surfaceAttribCallback,
                                                               SDL_EGLIntArrayCallback contextAttribCallback, void *userdata);
# 2875 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_GL_SetSwapInterval(int interval);
# 2894 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_GL_GetSwapInterval(int *interval);
# 2912 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_GL_SwapWindow(SDL_Window *window);
# 2925 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h"
extern bool SDL_GL_DestroyContext(SDL_GLContext context);






}

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_close_code.h" 1
# 2935 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_video.h" 2
# 38 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_keyboard.h" 2

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_begin_code.h" 1
# 40 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_keyboard.h" 2


extern "C" {
# 55 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_keyboard.h"
typedef Uint32 SDL_KeyboardID;
# 68 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_keyboard.h"
extern bool SDL_HasKeyboard(void);
# 89 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_keyboard.h"
extern SDL_KeyboardID * SDL_GetKeyboards(int *count);
# 104 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_keyboard.h"
extern const char * SDL_GetKeyboardNameForID(SDL_KeyboardID instance_id);
# 113 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_keyboard.h"
extern SDL_Window * SDL_GetKeyboardFocus(void);
# 144 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_keyboard.h"
extern const bool * SDL_GetKeyboardState(int *numkeys);
# 155 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_keyboard.h"
extern void SDL_ResetKeyboard(void);
# 168 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_keyboard.h"
extern SDL_Keymod SDL_GetModState(void);
# 187 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_keyboard.h"
extern void SDL_SetModState(SDL_Keymod modstate);
# 209 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_keyboard.h"
extern SDL_Keycode SDL_GetKeyFromScancode(SDL_Scancode scancode, SDL_Keymod modstate, bool key_event);
# 228 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_keyboard.h"
extern SDL_Scancode SDL_GetScancodeFromKey(SDL_Keycode key, SDL_Keymod *modstate);
# 244 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_keyboard.h"
extern bool SDL_SetScancodeName(SDL_Scancode scancode, const char *name);
# 268 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_keyboard.h"
extern const char * SDL_GetScancodeName(SDL_Scancode scancode);
# 283 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_keyboard.h"
extern SDL_Scancode SDL_GetScancodeFromName(const char *name);
# 299 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_keyboard.h"
extern const char * SDL_GetKeyName(SDL_Keycode key);
# 314 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_keyboard.h"
extern SDL_Keycode SDL_GetKeyFromName(const char *name);
# 340 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_keyboard.h"
extern bool SDL_StartTextInput(SDL_Window *window);
# 353 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_keyboard.h"
typedef enum SDL_TextInputType
{
    SDL_TEXTINPUT_TYPE_TEXT,
    SDL_TEXTINPUT_TYPE_TEXT_NAME,
    SDL_TEXTINPUT_TYPE_TEXT_EMAIL,
    SDL_TEXTINPUT_TYPE_TEXT_USERNAME,
    SDL_TEXTINPUT_TYPE_TEXT_PASSWORD_HIDDEN,
    SDL_TEXTINPUT_TYPE_TEXT_PASSWORD_VISIBLE,
    SDL_TEXTINPUT_TYPE_NUMBER,
    SDL_TEXTINPUT_TYPE_NUMBER_PASSWORD_HIDDEN,
    SDL_TEXTINPUT_TYPE_NUMBER_PASSWORD_VISIBLE
} SDL_TextInputType;
# 378 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_keyboard.h"
typedef enum SDL_Capitalization
{
    SDL_CAPITALIZE_NONE,
    SDL_CAPITALIZE_SENTENCES,
    SDL_CAPITALIZE_WORDS,
    SDL_CAPITALIZE_LETTERS
} SDL_Capitalization;
# 434 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_keyboard.h"
extern bool SDL_StartTextInputWithProperties(SDL_Window *window, SDL_PropertiesID props);
# 452 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_keyboard.h"
extern bool SDL_TextInputActive(SDL_Window *window);
# 468 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_keyboard.h"
extern bool SDL_StopTextInput(SDL_Window *window);
# 482 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_keyboard.h"
extern bool SDL_ClearComposition(SDL_Window *window);
# 503 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_keyboard.h"
extern bool SDL_SetTextInputArea(SDL_Window *window, const SDL_Rect *rect, int cursor);
# 522 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_keyboard.h"
extern bool SDL_GetTextInputArea(SDL_Window *window, SDL_Rect *rect, int *cursor);
# 535 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_keyboard.h"
extern bool SDL_HasScreenKeyboardSupport(void);
# 547 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_keyboard.h"
extern bool SDL_ScreenKeyboardShown(SDL_Window *window);



}

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_close_code.h" 1
# 554 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_keyboard.h" 2
# 38 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_events.h" 2

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mouse.h" 1
# 36 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mouse.h"
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_begin_code.h" 1
# 37 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mouse.h" 2


extern "C" {
# 52 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mouse.h"
typedef Uint32 SDL_MouseID;
# 61 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mouse.h"
typedef struct SDL_Cursor SDL_Cursor;






typedef enum SDL_SystemCursor
{
    SDL_SYSTEM_CURSOR_DEFAULT,
    SDL_SYSTEM_CURSOR_TEXT,
    SDL_SYSTEM_CURSOR_WAIT,
    SDL_SYSTEM_CURSOR_CROSSHAIR,
    SDL_SYSTEM_CURSOR_PROGRESS,
    SDL_SYSTEM_CURSOR_NWSE_RESIZE,
    SDL_SYSTEM_CURSOR_NESW_RESIZE,
    SDL_SYSTEM_CURSOR_EW_RESIZE,
    SDL_SYSTEM_CURSOR_NS_RESIZE,
    SDL_SYSTEM_CURSOR_MOVE,
    SDL_SYSTEM_CURSOR_NOT_ALLOWED,
    SDL_SYSTEM_CURSOR_POINTER,
    SDL_SYSTEM_CURSOR_NW_RESIZE,
    SDL_SYSTEM_CURSOR_N_RESIZE,
    SDL_SYSTEM_CURSOR_NE_RESIZE,
    SDL_SYSTEM_CURSOR_E_RESIZE,
    SDL_SYSTEM_CURSOR_SE_RESIZE,
    SDL_SYSTEM_CURSOR_S_RESIZE,
    SDL_SYSTEM_CURSOR_SW_RESIZE,
    SDL_SYSTEM_CURSOR_W_RESIZE,
    SDL_SYSTEM_CURSOR_COUNT
} SDL_SystemCursor;






typedef enum SDL_MouseWheelDirection
{
    SDL_MOUSEWHEEL_NORMAL,
    SDL_MOUSEWHEEL_FLIPPED
} SDL_MouseWheelDirection;
# 119 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mouse.h"
typedef Uint32 SDL_MouseButtonFlags;
# 146 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mouse.h"
extern bool SDL_HasMouse(void);
# 167 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mouse.h"
extern SDL_MouseID * SDL_GetMice(int *count);
# 182 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mouse.h"
extern const char * SDL_GetMouseNameForID(SDL_MouseID instance_id);
# 191 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mouse.h"
extern SDL_Window * SDL_GetMouseFocus(void);
# 213 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mouse.h"
extern SDL_MouseButtonFlags SDL_GetMouseState(float *x, float *y);
# 243 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mouse.h"
extern SDL_MouseButtonFlags SDL_GetGlobalMouseState(float *x, float *y);
# 262 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mouse.h"
extern SDL_MouseButtonFlags SDL_GetRelativeMouseState(float *x, float *y);
# 283 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mouse.h"
extern void SDL_WarpMouseInWindow(SDL_Window * window,
                                                   float x, float y);
# 306 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mouse.h"
extern bool SDL_WarpMouseGlobal(float x, float y);
# 327 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mouse.h"
extern bool SDL_SetWindowRelativeMouseMode(SDL_Window *window, bool enabled);
# 339 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mouse.h"
extern bool SDL_GetWindowRelativeMouseMode(SDL_Window *window);
# 385 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mouse.h"
extern bool SDL_CaptureMouse(bool enabled);
# 429 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mouse.h"
extern SDL_Cursor * SDL_CreateCursor(const Uint8 * data,
                                                     const Uint8 * mask,
                                                     int w, int h, int hot_x,
                                                     int hot_y);
# 460 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mouse.h"
extern SDL_Cursor * SDL_CreateColorCursor(SDL_Surface *surface,
                                                          int hot_x,
                                                          int hot_y);
# 475 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mouse.h"
extern SDL_Cursor * SDL_CreateSystemCursor(SDL_SystemCursor id);
# 493 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mouse.h"
extern bool SDL_SetCursor(SDL_Cursor *cursor);
# 507 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mouse.h"
extern SDL_Cursor * SDL_GetCursor(void);
# 520 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mouse.h"
extern SDL_Cursor * SDL_GetDefaultCursor(void);
# 536 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mouse.h"
extern void SDL_DestroyCursor(SDL_Cursor *cursor);
# 549 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mouse.h"
extern bool SDL_ShowCursor(void);
# 562 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mouse.h"
extern bool SDL_HideCursor(void);
# 575 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mouse.h"
extern bool SDL_CursorVisible(void);



}

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_close_code.h" 1
# 582 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_mouse.h" 2
# 40 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_events.h" 2
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_pen.h" 1
# 46 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_pen.h"
extern "C" {
# 60 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_pen.h"
typedef Uint32 SDL_PenID;







typedef Uint32 SDL_PenInputFlags;
# 93 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_pen.h"
typedef enum SDL_PenAxis
{
    SDL_PEN_AXIS_PRESSURE,
    SDL_PEN_AXIS_XTILT,
    SDL_PEN_AXIS_YTILT,
    SDL_PEN_AXIS_DISTANCE,
    SDL_PEN_AXIS_ROTATION,
    SDL_PEN_AXIS_SLIDER,
    SDL_PEN_AXIS_TANGENTIAL_PRESSURE,
    SDL_PEN_AXIS_COUNT
} SDL_PenAxis;



}
# 41 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_events.h" 2



# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_touch.h" 1
# 35 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_touch.h"
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_begin_code.h" 1
# 36 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_touch.h" 2


extern "C" {


typedef Uint64 SDL_TouchID;
typedef Uint64 SDL_FingerID;

typedef enum SDL_TouchDeviceType
{
    SDL_TOUCH_DEVICE_INVALID = -1,
    SDL_TOUCH_DEVICE_DIRECT,
    SDL_TOUCH_DEVICE_INDIRECT_ABSOLUTE,
    SDL_TOUCH_DEVICE_INDIRECT_RELATIVE
} SDL_TouchDeviceType;
# 63 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_touch.h"
typedef struct SDL_Finger
{
    SDL_FingerID id;
    float x;
    float y;
    float pressure;
} SDL_Finger;
# 93 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_touch.h"
extern SDL_TouchID * SDL_GetTouchDevices(int *count);
# 104 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_touch.h"
extern const char * SDL_GetTouchDeviceName(SDL_TouchID touchID);
# 114 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_touch.h"
extern SDL_TouchDeviceType SDL_GetTouchDeviceType(SDL_TouchID touchID);
# 129 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_touch.h"
extern SDL_Finger ** SDL_GetTouchFingers(SDL_TouchID touchID, int *count);



}

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_close_code.h" 1
# 136 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_touch.h" 2
# 45 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_events.h" 2


# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_begin_code.h" 1
# 48 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_events.h" 2


extern "C" {
# 60 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_events.h"
typedef enum SDL_EventType
{
    SDL_EVENT_FIRST = 0,


    SDL_EVENT_QUIT = 0x100,


    SDL_EVENT_TERMINATING,



    SDL_EVENT_LOW_MEMORY,



    SDL_EVENT_WILL_ENTER_BACKGROUND,



    SDL_EVENT_DID_ENTER_BACKGROUND,



    SDL_EVENT_WILL_ENTER_FOREGROUND,



    SDL_EVENT_DID_ENTER_FOREGROUND,




    SDL_EVENT_LOCALE_CHANGED,

    SDL_EVENT_SYSTEM_THEME_CHANGED,



    SDL_EVENT_DISPLAY_ORIENTATION = 0x151,
    SDL_EVENT_DISPLAY_ADDED,
    SDL_EVENT_DISPLAY_REMOVED,
    SDL_EVENT_DISPLAY_MOVED,
    SDL_EVENT_DISPLAY_DESKTOP_MODE_CHANGED,
    SDL_EVENT_DISPLAY_CURRENT_MODE_CHANGED,
    SDL_EVENT_DISPLAY_CONTENT_SCALE_CHANGED,
    SDL_EVENT_DISPLAY_FIRST = SDL_EVENT_DISPLAY_ORIENTATION,
    SDL_EVENT_DISPLAY_LAST = SDL_EVENT_DISPLAY_CONTENT_SCALE_CHANGED,




    SDL_EVENT_WINDOW_SHOWN = 0x202,
    SDL_EVENT_WINDOW_HIDDEN,
    SDL_EVENT_WINDOW_EXPOSED,
    SDL_EVENT_WINDOW_MOVED,
    SDL_EVENT_WINDOW_RESIZED,
    SDL_EVENT_WINDOW_PIXEL_SIZE_CHANGED,
    SDL_EVENT_WINDOW_METAL_VIEW_RESIZED,
    SDL_EVENT_WINDOW_MINIMIZED,
    SDL_EVENT_WINDOW_MAXIMIZED,
    SDL_EVENT_WINDOW_RESTORED,
    SDL_EVENT_WINDOW_MOUSE_ENTER,
    SDL_EVENT_WINDOW_MOUSE_LEAVE,
    SDL_EVENT_WINDOW_FOCUS_GAINED,
    SDL_EVENT_WINDOW_FOCUS_LOST,
    SDL_EVENT_WINDOW_CLOSE_REQUESTED,
    SDL_EVENT_WINDOW_HIT_TEST,
    SDL_EVENT_WINDOW_ICCPROF_CHANGED,
    SDL_EVENT_WINDOW_DISPLAY_CHANGED,
    SDL_EVENT_WINDOW_DISPLAY_SCALE_CHANGED,
    SDL_EVENT_WINDOW_SAFE_AREA_CHANGED,
    SDL_EVENT_WINDOW_OCCLUDED,
    SDL_EVENT_WINDOW_ENTER_FULLSCREEN,
    SDL_EVENT_WINDOW_LEAVE_FULLSCREEN,
    SDL_EVENT_WINDOW_DESTROYED,



    SDL_EVENT_WINDOW_HDR_STATE_CHANGED,
    SDL_EVENT_WINDOW_FIRST = SDL_EVENT_WINDOW_SHOWN,
    SDL_EVENT_WINDOW_LAST = SDL_EVENT_WINDOW_HDR_STATE_CHANGED,


    SDL_EVENT_KEY_DOWN = 0x300,
    SDL_EVENT_KEY_UP,
    SDL_EVENT_TEXT_EDITING,
    SDL_EVENT_TEXT_INPUT,
    SDL_EVENT_KEYMAP_CHANGED,

    SDL_EVENT_KEYBOARD_ADDED,
    SDL_EVENT_KEYBOARD_REMOVED,
    SDL_EVENT_TEXT_EDITING_CANDIDATES,


    SDL_EVENT_MOUSE_MOTION = 0x400,
    SDL_EVENT_MOUSE_BUTTON_DOWN,
    SDL_EVENT_MOUSE_BUTTON_UP,
    SDL_EVENT_MOUSE_WHEEL,
    SDL_EVENT_MOUSE_ADDED,
    SDL_EVENT_MOUSE_REMOVED,


    SDL_EVENT_JOYSTICK_AXIS_MOTION = 0x600,
    SDL_EVENT_JOYSTICK_BALL_MOTION,
    SDL_EVENT_JOYSTICK_HAT_MOTION,
    SDL_EVENT_JOYSTICK_BUTTON_DOWN,
    SDL_EVENT_JOYSTICK_BUTTON_UP,
    SDL_EVENT_JOYSTICK_ADDED,
    SDL_EVENT_JOYSTICK_REMOVED,
    SDL_EVENT_JOYSTICK_BATTERY_UPDATED,
    SDL_EVENT_JOYSTICK_UPDATE_COMPLETE,


    SDL_EVENT_GAMEPAD_AXIS_MOTION = 0x650,
    SDL_EVENT_GAMEPAD_BUTTON_DOWN,
    SDL_EVENT_GAMEPAD_BUTTON_UP,
    SDL_EVENT_GAMEPAD_ADDED,
    SDL_EVENT_GAMEPAD_REMOVED,
    SDL_EVENT_GAMEPAD_REMAPPED,
    SDL_EVENT_GAMEPAD_TOUCHPAD_DOWN,
    SDL_EVENT_GAMEPAD_TOUCHPAD_MOTION,
    SDL_EVENT_GAMEPAD_TOUCHPAD_UP,
    SDL_EVENT_GAMEPAD_SENSOR_UPDATE,
    SDL_EVENT_GAMEPAD_UPDATE_COMPLETE,
    SDL_EVENT_GAMEPAD_STEAM_HANDLE_UPDATED,


    SDL_EVENT_FINGER_DOWN = 0x700,
    SDL_EVENT_FINGER_UP,
    SDL_EVENT_FINGER_MOTION,




    SDL_EVENT_CLIPBOARD_UPDATE = 0x900,


    SDL_EVENT_DROP_FILE = 0x1000,
    SDL_EVENT_DROP_TEXT,
    SDL_EVENT_DROP_BEGIN,
    SDL_EVENT_DROP_COMPLETE,
    SDL_EVENT_DROP_POSITION,


    SDL_EVENT_AUDIO_DEVICE_ADDED = 0x1100,
    SDL_EVENT_AUDIO_DEVICE_REMOVED,
    SDL_EVENT_AUDIO_DEVICE_FORMAT_CHANGED,


    SDL_EVENT_SENSOR_UPDATE = 0x1200,


    SDL_EVENT_PEN_PROXIMITY_IN = 0x1300,
    SDL_EVENT_PEN_PROXIMITY_OUT,
    SDL_EVENT_PEN_DOWN,
    SDL_EVENT_PEN_UP,
    SDL_EVENT_PEN_BUTTON_DOWN,
    SDL_EVENT_PEN_BUTTON_UP,
    SDL_EVENT_PEN_MOTION,
    SDL_EVENT_PEN_AXIS,


    SDL_EVENT_CAMERA_DEVICE_ADDED = 0x1400,
    SDL_EVENT_CAMERA_DEVICE_REMOVED,
    SDL_EVENT_CAMERA_DEVICE_APPROVED,
    SDL_EVENT_CAMERA_DEVICE_DENIED,


    SDL_EVENT_RENDER_TARGETS_RESET = 0x2000,
    SDL_EVENT_RENDER_DEVICE_RESET,


    SDL_EVENT_POLL_SENTINEL = 0x7F00,




    SDL_EVENT_USER = 0x8000,




    SDL_EVENT_LAST = 0xFFFF,


    SDL_EVENT_ENUM_PADDING = 0x7FFFFFFF

} SDL_EventType;






typedef struct SDL_CommonEvent
{
    Uint32 type;
    Uint32 reserved;
    Uint64 timestamp;
} SDL_CommonEvent;






typedef struct SDL_DisplayEvent
{
    SDL_EventType type;
    Uint32 reserved;
    Uint64 timestamp;
    SDL_DisplayID displayID;
    Sint32 data1;
    Sint32 data2;
} SDL_DisplayEvent;






typedef struct SDL_WindowEvent
{
    SDL_EventType type;
    Uint32 reserved;
    Uint64 timestamp;
    SDL_WindowID windowID;
    Sint32 data1;
    Sint32 data2;
} SDL_WindowEvent;






typedef struct SDL_KeyboardDeviceEvent
{
    SDL_EventType type;
    Uint32 reserved;
    Uint64 timestamp;
    SDL_KeyboardID which;
} SDL_KeyboardDeviceEvent;
# 319 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_events.h"
typedef struct SDL_KeyboardEvent
{
    SDL_EventType type;
    Uint32 reserved;
    Uint64 timestamp;
    SDL_WindowID windowID;
    SDL_KeyboardID which;
    SDL_Scancode scancode;
    SDL_Keycode key;
    SDL_Keymod mod;
    Uint16 raw;
    bool down;
    bool repeat;
} SDL_KeyboardEvent;
# 343 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_events.h"
typedef struct SDL_TextEditingEvent
{
    SDL_EventType type;
    Uint32 reserved;
    Uint64 timestamp;
    SDL_WindowID windowID;
    const char *text;
    Sint32 start;
    Sint32 length;
} SDL_TextEditingEvent;






typedef struct SDL_TextEditingCandidatesEvent
{
    SDL_EventType type;
    Uint32 reserved;
    Uint64 timestamp;
    SDL_WindowID windowID;
    const char * const *candidates;
    Sint32 num_candidates;
    Sint32 selected_candidate;
    bool horizontal;
    Uint8 padding1;
    Uint8 padding2;
    Uint8 padding3;
} SDL_TextEditingCandidatesEvent;
# 385 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_events.h"
typedef struct SDL_TextInputEvent
{
    SDL_EventType type;
    Uint32 reserved;
    Uint64 timestamp;
    SDL_WindowID windowID;
    const char *text;
} SDL_TextInputEvent;






typedef struct SDL_MouseDeviceEvent
{
    SDL_EventType type;
    Uint32 reserved;
    Uint64 timestamp;
    SDL_MouseID which;
} SDL_MouseDeviceEvent;






typedef struct SDL_MouseMotionEvent
{
    SDL_EventType type;
    Uint32 reserved;
    Uint64 timestamp;
    SDL_WindowID windowID;
    SDL_MouseID which;
    SDL_MouseButtonFlags state;
    float x;
    float y;
    float xrel;
    float yrel;
} SDL_MouseMotionEvent;






typedef struct SDL_MouseButtonEvent
{
    SDL_EventType type;
    Uint32 reserved;
    Uint64 timestamp;
    SDL_WindowID windowID;
    SDL_MouseID which;
    Uint8 button;
    bool down;
    Uint8 clicks;
    Uint8 padding;
    float x;
    float y;
} SDL_MouseButtonEvent;






typedef struct SDL_MouseWheelEvent
{
    SDL_EventType type;
    Uint32 reserved;
    Uint64 timestamp;
    SDL_WindowID windowID;
    SDL_MouseID which;
    float x;
    float y;
    SDL_MouseWheelDirection direction;
    float mouse_x;
    float mouse_y;
} SDL_MouseWheelEvent;






typedef struct SDL_JoyAxisEvent
{
    SDL_EventType type;
    Uint32 reserved;
    Uint64 timestamp;
    SDL_JoystickID which;
    Uint8 axis;
    Uint8 padding1;
    Uint8 padding2;
    Uint8 padding3;
    Sint16 value;
    Uint16 padding4;
} SDL_JoyAxisEvent;






typedef struct SDL_JoyBallEvent
{
    SDL_EventType type;
    Uint32 reserved;
    Uint64 timestamp;
    SDL_JoystickID which;
    Uint8 ball;
    Uint8 padding1;
    Uint8 padding2;
    Uint8 padding3;
    Sint16 xrel;
    Sint16 yrel;
} SDL_JoyBallEvent;






typedef struct SDL_JoyHatEvent
{
    SDL_EventType type;
    Uint32 reserved;
    Uint64 timestamp;
    SDL_JoystickID which;
    Uint8 hat;
    Uint8 value;






    Uint8 padding1;
    Uint8 padding2;
} SDL_JoyHatEvent;






typedef struct SDL_JoyButtonEvent
{
    SDL_EventType type;
    Uint32 reserved;
    Uint64 timestamp;
    SDL_JoystickID which;
    Uint8 button;
    bool down;
    Uint8 padding1;
    Uint8 padding2;
} SDL_JoyButtonEvent;






typedef struct SDL_JoyDeviceEvent
{
    SDL_EventType type;
    Uint32 reserved;
    Uint64 timestamp;
    SDL_JoystickID which;
} SDL_JoyDeviceEvent;






typedef struct SDL_JoyBatteryEvent
{
    SDL_EventType type;
    Uint32 reserved;
    Uint64 timestamp;
    SDL_JoystickID which;
    SDL_PowerState state;
    int percent;
} SDL_JoyBatteryEvent;






typedef struct SDL_GamepadAxisEvent
{
    SDL_EventType type;
    Uint32 reserved;
    Uint64 timestamp;
    SDL_JoystickID which;
    Uint8 axis;
    Uint8 padding1;
    Uint8 padding2;
    Uint8 padding3;
    Sint16 value;
    Uint16 padding4;
} SDL_GamepadAxisEvent;







typedef struct SDL_GamepadButtonEvent
{
    SDL_EventType type;
    Uint32 reserved;
    Uint64 timestamp;
    SDL_JoystickID which;
    Uint8 button;
    bool down;
    Uint8 padding1;
    Uint8 padding2;
} SDL_GamepadButtonEvent;







typedef struct SDL_GamepadDeviceEvent
{
    SDL_EventType type;
    Uint32 reserved;
    Uint64 timestamp;
    SDL_JoystickID which;
} SDL_GamepadDeviceEvent;






typedef struct SDL_GamepadTouchpadEvent
{
    SDL_EventType type;
    Uint32 reserved;
    Uint64 timestamp;
    SDL_JoystickID which;
    Sint32 touchpad;
    Sint32 finger;
    float x;
    float y;
    float pressure;
} SDL_GamepadTouchpadEvent;






typedef struct SDL_GamepadSensorEvent
{
    SDL_EventType type;
    Uint32 reserved;
    Uint64 timestamp;
    SDL_JoystickID which;
    Sint32 sensor;
    float data[3];
    Uint64 sensor_timestamp;
} SDL_GamepadSensorEvent;






typedef struct SDL_AudioDeviceEvent
{
    SDL_EventType type;
    Uint32 reserved;
    Uint64 timestamp;
    SDL_AudioDeviceID which;
    bool recording;
    Uint8 padding1;
    Uint8 padding2;
    Uint8 padding3;
} SDL_AudioDeviceEvent;






typedef struct SDL_CameraDeviceEvent
{
    SDL_EventType type;
    Uint32 reserved;
    Uint64 timestamp;
    SDL_CameraID which;
} SDL_CameraDeviceEvent;






typedef struct SDL_TouchFingerEvent
{
    SDL_EventType type;
    Uint32 reserved;
    Uint64 timestamp;
    SDL_TouchID touchID;
    SDL_FingerID fingerID;
    float x;
    float y;
    float dx;
    float dy;
    float pressure;
    SDL_WindowID windowID;
} SDL_TouchFingerEvent;
# 721 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_events.h"
typedef struct SDL_PenProximityEvent
{
    SDL_EventType type;
    Uint32 reserved;
    Uint64 timestamp;
    SDL_WindowID windowID;
    SDL_PenID which;
} SDL_PenProximityEvent;
# 741 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_events.h"
typedef struct SDL_PenMotionEvent
{
    SDL_EventType type;
    Uint32 reserved;
    Uint64 timestamp;
    SDL_WindowID windowID;
    SDL_PenID which;
    SDL_PenInputFlags pen_state;
    float x;
    float y;
} SDL_PenMotionEvent;
# 761 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_events.h"
typedef struct SDL_PenTouchEvent
{
    SDL_EventType type;
    Uint32 reserved;
    Uint64 timestamp;
    SDL_WindowID windowID;
    SDL_PenID which;
    SDL_PenInputFlags pen_state;
    float x;
    float y;
    bool eraser;
    bool down;
} SDL_PenTouchEvent;
# 783 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_events.h"
typedef struct SDL_PenButtonEvent
{
    SDL_EventType type;
    Uint32 reserved;
    Uint64 timestamp;
    SDL_WindowID windowID;
    SDL_PenID which;
    SDL_PenInputFlags pen_state;
    float x;
    float y;
    Uint8 button;
    bool down;
} SDL_PenButtonEvent;
# 805 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_events.h"
typedef struct SDL_PenAxisEvent
{
    SDL_EventType type;
    Uint32 reserved;
    Uint64 timestamp;
    SDL_WindowID windowID;
    SDL_PenID which;
    SDL_PenInputFlags pen_state;
    float x;
    float y;
    SDL_PenAxis axis;
    float value;
} SDL_PenAxisEvent;







typedef struct SDL_DropEvent
{
    SDL_EventType type;
    Uint32 reserved;
    Uint64 timestamp;
    SDL_WindowID windowID;
    float x;
    float y;
    const char *source;
    const char *data;
} SDL_DropEvent;







typedef struct SDL_ClipboardEvent
{
    SDL_EventType type;
    Uint32 reserved;
    Uint64 timestamp;
    bool owner;
    Sint32 n_mime_types;
    const char **mime_types;
} SDL_ClipboardEvent;






typedef struct SDL_SensorEvent
{
    SDL_EventType type;
    Uint32 reserved;
    Uint64 timestamp;
    SDL_SensorID which;
    float data[6];
    Uint64 sensor_timestamp;
} SDL_SensorEvent;






typedef struct SDL_QuitEvent
{
    SDL_EventType type;
    Uint32 reserved;
    Uint64 timestamp;
} SDL_QuitEvent;
# 891 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_events.h"
typedef struct SDL_UserEvent
{
    Uint32 type;
    Uint32 reserved;
    Uint64 timestamp;
    SDL_WindowID windowID;
    Sint32 code;
    void *data1;
    void *data2;
} SDL_UserEvent;







typedef union SDL_Event
{
    Uint32 type;
    SDL_CommonEvent common;
    SDL_DisplayEvent display;
    SDL_WindowEvent window;
    SDL_KeyboardDeviceEvent kdevice;
    SDL_KeyboardEvent key;
    SDL_TextEditingEvent edit;
    SDL_TextEditingCandidatesEvent edit_candidates;
    SDL_TextInputEvent text;
    SDL_MouseDeviceEvent mdevice;
    SDL_MouseMotionEvent motion;
    SDL_MouseButtonEvent button;
    SDL_MouseWheelEvent wheel;
    SDL_JoyDeviceEvent jdevice;
    SDL_JoyAxisEvent jaxis;
    SDL_JoyBallEvent jball;
    SDL_JoyHatEvent jhat;
    SDL_JoyButtonEvent jbutton;
    SDL_JoyBatteryEvent jbattery;
    SDL_GamepadDeviceEvent gdevice;
    SDL_GamepadAxisEvent gaxis;
    SDL_GamepadButtonEvent gbutton;
    SDL_GamepadTouchpadEvent gtouchpad;
    SDL_GamepadSensorEvent gsensor;
    SDL_AudioDeviceEvent adevice;
    SDL_CameraDeviceEvent cdevice;
    SDL_SensorEvent sensor;
    SDL_QuitEvent quit;
    SDL_UserEvent user;
    SDL_TouchFingerEvent tfinger;
    SDL_PenProximityEvent pproximity;
    SDL_PenTouchEvent ptouch;
    SDL_PenMotionEvent pmotion;
    SDL_PenButtonEvent pbutton;
    SDL_PenAxisEvent paxis;
    SDL_DropEvent drop;
    SDL_ClipboardEvent clipboard;
# 961 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_events.h"
    Uint8 padding[128];
} SDL_Event;


static_assert(sizeof(SDL_Event) == sizeof(((SDL_Event *)
# 965 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_events.h" 3 4
__null
# 965 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_events.h"
)->padding), "sizeof(SDL_Event) == sizeof(((SDL_Event *)NULL)->padding)");
# 992 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_events.h"
extern void SDL_PumpEvents(void);
# 1001 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_events.h"
typedef enum SDL_EventAction
{
    SDL_ADDEVENT,
    SDL_PEEKEVENT,
    SDL_GETEVENT
} SDL_EventAction;
# 1050 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_events.h"
extern int SDL_PeepEvents(SDL_Event *events, int numevents, SDL_EventAction action, Uint32 minType, Uint32 maxType);
# 1067 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_events.h"
extern bool SDL_HasEvent(Uint32 type);
# 1086 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_events.h"
extern bool SDL_HasEvents(Uint32 minType, Uint32 maxType);
# 1112 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_events.h"
extern void SDL_FlushEvent(Uint32 type);
# 1137 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_events.h"
extern void SDL_FlushEvents(Uint32 minType, Uint32 maxType);
# 1181 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_events.h"
extern bool SDL_PollEvent(SDL_Event *event);
# 1203 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_events.h"
extern bool SDL_WaitEvent(SDL_Event *event);
# 1231 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_events.h"
extern bool SDL_WaitEventTimeout(SDL_Event *event, Sint32 timeoutMS);
# 1265 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_events.h"
extern bool SDL_PushEvent(SDL_Event *event);
# 1286 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_events.h"
typedef bool ( *SDL_EventFilter)(void *userdata, SDL_Event *event);
# 1334 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_events.h"
extern void SDL_SetEventFilter(SDL_EventFilter filter, void *userdata);
# 1351 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_events.h"
extern bool SDL_GetEventFilter(SDL_EventFilter *filter, void **userdata);
# 1383 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_events.h"
extern bool SDL_AddEventWatch(SDL_EventFilter filter, void *userdata);
# 1398 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_events.h"
extern void SDL_RemoveEventWatch(SDL_EventFilter filter, void *userdata);
# 1416 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_events.h"
extern void SDL_FilterEvents(SDL_EventFilter filter, void *userdata);
# 1428 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_events.h"
extern void SDL_SetEventEnabled(Uint32 type, bool enabled);
# 1440 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_events.h"
extern bool SDL_EventEnabled(Uint32 type);
# 1454 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_events.h"
extern Uint32 SDL_RegisterEvents(int numevents);
# 1468 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_events.h"
extern SDL_Window * SDL_GetWindowFromEvent(const SDL_Event *event);



}

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_close_code.h" 1
# 1475 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_events.h" 2
# 57 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h" 2






# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_begin_code.h" 1
# 64 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h" 2


extern "C" {
# 81 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
typedef struct SDL_Vertex
{
    SDL_FPoint position;
    SDL_FColor color;
    SDL_FPoint tex_coord;
} SDL_Vertex;






typedef enum SDL_TextureAccess
{
    SDL_TEXTUREACCESS_STATIC,
    SDL_TEXTUREACCESS_STREAMING,
    SDL_TEXTUREACCESS_TARGET
} SDL_TextureAccess;






typedef enum SDL_RendererLogicalPresentation
{
    SDL_LOGICAL_PRESENTATION_DISABLED,
    SDL_LOGICAL_PRESENTATION_STRETCH,
    SDL_LOGICAL_PRESENTATION_LETTERBOX,
    SDL_LOGICAL_PRESENTATION_OVERSCAN,
    SDL_LOGICAL_PRESENTATION_INTEGER_SCALE
} SDL_RendererLogicalPresentation;






typedef struct SDL_Renderer SDL_Renderer;
# 133 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
struct SDL_Texture
{
    SDL_PixelFormat format;
    int w;
    int h;

    int refcount;
};


typedef struct SDL_Texture SDL_Texture;
# 165 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern int SDL_GetNumRenderDrivers(void);
# 189 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern const char * SDL_GetRenderDriver(int index);
# 211 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_CreateWindowAndRenderer(const char *title, int width, int height, SDL_WindowFlags window_flags, SDL_Window **window, SDL_Renderer **renderer);
# 243 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern SDL_Renderer * SDL_CreateRenderer(SDL_Window *window, const char *name);
# 296 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern SDL_Renderer * SDL_CreateRendererWithProperties(SDL_PropertiesID props);
# 329 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern SDL_Renderer * SDL_CreateSoftwareRenderer(SDL_Surface *surface);
# 342 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern SDL_Renderer * SDL_GetRenderer(SDL_Window *window);
# 355 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern SDL_Window * SDL_GetRenderWindow(SDL_Renderer *renderer);
# 371 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern const char * SDL_GetRendererName(SDL_Renderer *renderer);
# 452 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern SDL_PropertiesID SDL_GetRendererProperties(SDL_Renderer *renderer);
# 496 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_GetRenderOutputSize(SDL_Renderer *renderer, int *w, int *h);
# 518 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_GetCurrentRenderOutputSize(SDL_Renderer *renderer, int *w, int *h);
# 544 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern SDL_Texture * SDL_CreateTexture(SDL_Renderer *renderer, SDL_PixelFormat format, SDL_TextureAccess access, int w, int h);
# 572 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern SDL_Texture * SDL_CreateTextureFromSurface(SDL_Renderer *renderer, SDL_Surface *surface);
# 685 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern SDL_Texture * SDL_CreateTextureWithProperties(SDL_Renderer *renderer, SDL_PropertiesID props);
# 808 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern SDL_PropertiesID SDL_GetTextureProperties(SDL_Texture *texture);
# 848 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern SDL_Renderer * SDL_GetRendererFromTexture(SDL_Texture *texture);
# 865 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_GetTextureSize(SDL_Texture *texture, float *w, float *h);
# 894 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_SetTextureColorMod(SDL_Texture *texture, Uint8 r, Uint8 g, Uint8 b);
# 924 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_SetTextureColorModFloat(SDL_Texture *texture, float r, float g, float b);
# 945 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_GetTextureColorMod(SDL_Texture *texture, Uint8 *r, Uint8 *g, Uint8 *b);
# 965 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_GetTextureColorModFloat(SDL_Texture *texture, float *r, float *g, float *b);
# 991 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_SetTextureAlphaMod(SDL_Texture *texture, Uint8 alpha);
# 1017 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_SetTextureAlphaModFloat(SDL_Texture *texture, float alpha);
# 1035 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_GetTextureAlphaMod(SDL_Texture *texture, Uint8 *alpha);
# 1053 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_GetTextureAlphaModFloat(SDL_Texture *texture, float *alpha);
# 1072 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_SetTextureBlendMode(SDL_Texture *texture, SDL_BlendMode blendMode);
# 1088 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_GetTextureBlendMode(SDL_Texture *texture, SDL_BlendMode *blendMode);
# 1108 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_SetTextureScaleMode(SDL_Texture *texture, SDL_ScaleMode scaleMode);
# 1124 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_GetTextureScaleMode(SDL_Texture *texture, SDL_ScaleMode *scaleMode);
# 1158 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_UpdateTexture(SDL_Texture *texture, const SDL_Rect *rect, const void *pixels, int pitch);
# 1190 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_UpdateYUVTexture(SDL_Texture *texture,
                                                 const SDL_Rect *rect,
                                                 const Uint8 *Yplane, int Ypitch,
                                                 const Uint8 *Uplane, int Upitch,
                                                 const Uint8 *Vplane, int Vpitch);
# 1222 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_UpdateNVTexture(SDL_Texture *texture,
                                                 const SDL_Rect *rect,
                                                 const Uint8 *Yplane, int Ypitch,
                                                 const Uint8 *UVplane, int UVpitch);
# 1257 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_LockTexture(SDL_Texture *texture,
                                            const SDL_Rect *rect,
                                            void **pixels, int *pitch);
# 1295 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_LockTextureToSurface(SDL_Texture *texture, const SDL_Rect *rect, SDL_Surface **surface);
# 1316 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern void SDL_UnlockTexture(SDL_Texture *texture);
# 1338 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_SetRenderTarget(SDL_Renderer *renderer, SDL_Texture *texture);
# 1355 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern SDL_Texture * SDL_GetRenderTarget(SDL_Renderer *renderer);
# 1396 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_SetRenderLogicalPresentation(SDL_Renderer *renderer, int w, int h, SDL_RendererLogicalPresentation mode);
# 1417 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_GetRenderLogicalPresentation(SDL_Renderer *renderer, int *w, int *h, SDL_RendererLogicalPresentation *mode);
# 1439 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_GetRenderLogicalPresentationRect(SDL_Renderer *renderer, SDL_FRect *rect);
# 1466 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_RenderCoordinatesFromWindow(SDL_Renderer *renderer, float window_x, float window_y, float *x, float *y);
# 1496 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_RenderCoordinatesToWindow(SDL_Renderer *renderer, float x, float y, float *window_x, float *window_y);
# 1524 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_ConvertEventToRenderCoordinates(SDL_Renderer *renderer, SDL_Event *event);
# 1548 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_SetRenderViewport(SDL_Renderer *renderer, const SDL_Rect *rect);
# 1565 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_GetRenderViewport(SDL_Renderer *renderer, SDL_Rect *rect);
# 1585 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_RenderViewportSet(SDL_Renderer *renderer);
# 1607 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_GetRenderSafeArea(SDL_Renderer *renderer, SDL_Rect *rect);
# 1625 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_SetRenderClipRect(SDL_Renderer *renderer, const SDL_Rect *rect);
# 1643 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_GetRenderClipRect(SDL_Renderer *renderer, SDL_Rect *rect);
# 1659 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_RenderClipEnabled(SDL_Renderer *renderer);
# 1684 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_SetRenderScale(SDL_Renderer *renderer, float scaleX, float scaleY);
# 1701 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_GetRenderScale(SDL_Renderer *renderer, float *scaleX, float *scaleY);
# 1726 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_SetRenderDrawColor(SDL_Renderer *renderer, Uint8 r, Uint8 g, Uint8 b, Uint8 a);
# 1751 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_SetRenderDrawColorFloat(SDL_Renderer *renderer, float r, float g, float b, float a);
# 1775 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_GetRenderDrawColor(SDL_Renderer *renderer, Uint8 *r, Uint8 *g, Uint8 *b, Uint8 *a);
# 1799 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_GetRenderDrawColorFloat(SDL_Renderer *renderer, float *r, float *g, float *b, float *a);
# 1823 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_SetRenderColorScale(SDL_Renderer *renderer, float scale);
# 1839 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_GetRenderColorScale(SDL_Renderer *renderer, float *scale);
# 1857 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_SetRenderDrawBlendMode(SDL_Renderer *renderer, SDL_BlendMode blendMode);
# 1873 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_GetRenderDrawBlendMode(SDL_Renderer *renderer, SDL_BlendMode *blendMode);
# 1893 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_RenderClear(SDL_Renderer *renderer);
# 1910 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_RenderPoint(SDL_Renderer *renderer, float x, float y);
# 1927 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_RenderPoints(SDL_Renderer *renderer, const SDL_FPoint *points, int count);
# 1946 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_RenderLine(SDL_Renderer *renderer, float x1, float y1, float x2, float y2);
# 1964 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_RenderLines(SDL_Renderer *renderer, const SDL_FPoint *points, int count);
# 1981 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_RenderRect(SDL_Renderer *renderer, const SDL_FRect *rect);
# 1999 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_RenderRects(SDL_Renderer *renderer, const SDL_FRect *rects, int count);
# 2017 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_RenderFillRect(SDL_Renderer *renderer, const SDL_FRect *rect);
# 2035 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_RenderFillRects(SDL_Renderer *renderer, const SDL_FRect *rects, int count);
# 2057 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_RenderTexture(SDL_Renderer *renderer, SDL_Texture *texture, const SDL_FRect *srcrect, const SDL_FRect *dstrect);
# 2085 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_RenderTextureRotated(SDL_Renderer *renderer, SDL_Texture *texture,
                                                     const SDL_FRect *srcrect, const SDL_FRect *dstrect,
                                                     double angle, const SDL_FPoint *center,
                                                     SDL_FlipMode flip);
# 2115 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_RenderTextureTiled(SDL_Renderer *renderer, SDL_Texture *texture, const SDL_FRect *srcrect, float scale, const SDL_FRect *dstrect);
# 2149 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_RenderTexture9Grid(SDL_Renderer *renderer, SDL_Texture *texture, const SDL_FRect *srcrect, float left_width, float right_width, float top_height, float bottom_height, float scale, const SDL_FRect *dstrect);
# 2173 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_RenderGeometry(SDL_Renderer *renderer,
                                               SDL_Texture *texture,
                                               const SDL_Vertex *vertices, int num_vertices,
                                               const int *indices, int num_indices);
# 2205 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_RenderGeometryRaw(SDL_Renderer *renderer,
                                               SDL_Texture *texture,
                                               const float *xy, int xy_stride,
                                               const SDL_FColor *color, int color_stride,
                                               const float *uv, int uv_stride,
                                               int num_vertices,
                                               const void *indices, int num_indices, int size_indices);
# 2232 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern SDL_Surface * SDL_RenderReadPixels(SDL_Renderer *renderer, const SDL_Rect *rect);
# 2282 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_RenderPresent(SDL_Renderer *renderer);
# 2299 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern void SDL_DestroyTexture(SDL_Texture *texture);
# 2315 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern void SDL_DestroyRenderer(SDL_Renderer *renderer);
# 2348 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_FlushRenderer(SDL_Renderer *renderer);
# 2366 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern void * SDL_GetRenderMetalLayer(SDL_Renderer *renderer);
# 2389 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern void * SDL_GetRenderMetalCommandEncoder(SDL_Renderer *renderer);
# 2420 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_AddVulkanRenderSemaphores(SDL_Renderer *renderer, Uint32 wait_stage_mask, Sint64 wait_semaphore, Sint64 signal_semaphore);
# 2445 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_SetRenderVSync(SDL_Renderer *renderer, int vsync);
# 2465 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_GetRenderVSync(SDL_Renderer *renderer, int *vsync);
# 2516 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h"
extern bool SDL_RenderDebugText(SDL_Renderer *renderer, float x, float y, const char *str);



}

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_close_code.h" 1
# 2523 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_render.h" 2
# 5 "D:/Institute/Third_year/PZ_Networks/1_3/Client/Entities/Entity/Entity.h" 2
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL.h" 1
# 32 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL.h"
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_assert.h" 1
# 64 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_assert.h"
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_begin_code.h" 1
# 65 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_assert.h" 2


extern "C" {
# 203 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_assert.h"
typedef enum SDL_AssertState
{
    SDL_ASSERTION_RETRY,
    SDL_ASSERTION_BREAK,
    SDL_ASSERTION_ABORT,
    SDL_ASSERTION_IGNORE,
    SDL_ASSERTION_ALWAYS_IGNORE
} SDL_AssertState;
# 221 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_assert.h"
typedef struct SDL_AssertData
{
    bool always_ignore;
    unsigned int trigger_count;
    const char *condition;
    const char *filename;
    int linenum;
    const char *function;
    const struct SDL_AssertData *next;
} SDL_AssertData;
# 245 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_assert.h"
extern SDL_AssertState SDL_ReportAssertion(SDL_AssertData *data,
                                                            const char *func,
                                                            const char *file, int line) ;
# 423 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_assert.h"
typedef SDL_AssertState ( *SDL_AssertionHandler)(
                                 const SDL_AssertData *data, void *userdata);
# 447 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_assert.h"
extern void SDL_SetAssertionHandler(
                                            SDL_AssertionHandler handler,
                                            void *userdata);
# 466 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_assert.h"
extern SDL_AssertionHandler SDL_GetDefaultAssertionHandler(void);
# 489 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_assert.h"
extern SDL_AssertionHandler SDL_GetAssertionHandler(void **puserdata);
# 517 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_assert.h"
extern const SDL_AssertData * SDL_GetAssertionReport(void);
# 531 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_assert.h"
extern void SDL_ResetAssertionReport(void);



}

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_close_code.h" 1
# 538 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_assert.h" 2
# 33 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL.h" 2


# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_bits.h" 1
# 33 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_bits.h"
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_begin_code.h" 1
# 34 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_bits.h" 2


extern "C" {
# 70 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_bits.h"
__attribute__((always_inline)) static __inline__ int SDL_MostSignificantBitIndex32(Uint32 x)
{




    if (x == 0) {
        return -1;
    }
    return 31 - __builtin_clz(x);
# 117 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_bits.h"
}
# 137 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_bits.h"
__attribute__((always_inline)) static __inline__ bool SDL_HasExactlyOneBitSet32(Uint32 x)
{
    if (x && !(x & (x - 1))) {
        return true;
    }
    return false;
}



}

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_close_code.h" 1
# 150 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_bits.h" 2
# 36 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL.h" 2


# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_clipboard.h" 1
# 37 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_clipboard.h"
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_begin_code.h" 1
# 38 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_clipboard.h" 2


extern "C" {
# 57 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_clipboard.h"
extern bool SDL_SetClipboardText(const char *text);
# 74 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_clipboard.h"
extern char * SDL_GetClipboardText(void);
# 86 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_clipboard.h"
extern bool SDL_HasClipboardText(void);
# 100 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_clipboard.h"
extern bool SDL_SetPrimarySelectionText(const char *text);
# 117 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_clipboard.h"
extern char * SDL_GetPrimarySelectionText(void);
# 130 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_clipboard.h"
extern bool SDL_HasPrimarySelectionText(void);
# 154 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_clipboard.h"
typedef const void *( *SDL_ClipboardDataCallback)(void *userdata, const char *mime_type, size_t *size);
# 166 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_clipboard.h"
typedef void ( *SDL_ClipboardCleanupCallback)(void *userdata);
# 196 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_clipboard.h"
extern bool SDL_SetClipboardData(SDL_ClipboardDataCallback callback, SDL_ClipboardCleanupCallback cleanup, void *userdata, const char **mime_types, size_t num_mime_types);
# 208 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_clipboard.h"
extern bool SDL_ClearClipboardData(void);
# 227 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_clipboard.h"
extern void * SDL_GetClipboardData(const char *mime_type, size_t *size);
# 241 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_clipboard.h"
extern bool SDL_HasClipboardData(const char *mime_type);
# 256 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_clipboard.h"
extern char ** SDL_GetClipboardMimeTypes(size_t *num_mime_types);



}

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_close_code.h" 1
# 263 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_clipboard.h" 2
# 39 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL.h" 2
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_cpuinfo.h" 1
# 39 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_cpuinfo.h"
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_begin_code.h" 1
# 40 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_cpuinfo.h" 2


extern "C" {
# 65 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_cpuinfo.h"
extern int SDL_GetNumLogicalCPUCores(void);
# 77 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_cpuinfo.h"
extern int SDL_GetCPUCacheLineSize(void);
# 89 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_cpuinfo.h"
extern bool SDL_HasAltiVec(void);
# 100 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_cpuinfo.h"
extern bool SDL_HasMMX(void);
# 116 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_cpuinfo.h"
extern bool SDL_HasSSE(void);
# 132 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_cpuinfo.h"
extern bool SDL_HasSSE2(void);
# 148 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_cpuinfo.h"
extern bool SDL_HasSSE3(void);
# 164 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_cpuinfo.h"
extern bool SDL_HasSSE41(void);
# 180 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_cpuinfo.h"
extern bool SDL_HasSSE42(void);
# 194 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_cpuinfo.h"
extern bool SDL_HasAVX(void);
# 208 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_cpuinfo.h"
extern bool SDL_HasAVX2(void);
# 222 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_cpuinfo.h"
extern bool SDL_HasAVX512F(void);
# 237 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_cpuinfo.h"
extern bool SDL_HasARMSIMD(void);
# 248 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_cpuinfo.h"
extern bool SDL_HasNEON(void);
# 260 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_cpuinfo.h"
extern bool SDL_HasLSX(void);
# 272 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_cpuinfo.h"
extern bool SDL_HasLASX(void);
# 281 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_cpuinfo.h"
extern int SDL_GetSystemRAM(void);
# 303 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_cpuinfo.h"
extern size_t SDL_GetSIMDAlignment(void);



}

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_close_code.h" 1
# 310 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_cpuinfo.h" 2
# 40 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL.h" 2
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_dialog.h" 1
# 35 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_dialog.h"
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_begin_code.h" 1
# 36 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_dialog.h" 2


extern "C" {
# 59 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_dialog.h"
typedef struct SDL_DialogFileFilter
{
    const char *name;
    const char *pattern;
} SDL_DialogFileFilter;
# 97 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_dialog.h"
typedef void ( *SDL_DialogFileCallback)(void *userdata, const char * const *filelist, int filter);
# 154 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_dialog.h"
extern void SDL_ShowOpenFileDialog(SDL_DialogFileCallback callback, void *userdata, SDL_Window *window, const SDL_DialogFileFilter *filters, int nfilters, const char *default_location, bool allow_many);
# 209 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_dialog.h"
extern void SDL_ShowSaveFileDialog(SDL_DialogFileCallback callback, void *userdata, SDL_Window *window, const SDL_DialogFileFilter *filters, int nfilters, const char *default_location);
# 257 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_dialog.h"
extern void SDL_ShowOpenFolderDialog(SDL_DialogFileCallback callback, void *userdata, SDL_Window *window, const char *default_location, bool allow_many);



}

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_close_code.h" 1
# 264 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_dialog.h" 2
# 41 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL.h" 2



# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_filesystem.h" 1
# 34 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_filesystem.h"
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_begin_code.h" 1
# 35 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_filesystem.h" 2



extern "C" {
# 80 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_filesystem.h"
extern const char * SDL_GetBasePath(void);
# 135 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_filesystem.h"
extern char * SDL_GetPrefPath(const char *org, const char *app);
# 166 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_filesystem.h"
typedef enum SDL_Folder
{
    SDL_FOLDER_HOME,

    SDL_FOLDER_DESKTOP,

    SDL_FOLDER_DOCUMENTS,

    SDL_FOLDER_DOWNLOADS,

    SDL_FOLDER_MUSIC,

    SDL_FOLDER_PICTURES,

    SDL_FOLDER_PUBLICSHARE,

    SDL_FOLDER_SAVEDGAMES,

    SDL_FOLDER_SCREENSHOTS,

    SDL_FOLDER_TEMPLATES,

    SDL_FOLDER_VIDEOS,

    SDL_FOLDER_COUNT

} SDL_Folder;
# 217 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_filesystem.h"
extern const char * SDL_GetUserFolder(SDL_Folder folder);




typedef enum SDL_PathType
{
    SDL_PATHTYPE_NONE,
    SDL_PATHTYPE_FILE,
    SDL_PATHTYPE_DIRECTORY,
    SDL_PATHTYPE_OTHER
} SDL_PathType;

typedef struct SDL_PathInfo
{
    SDL_PathType type;
    Uint64 size;
    SDL_Time create_time;
    SDL_Time modify_time;
    SDL_Time access_time;
} SDL_PathInfo;
# 247 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_filesystem.h"
typedef Uint32 SDL_GlobFlags;
# 265 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_filesystem.h"
extern bool SDL_CreateDirectory(const char *path);
# 274 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_filesystem.h"
typedef enum SDL_EnumerationResult
{
    SDL_ENUM_CONTINUE,
    SDL_ENUM_SUCCESS,
    SDL_ENUM_FAILURE
} SDL_EnumerationResult;
# 302 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_filesystem.h"
typedef SDL_EnumerationResult ( *SDL_EnumerateDirectoryCallback)(void *userdata, const char *dirname, const char *fname);
# 323 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_filesystem.h"
extern bool SDL_EnumerateDirectory(const char *path, SDL_EnumerateDirectoryCallback callback, void *userdata);
# 337 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_filesystem.h"
extern bool SDL_RemovePath(const char *path);
# 360 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_filesystem.h"
extern bool SDL_RenamePath(const char *oldpath, const char *newpath);
# 400 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_filesystem.h"
extern bool SDL_CopyFile(const char *oldpath, const char *newpath);
# 413 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_filesystem.h"
extern bool SDL_GetPathInfo(const char *path, SDL_PathInfo *info);
# 446 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_filesystem.h"
extern char ** SDL_GlobDirectory(const char *path, const char *pattern, SDL_GlobFlags flags, int *count);



}

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_close_code.h" 1
# 453 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_filesystem.h" 2
# 45 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL.h" 2

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h" 1
# 163 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_begin_code.h" 1
# 164 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h" 2

extern "C" {
# 175 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef struct SDL_GPUDevice SDL_GPUDevice;
# 200 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef struct SDL_GPUBuffer SDL_GPUBuffer;
# 218 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef struct SDL_GPUTransferBuffer SDL_GPUTransferBuffer;
# 239 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef struct SDL_GPUTexture SDL_GPUTexture;
# 251 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef struct SDL_GPUSampler SDL_GPUSampler;
# 262 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef struct SDL_GPUShader SDL_GPUShader;
# 275 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef struct SDL_GPUComputePipeline SDL_GPUComputePipeline;
# 288 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef struct SDL_GPUGraphicsPipeline SDL_GPUGraphicsPipeline;
# 313 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef struct SDL_GPUCommandBuffer SDL_GPUCommandBuffer;
# 326 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef struct SDL_GPURenderPass SDL_GPURenderPass;
# 339 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef struct SDL_GPUComputePass SDL_GPUComputePass;
# 352 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef struct SDL_GPUCopyPass SDL_GPUCopyPass;
# 364 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef struct SDL_GPUFence SDL_GPUFence;
# 373 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef enum SDL_GPUPrimitiveType
{
    SDL_GPU_PRIMITIVETYPE_TRIANGLELIST,
    SDL_GPU_PRIMITIVETYPE_TRIANGLESTRIP,
    SDL_GPU_PRIMITIVETYPE_LINELIST,
    SDL_GPU_PRIMITIVETYPE_LINESTRIP,
    SDL_GPU_PRIMITIVETYPE_POINTLIST
} SDL_GPUPrimitiveType;
# 390 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef enum SDL_GPULoadOp
{
    SDL_GPU_LOADOP_LOAD,
    SDL_GPU_LOADOP_CLEAR,
    SDL_GPU_LOADOP_DONT_CARE
} SDL_GPULoadOp;
# 405 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef enum SDL_GPUStoreOp
{
    SDL_GPU_STOREOP_STORE,
    SDL_GPU_STOREOP_DONT_CARE,
    SDL_GPU_STOREOP_RESOLVE,
    SDL_GPU_STOREOP_RESOLVE_AND_STORE
} SDL_GPUStoreOp;
# 420 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef enum SDL_GPUIndexElementSize
{
    SDL_GPU_INDEXELEMENTSIZE_16BIT,
    SDL_GPU_INDEXELEMENTSIZE_32BIT
} SDL_GPUIndexElementSize;
# 512 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef enum SDL_GPUTextureFormat
{
    SDL_GPU_TEXTUREFORMAT_INVALID,


    SDL_GPU_TEXTUREFORMAT_A8_UNORM,
    SDL_GPU_TEXTUREFORMAT_R8_UNORM,
    SDL_GPU_TEXTUREFORMAT_R8G8_UNORM,
    SDL_GPU_TEXTUREFORMAT_R8G8B8A8_UNORM,
    SDL_GPU_TEXTUREFORMAT_R16_UNORM,
    SDL_GPU_TEXTUREFORMAT_R16G16_UNORM,
    SDL_GPU_TEXTUREFORMAT_R16G16B16A16_UNORM,
    SDL_GPU_TEXTUREFORMAT_R10G10B10A2_UNORM,
    SDL_GPU_TEXTUREFORMAT_B5G6R5_UNORM,
    SDL_GPU_TEXTUREFORMAT_B5G5R5A1_UNORM,
    SDL_GPU_TEXTUREFORMAT_B4G4R4A4_UNORM,
    SDL_GPU_TEXTUREFORMAT_B8G8R8A8_UNORM,

    SDL_GPU_TEXTUREFORMAT_BC1_RGBA_UNORM,
    SDL_GPU_TEXTUREFORMAT_BC2_RGBA_UNORM,
    SDL_GPU_TEXTUREFORMAT_BC3_RGBA_UNORM,
    SDL_GPU_TEXTUREFORMAT_BC4_R_UNORM,
    SDL_GPU_TEXTUREFORMAT_BC5_RG_UNORM,
    SDL_GPU_TEXTUREFORMAT_BC7_RGBA_UNORM,

    SDL_GPU_TEXTUREFORMAT_BC6H_RGB_FLOAT,

    SDL_GPU_TEXTUREFORMAT_BC6H_RGB_UFLOAT,

    SDL_GPU_TEXTUREFORMAT_R8_SNORM,
    SDL_GPU_TEXTUREFORMAT_R8G8_SNORM,
    SDL_GPU_TEXTUREFORMAT_R8G8B8A8_SNORM,
    SDL_GPU_TEXTUREFORMAT_R16_SNORM,
    SDL_GPU_TEXTUREFORMAT_R16G16_SNORM,
    SDL_GPU_TEXTUREFORMAT_R16G16B16A16_SNORM,

    SDL_GPU_TEXTUREFORMAT_R16_FLOAT,
    SDL_GPU_TEXTUREFORMAT_R16G16_FLOAT,
    SDL_GPU_TEXTUREFORMAT_R16G16B16A16_FLOAT,
    SDL_GPU_TEXTUREFORMAT_R32_FLOAT,
    SDL_GPU_TEXTUREFORMAT_R32G32_FLOAT,
    SDL_GPU_TEXTUREFORMAT_R32G32B32A32_FLOAT,

    SDL_GPU_TEXTUREFORMAT_R11G11B10_UFLOAT,

    SDL_GPU_TEXTUREFORMAT_R8_UINT,
    SDL_GPU_TEXTUREFORMAT_R8G8_UINT,
    SDL_GPU_TEXTUREFORMAT_R8G8B8A8_UINT,
    SDL_GPU_TEXTUREFORMAT_R16_UINT,
    SDL_GPU_TEXTUREFORMAT_R16G16_UINT,
    SDL_GPU_TEXTUREFORMAT_R16G16B16A16_UINT,
    SDL_GPU_TEXTUREFORMAT_R32_UINT,
    SDL_GPU_TEXTUREFORMAT_R32G32_UINT,
    SDL_GPU_TEXTUREFORMAT_R32G32B32A32_UINT,

    SDL_GPU_TEXTUREFORMAT_R8_INT,
    SDL_GPU_TEXTUREFORMAT_R8G8_INT,
    SDL_GPU_TEXTUREFORMAT_R8G8B8A8_INT,
    SDL_GPU_TEXTUREFORMAT_R16_INT,
    SDL_GPU_TEXTUREFORMAT_R16G16_INT,
    SDL_GPU_TEXTUREFORMAT_R16G16B16A16_INT,
    SDL_GPU_TEXTUREFORMAT_R32_INT,
    SDL_GPU_TEXTUREFORMAT_R32G32_INT,
    SDL_GPU_TEXTUREFORMAT_R32G32B32A32_INT,

    SDL_GPU_TEXTUREFORMAT_R8G8B8A8_UNORM_SRGB,
    SDL_GPU_TEXTUREFORMAT_B8G8R8A8_UNORM_SRGB,

    SDL_GPU_TEXTUREFORMAT_BC1_RGBA_UNORM_SRGB,
    SDL_GPU_TEXTUREFORMAT_BC2_RGBA_UNORM_SRGB,
    SDL_GPU_TEXTUREFORMAT_BC3_RGBA_UNORM_SRGB,
    SDL_GPU_TEXTUREFORMAT_BC7_RGBA_UNORM_SRGB,

    SDL_GPU_TEXTUREFORMAT_D16_UNORM,
    SDL_GPU_TEXTUREFORMAT_D24_UNORM,
    SDL_GPU_TEXTUREFORMAT_D32_FLOAT,
    SDL_GPU_TEXTUREFORMAT_D24_UNORM_S8_UINT,
    SDL_GPU_TEXTUREFORMAT_D32_FLOAT_S8_UINT,

    SDL_GPU_TEXTUREFORMAT_ASTC_4x4_UNORM,
    SDL_GPU_TEXTUREFORMAT_ASTC_5x4_UNORM,
    SDL_GPU_TEXTUREFORMAT_ASTC_5x5_UNORM,
    SDL_GPU_TEXTUREFORMAT_ASTC_6x5_UNORM,
    SDL_GPU_TEXTUREFORMAT_ASTC_6x6_UNORM,
    SDL_GPU_TEXTUREFORMAT_ASTC_8x5_UNORM,
    SDL_GPU_TEXTUREFORMAT_ASTC_8x6_UNORM,
    SDL_GPU_TEXTUREFORMAT_ASTC_8x8_UNORM,
    SDL_GPU_TEXTUREFORMAT_ASTC_10x5_UNORM,
    SDL_GPU_TEXTUREFORMAT_ASTC_10x6_UNORM,
    SDL_GPU_TEXTUREFORMAT_ASTC_10x8_UNORM,
    SDL_GPU_TEXTUREFORMAT_ASTC_10x10_UNORM,
    SDL_GPU_TEXTUREFORMAT_ASTC_12x10_UNORM,
    SDL_GPU_TEXTUREFORMAT_ASTC_12x12_UNORM,

    SDL_GPU_TEXTUREFORMAT_ASTC_4x4_UNORM_SRGB,
    SDL_GPU_TEXTUREFORMAT_ASTC_5x4_UNORM_SRGB,
    SDL_GPU_TEXTUREFORMAT_ASTC_5x5_UNORM_SRGB,
    SDL_GPU_TEXTUREFORMAT_ASTC_6x5_UNORM_SRGB,
    SDL_GPU_TEXTUREFORMAT_ASTC_6x6_UNORM_SRGB,
    SDL_GPU_TEXTUREFORMAT_ASTC_8x5_UNORM_SRGB,
    SDL_GPU_TEXTUREFORMAT_ASTC_8x6_UNORM_SRGB,
    SDL_GPU_TEXTUREFORMAT_ASTC_8x8_UNORM_SRGB,
    SDL_GPU_TEXTUREFORMAT_ASTC_10x5_UNORM_SRGB,
    SDL_GPU_TEXTUREFORMAT_ASTC_10x6_UNORM_SRGB,
    SDL_GPU_TEXTUREFORMAT_ASTC_10x8_UNORM_SRGB,
    SDL_GPU_TEXTUREFORMAT_ASTC_10x10_UNORM_SRGB,
    SDL_GPU_TEXTUREFORMAT_ASTC_12x10_UNORM_SRGB,
    SDL_GPU_TEXTUREFORMAT_ASTC_12x12_UNORM_SRGB,

    SDL_GPU_TEXTUREFORMAT_ASTC_4x4_FLOAT,
    SDL_GPU_TEXTUREFORMAT_ASTC_5x4_FLOAT,
    SDL_GPU_TEXTUREFORMAT_ASTC_5x5_FLOAT,
    SDL_GPU_TEXTUREFORMAT_ASTC_6x5_FLOAT,
    SDL_GPU_TEXTUREFORMAT_ASTC_6x6_FLOAT,
    SDL_GPU_TEXTUREFORMAT_ASTC_8x5_FLOAT,
    SDL_GPU_TEXTUREFORMAT_ASTC_8x6_FLOAT,
    SDL_GPU_TEXTUREFORMAT_ASTC_8x8_FLOAT,
    SDL_GPU_TEXTUREFORMAT_ASTC_10x5_FLOAT,
    SDL_GPU_TEXTUREFORMAT_ASTC_10x6_FLOAT,
    SDL_GPU_TEXTUREFORMAT_ASTC_10x8_FLOAT,
    SDL_GPU_TEXTUREFORMAT_ASTC_10x10_FLOAT,
    SDL_GPU_TEXTUREFORMAT_ASTC_12x10_FLOAT,
    SDL_GPU_TEXTUREFORMAT_ASTC_12x12_FLOAT
} SDL_GPUTextureFormat;
# 657 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef Uint32 SDL_GPUTextureUsageFlags;
# 674 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef enum SDL_GPUTextureType
{
    SDL_GPU_TEXTURETYPE_2D,
    SDL_GPU_TEXTURETYPE_2D_ARRAY,
    SDL_GPU_TEXTURETYPE_3D,
    SDL_GPU_TEXTURETYPE_CUBE,
    SDL_GPU_TEXTURETYPE_CUBE_ARRAY
} SDL_GPUTextureType;
# 694 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef enum SDL_GPUSampleCount
{
    SDL_GPU_SAMPLECOUNT_1,
    SDL_GPU_SAMPLECOUNT_2,
    SDL_GPU_SAMPLECOUNT_4,
    SDL_GPU_SAMPLECOUNT_8
} SDL_GPUSampleCount;
# 710 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef enum SDL_GPUCubeMapFace
{
    SDL_GPU_CUBEMAPFACE_POSITIVEX,
    SDL_GPU_CUBEMAPFACE_NEGATIVEX,
    SDL_GPU_CUBEMAPFACE_POSITIVEY,
    SDL_GPU_CUBEMAPFACE_NEGATIVEY,
    SDL_GPU_CUBEMAPFACE_POSITIVEZ,
    SDL_GPU_CUBEMAPFACE_NEGATIVEZ
} SDL_GPUCubeMapFace;
# 733 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef Uint32 SDL_GPUBufferUsageFlags;
# 752 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef enum SDL_GPUTransferBufferUsage
{
    SDL_GPU_TRANSFERBUFFERUSAGE_UPLOAD,
    SDL_GPU_TRANSFERBUFFERUSAGE_DOWNLOAD
} SDL_GPUTransferBufferUsage;
# 765 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef enum SDL_GPUShaderStage
{
    SDL_GPU_SHADERSTAGE_VERTEX,
    SDL_GPU_SHADERSTAGE_FRAGMENT
} SDL_GPUShaderStage;
# 780 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef Uint32 SDL_GPUShaderFormat;
# 797 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef enum SDL_GPUVertexElementFormat
{
    SDL_GPU_VERTEXELEMENTFORMAT_INVALID,


    SDL_GPU_VERTEXELEMENTFORMAT_INT,
    SDL_GPU_VERTEXELEMENTFORMAT_INT2,
    SDL_GPU_VERTEXELEMENTFORMAT_INT3,
    SDL_GPU_VERTEXELEMENTFORMAT_INT4,


    SDL_GPU_VERTEXELEMENTFORMAT_UINT,
    SDL_GPU_VERTEXELEMENTFORMAT_UINT2,
    SDL_GPU_VERTEXELEMENTFORMAT_UINT3,
    SDL_GPU_VERTEXELEMENTFORMAT_UINT4,


    SDL_GPU_VERTEXELEMENTFORMAT_FLOAT,
    SDL_GPU_VERTEXELEMENTFORMAT_FLOAT2,
    SDL_GPU_VERTEXELEMENTFORMAT_FLOAT3,
    SDL_GPU_VERTEXELEMENTFORMAT_FLOAT4,


    SDL_GPU_VERTEXELEMENTFORMAT_BYTE2,
    SDL_GPU_VERTEXELEMENTFORMAT_BYTE4,


    SDL_GPU_VERTEXELEMENTFORMAT_UBYTE2,
    SDL_GPU_VERTEXELEMENTFORMAT_UBYTE4,


    SDL_GPU_VERTEXELEMENTFORMAT_BYTE2_NORM,
    SDL_GPU_VERTEXELEMENTFORMAT_BYTE4_NORM,


    SDL_GPU_VERTEXELEMENTFORMAT_UBYTE2_NORM,
    SDL_GPU_VERTEXELEMENTFORMAT_UBYTE4_NORM,


    SDL_GPU_VERTEXELEMENTFORMAT_SHORT2,
    SDL_GPU_VERTEXELEMENTFORMAT_SHORT4,


    SDL_GPU_VERTEXELEMENTFORMAT_USHORT2,
    SDL_GPU_VERTEXELEMENTFORMAT_USHORT4,


    SDL_GPU_VERTEXELEMENTFORMAT_SHORT2_NORM,
    SDL_GPU_VERTEXELEMENTFORMAT_SHORT4_NORM,


    SDL_GPU_VERTEXELEMENTFORMAT_USHORT2_NORM,
    SDL_GPU_VERTEXELEMENTFORMAT_USHORT4_NORM,


    SDL_GPU_VERTEXELEMENTFORMAT_HALF2,
    SDL_GPU_VERTEXELEMENTFORMAT_HALF4
} SDL_GPUVertexElementFormat;
# 863 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef enum SDL_GPUVertexInputRate
{
    SDL_GPU_VERTEXINPUTRATE_VERTEX,
    SDL_GPU_VERTEXINPUTRATE_INSTANCE
} SDL_GPUVertexInputRate;
# 876 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef enum SDL_GPUFillMode
{
    SDL_GPU_FILLMODE_FILL,
    SDL_GPU_FILLMODE_LINE
} SDL_GPUFillMode;
# 889 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef enum SDL_GPUCullMode
{
    SDL_GPU_CULLMODE_NONE,
    SDL_GPU_CULLMODE_FRONT,
    SDL_GPU_CULLMODE_BACK
} SDL_GPUCullMode;
# 904 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef enum SDL_GPUFrontFace
{
    SDL_GPU_FRONTFACE_COUNTER_CLOCKWISE,
    SDL_GPU_FRONTFACE_CLOCKWISE
} SDL_GPUFrontFace;
# 917 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef enum SDL_GPUCompareOp
{
    SDL_GPU_COMPAREOP_INVALID,
    SDL_GPU_COMPAREOP_NEVER,
    SDL_GPU_COMPAREOP_LESS,
    SDL_GPU_COMPAREOP_EQUAL,
    SDL_GPU_COMPAREOP_LESS_OR_EQUAL,
    SDL_GPU_COMPAREOP_GREATER,
    SDL_GPU_COMPAREOP_NOT_EQUAL,
    SDL_GPU_COMPAREOP_GREATER_OR_EQUAL,
    SDL_GPU_COMPAREOP_ALWAYS
} SDL_GPUCompareOp;
# 938 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef enum SDL_GPUStencilOp
{
    SDL_GPU_STENCILOP_INVALID,
    SDL_GPU_STENCILOP_KEEP,
    SDL_GPU_STENCILOP_ZERO,
    SDL_GPU_STENCILOP_REPLACE,
    SDL_GPU_STENCILOP_INCREMENT_AND_CLAMP,
    SDL_GPU_STENCILOP_DECREMENT_AND_CLAMP,
    SDL_GPU_STENCILOP_INVERT,
    SDL_GPU_STENCILOP_INCREMENT_AND_WRAP,
    SDL_GPU_STENCILOP_DECREMENT_AND_WRAP
} SDL_GPUStencilOp;
# 962 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef enum SDL_GPUBlendOp
{
    SDL_GPU_BLENDOP_INVALID,
    SDL_GPU_BLENDOP_ADD,
    SDL_GPU_BLENDOP_SUBTRACT,
    SDL_GPU_BLENDOP_REVERSE_SUBTRACT,
    SDL_GPU_BLENDOP_MIN,
    SDL_GPU_BLENDOP_MAX
} SDL_GPUBlendOp;
# 983 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef enum SDL_GPUBlendFactor
{
    SDL_GPU_BLENDFACTOR_INVALID,
    SDL_GPU_BLENDFACTOR_ZERO,
    SDL_GPU_BLENDFACTOR_ONE,
    SDL_GPU_BLENDFACTOR_SRC_COLOR,
    SDL_GPU_BLENDFACTOR_ONE_MINUS_SRC_COLOR,
    SDL_GPU_BLENDFACTOR_DST_COLOR,
    SDL_GPU_BLENDFACTOR_ONE_MINUS_DST_COLOR,
    SDL_GPU_BLENDFACTOR_SRC_ALPHA,
    SDL_GPU_BLENDFACTOR_ONE_MINUS_SRC_ALPHA,
    SDL_GPU_BLENDFACTOR_DST_ALPHA,
    SDL_GPU_BLENDFACTOR_ONE_MINUS_DST_ALPHA,
    SDL_GPU_BLENDFACTOR_CONSTANT_COLOR,
    SDL_GPU_BLENDFACTOR_ONE_MINUS_CONSTANT_COLOR,
    SDL_GPU_BLENDFACTOR_SRC_ALPHA_SATURATE
} SDL_GPUBlendFactor;
# 1008 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef Uint8 SDL_GPUColorComponentFlags;
# 1022 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef enum SDL_GPUFilter
{
    SDL_GPU_FILTER_NEAREST,
    SDL_GPU_FILTER_LINEAR
} SDL_GPUFilter;
# 1035 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef enum SDL_GPUSamplerMipmapMode
{
    SDL_GPU_SAMPLERMIPMAPMODE_NEAREST,
    SDL_GPU_SAMPLERMIPMAPMODE_LINEAR
} SDL_GPUSamplerMipmapMode;
# 1049 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef enum SDL_GPUSamplerAddressMode
{
    SDL_GPU_SAMPLERADDRESSMODE_REPEAT,
    SDL_GPU_SAMPLERADDRESSMODE_MIRRORED_REPEAT,
    SDL_GPU_SAMPLERADDRESSMODE_CLAMP_TO_EDGE
} SDL_GPUSamplerAddressMode;
# 1087 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef enum SDL_GPUPresentMode
{
    SDL_GPU_PRESENTMODE_VSYNC,
    SDL_GPU_PRESENTMODE_IMMEDIATE,
    SDL_GPU_PRESENTMODE_MAILBOX
} SDL_GPUPresentMode;
# 1119 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef enum SDL_GPUSwapchainComposition
{
    SDL_GPU_SWAPCHAINCOMPOSITION_SDR,
    SDL_GPU_SWAPCHAINCOMPOSITION_SDR_LINEAR,
    SDL_GPU_SWAPCHAINCOMPOSITION_HDR_EXTENDED_LINEAR,
    SDL_GPU_SWAPCHAINCOMPOSITION_HDR10_ST2048
} SDL_GPUSwapchainComposition;
# 1136 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef struct SDL_GPUViewport
{
    float x;
    float y;
    float w;
    float h;
    float min_depth;
    float max_depth;
} SDL_GPUViewport;
# 1155 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef struct SDL_GPUTextureTransferInfo
{
    SDL_GPUTransferBuffer *transfer_buffer;
    Uint32 offset;
    Uint32 pixels_per_row;
    Uint32 rows_per_layer;
} SDL_GPUTextureTransferInfo;
# 1173 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef struct SDL_GPUTransferBufferLocation
{
    SDL_GPUTransferBuffer *transfer_buffer;
    Uint32 offset;
} SDL_GPUTransferBufferLocation;
# 1188 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef struct SDL_GPUTextureLocation
{
    SDL_GPUTexture *texture;
    Uint32 mip_level;
    Uint32 layer;
    Uint32 x;
    Uint32 y;
    Uint32 z;
} SDL_GPUTextureLocation;
# 1208 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef struct SDL_GPUTextureRegion
{
    SDL_GPUTexture *texture;
    Uint32 mip_level;
    Uint32 layer;
    Uint32 x;
    Uint32 y;
    Uint32 z;
    Uint32 w;
    Uint32 h;
    Uint32 d;
} SDL_GPUTextureRegion;
# 1228 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef struct SDL_GPUBlitRegion
{
    SDL_GPUTexture *texture;
    Uint32 mip_level;
    Uint32 layer_or_depth_plane;
    Uint32 x;
    Uint32 y;
    Uint32 w;
    Uint32 h;
} SDL_GPUBlitRegion;
# 1248 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef struct SDL_GPUBufferLocation
{
    SDL_GPUBuffer *buffer;
    Uint32 offset;
} SDL_GPUBufferLocation;
# 1264 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef struct SDL_GPUBufferRegion
{
    SDL_GPUBuffer *buffer;
    Uint32 offset;
    Uint32 size;
} SDL_GPUBufferRegion;
# 1283 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef struct SDL_GPUIndirectDrawCommand
{
    Uint32 num_vertices;
    Uint32 num_instances;
    Uint32 first_vertex;
    Uint32 first_instance;
} SDL_GPUIndirectDrawCommand;
# 1303 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef struct SDL_GPUIndexedIndirectDrawCommand
{
    Uint32 num_indices;
    Uint32 num_instances;
    Uint32 first_index;
    Sint32 vertex_offset;
    Uint32 first_instance;
} SDL_GPUIndexedIndirectDrawCommand;
# 1319 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef struct SDL_GPUIndirectDispatchCommand
{
    Uint32 groupcount_x;
    Uint32 groupcount_y;
    Uint32 groupcount_z;
} SDL_GPUIndirectDispatchCommand;
# 1335 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef struct SDL_GPUSamplerCreateInfo
{
    SDL_GPUFilter min_filter;
    SDL_GPUFilter mag_filter;
    SDL_GPUSamplerMipmapMode mipmap_mode;
    SDL_GPUSamplerAddressMode address_mode_u;
    SDL_GPUSamplerAddressMode address_mode_v;
    SDL_GPUSamplerAddressMode address_mode_w;
    float mip_lod_bias;
    float max_anisotropy;
    SDL_GPUCompareOp compare_op;
    float min_lod;
    float max_lod;
    bool enable_anisotropy;
    bool enable_compare;
    Uint8 padding1;
    Uint8 padding2;

    SDL_PropertiesID props;
} SDL_GPUSamplerCreateInfo;
# 1374 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef struct SDL_GPUVertexBufferDescription
{
    Uint32 slot;
    Uint32 pitch;
    SDL_GPUVertexInputRate input_rate;
    Uint32 instance_step_rate;
} SDL_GPUVertexBufferDescription;
# 1393 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef struct SDL_GPUVertexAttribute
{
    Uint32 location;
    Uint32 buffer_slot;
    SDL_GPUVertexElementFormat format;
    Uint32 offset;
} SDL_GPUVertexAttribute;
# 1409 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef struct SDL_GPUVertexInputState
{
    const SDL_GPUVertexBufferDescription *vertex_buffer_descriptions;
    Uint32 num_vertex_buffers;
    const SDL_GPUVertexAttribute *vertex_attributes;
    Uint32 num_vertex_attributes;
} SDL_GPUVertexInputState;
# 1424 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef struct SDL_GPUStencilOpState
{
    SDL_GPUStencilOp fail_op;
    SDL_GPUStencilOp pass_op;
    SDL_GPUStencilOp depth_fail_op;
    SDL_GPUCompareOp compare_op;
} SDL_GPUStencilOpState;
# 1439 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef struct SDL_GPUColorTargetBlendState
{
    SDL_GPUBlendFactor src_color_blendfactor;
    SDL_GPUBlendFactor dst_color_blendfactor;
    SDL_GPUBlendOp color_blend_op;
    SDL_GPUBlendFactor src_alpha_blendfactor;
    SDL_GPUBlendFactor dst_alpha_blendfactor;
    SDL_GPUBlendOp alpha_blend_op;
    SDL_GPUColorComponentFlags color_write_mask;
    bool enable_blend;
    bool enable_color_write_mask;
    Uint8 padding1;
    Uint8 padding2;
} SDL_GPUColorTargetBlendState;
# 1462 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef struct SDL_GPUShaderCreateInfo
{
    size_t code_size;
    const Uint8 *code;
    const char *entrypoint;
    SDL_GPUShaderFormat format;
    SDL_GPUShaderStage stage;
    Uint32 num_samplers;
    Uint32 num_storage_textures;
    Uint32 num_storage_buffers;
    Uint32 num_uniform_buffers;

    SDL_PropertiesID props;
} SDL_GPUShaderCreateInfo;
# 1488 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef struct SDL_GPUTextureCreateInfo
{
    SDL_GPUTextureType type;
    SDL_GPUTextureFormat format;
    SDL_GPUTextureUsageFlags usage;
    Uint32 width;
    Uint32 height;
    Uint32 layer_count_or_depth;
    Uint32 num_levels;
    SDL_GPUSampleCount sample_count;

    SDL_PropertiesID props;
} SDL_GPUTextureCreateInfo;
# 1519 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef struct SDL_GPUBufferCreateInfo
{
    SDL_GPUBufferUsageFlags usage;
    Uint32 size;

    SDL_PropertiesID props;
} SDL_GPUBufferCreateInfo;
# 1534 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef struct SDL_GPUTransferBufferCreateInfo
{
    SDL_GPUTransferBufferUsage usage;
    Uint32 size;

    SDL_PropertiesID props;
} SDL_GPUTransferBufferCreateInfo;
# 1557 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef struct SDL_GPURasterizerState
{
    SDL_GPUFillMode fill_mode;
    SDL_GPUCullMode cull_mode;
    SDL_GPUFrontFace front_face;
    float depth_bias_constant_factor;
    float depth_bias_clamp;
    float depth_bias_slope_factor;
    bool enable_depth_bias;
    bool enable_depth_clip;
    Uint8 padding1;
    Uint8 padding2;
} SDL_GPURasterizerState;
# 1579 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef struct SDL_GPUMultisampleState
{
    SDL_GPUSampleCount sample_count;
    Uint32 sample_mask;
    bool enable_mask;
    Uint8 padding1;
    Uint8 padding2;
    Uint8 padding3;
} SDL_GPUMultisampleState;
# 1597 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef struct SDL_GPUDepthStencilState
{
    SDL_GPUCompareOp compare_op;
    SDL_GPUStencilOpState back_stencil_state;
    SDL_GPUStencilOpState front_stencil_state;
    Uint8 compare_mask;
    Uint8 write_mask;
    bool enable_depth_test;
    bool enable_depth_write;
    bool enable_stencil_test;
    Uint8 padding1;
    Uint8 padding2;
    Uint8 padding3;
} SDL_GPUDepthStencilState;
# 1620 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef struct SDL_GPUColorTargetDescription
{
    SDL_GPUTextureFormat format;
    SDL_GPUColorTargetBlendState blend_state;
} SDL_GPUColorTargetDescription;
# 1634 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef struct SDL_GPUGraphicsPipelineTargetInfo
{
    const SDL_GPUColorTargetDescription *color_target_descriptions;
    Uint32 num_color_targets;
    SDL_GPUTextureFormat depth_stencil_format;
    bool has_depth_stencil_target;
    Uint8 padding1;
    Uint8 padding2;
    Uint8 padding3;
} SDL_GPUGraphicsPipelineTargetInfo;
# 1652 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef struct SDL_GPUGraphicsPipelineCreateInfo
{
    SDL_GPUShader *vertex_shader;
    SDL_GPUShader *fragment_shader;
    SDL_GPUVertexInputState vertex_input_state;
    SDL_GPUPrimitiveType primitive_type;
    SDL_GPURasterizerState rasterizer_state;
    SDL_GPUMultisampleState multisample_state;
    SDL_GPUDepthStencilState depth_stencil_state;
    SDL_GPUGraphicsPipelineTargetInfo target_info;

    SDL_PropertiesID props;
} SDL_GPUGraphicsPipelineCreateInfo;
# 1673 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef struct SDL_GPUComputePipelineCreateInfo
{
    size_t code_size;
    const Uint8 *code;
    const char *entrypoint;
    SDL_GPUShaderFormat format;
    Uint32 num_samplers;
    Uint32 num_readonly_storage_textures;
    Uint32 num_readonly_storage_buffers;
    Uint32 num_readwrite_storage_textures;
    Uint32 num_readwrite_storage_buffers;
    Uint32 num_uniform_buffers;
    Uint32 threadcount_x;
    Uint32 threadcount_y;
    Uint32 threadcount_z;

    SDL_PropertiesID props;
} SDL_GPUComputePipelineCreateInfo;
# 1727 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef struct SDL_GPUColorTargetInfo
{
    SDL_GPUTexture *texture;
    Uint32 mip_level;
    Uint32 layer_or_depth_plane;
    SDL_FColor clear_color;
    SDL_GPULoadOp load_op;
    SDL_GPUStoreOp store_op;
    SDL_GPUTexture *resolve_texture;
    Uint32 resolve_mip_level;
    Uint32 resolve_layer;
    bool cycle;
    bool cycle_resolve_texture;
    Uint8 padding1;
    Uint8 padding2;
} SDL_GPUColorTargetInfo;
# 1788 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef struct SDL_GPUDepthStencilTargetInfo
{
    SDL_GPUTexture *texture;
    float clear_depth;
    SDL_GPULoadOp load_op;
    SDL_GPUStoreOp store_op;
    SDL_GPULoadOp stencil_load_op;
    SDL_GPUStoreOp stencil_store_op;
    bool cycle;
    Uint8 clear_stencil;
    Uint8 padding1;
    Uint8 padding2;
} SDL_GPUDepthStencilTargetInfo;
# 1809 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef struct SDL_GPUBlitInfo {
    SDL_GPUBlitRegion source;
    SDL_GPUBlitRegion destination;
    SDL_GPULoadOp load_op;
    SDL_FColor clear_color;
    SDL_FlipMode flip_mode;
    SDL_GPUFilter filter;
    bool cycle;
    Uint8 padding1;
    Uint8 padding2;
    Uint8 padding3;
} SDL_GPUBlitInfo;
# 1832 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef struct SDL_GPUBufferBinding
{
    SDL_GPUBuffer *buffer;
    Uint32 offset;
} SDL_GPUBufferBinding;
# 1846 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef struct SDL_GPUTextureSamplerBinding
{
    SDL_GPUTexture *texture;
    SDL_GPUSampler *sampler;
} SDL_GPUTextureSamplerBinding;
# 1860 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef struct SDL_GPUStorageBufferReadWriteBinding
{
    SDL_GPUBuffer *buffer;
    bool cycle;
    Uint8 padding1;
    Uint8 padding2;
    Uint8 padding3;
} SDL_GPUStorageBufferReadWriteBinding;
# 1877 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
typedef struct SDL_GPUStorageTextureReadWriteBinding
{
    SDL_GPUTexture *texture;
    Uint32 mip_level;
    Uint32 layer;
    bool cycle;
    Uint8 padding1;
    Uint8 padding2;
    Uint8 padding3;
} SDL_GPUStorageTextureReadWriteBinding;
# 1905 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern bool SDL_GPUSupportsShaderFormats(
    SDL_GPUShaderFormat format_flags,
    const char *name);
# 1919 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern bool SDL_GPUSupportsProperties(
    SDL_PropertiesID props);
# 1940 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern SDL_GPUDevice * SDL_CreateGPUDevice(
    SDL_GPUShaderFormat format_flags,
    bool debug_mode,
    const char *name);
# 1988 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern SDL_GPUDevice * SDL_CreateGPUDeviceWithProperties(
    SDL_PropertiesID props);
# 2011 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern void SDL_DestroyGPUDevice(SDL_GPUDevice *device);
# 2022 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern int SDL_GetNumGPUDrivers(void);
# 2041 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern const char * SDL_GetGPUDriver(int index);
# 2051 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern const char * SDL_GetGPUDeviceDriver(SDL_GPUDevice *device);
# 2062 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern SDL_GPUShaderFormat SDL_GetGPUShaderFormats(SDL_GPUDevice *device);
# 2113 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern SDL_GPUComputePipeline * SDL_CreateGPUComputePipeline(
    SDL_GPUDevice *device,
    const SDL_GPUComputePipelineCreateInfo *createinfo);
# 2132 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern SDL_GPUGraphicsPipeline * SDL_CreateGPUGraphicsPipeline(
    SDL_GPUDevice *device,
    const SDL_GPUGraphicsPipelineCreateInfo *createinfo);
# 2151 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern SDL_GPUSampler * SDL_CreateGPUSampler(
    SDL_GPUDevice *device,
    const SDL_GPUSamplerCreateInfo *createinfo);
# 2220 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern SDL_GPUShader * SDL_CreateGPUShader(
    SDL_GPUDevice *device,
    const SDL_GPUShaderCreateInfo *createinfo);
# 2255 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern SDL_GPUTexture * SDL_CreateGPUTexture(
    SDL_GPUDevice *device,
    const SDL_GPUTextureCreateInfo *createinfo);
# 2289 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern SDL_GPUBuffer * SDL_CreateGPUBuffer(
    SDL_GPUDevice *device,
    const SDL_GPUBufferCreateInfo *createinfo);
# 2311 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern SDL_GPUTransferBuffer * SDL_CreateGPUTransferBuffer(
    SDL_GPUDevice *device,
    const SDL_GPUTransferBufferCreateInfo *createinfo);
# 2328 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern void SDL_SetGPUBufferName(
    SDL_GPUDevice *device,
    SDL_GPUBuffer *buffer,
    const char *text);
# 2344 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern void SDL_SetGPUTextureName(
    SDL_GPUDevice *device,
    SDL_GPUTexture *texture,
    const char *text);
# 2359 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern void SDL_InsertGPUDebugLabel(
    SDL_GPUCommandBuffer *command_buffer,
    const char *text);
# 2384 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern void SDL_PushGPUDebugGroup(
    SDL_GPUCommandBuffer *command_buffer,
    const char *name);
# 2397 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern void SDL_PopGPUDebugGroup(
    SDL_GPUCommandBuffer *command_buffer);
# 2412 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern void SDL_ReleaseGPUTexture(
    SDL_GPUDevice *device,
    SDL_GPUTexture *texture);
# 2426 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern void SDL_ReleaseGPUSampler(
    SDL_GPUDevice *device,
    SDL_GPUSampler *sampler);
# 2440 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern void SDL_ReleaseGPUBuffer(
    SDL_GPUDevice *device,
    SDL_GPUBuffer *buffer);
# 2454 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern void SDL_ReleaseGPUTransferBuffer(
    SDL_GPUDevice *device,
    SDL_GPUTransferBuffer *transfer_buffer);
# 2468 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern void SDL_ReleaseGPUComputePipeline(
    SDL_GPUDevice *device,
    SDL_GPUComputePipeline *compute_pipeline);
# 2482 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern void SDL_ReleaseGPUShader(
    SDL_GPUDevice *device,
    SDL_GPUShader *shader);
# 2496 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern void SDL_ReleaseGPUGraphicsPipeline(
    SDL_GPUDevice *device,
    SDL_GPUGraphicsPipeline *graphics_pipeline);
# 2517 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern SDL_GPUCommandBuffer * SDL_AcquireGPUCommandBuffer(
    SDL_GPUDevice *device);
# 2552 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern void SDL_PushGPUVertexUniformData(
    SDL_GPUCommandBuffer *command_buffer,
    Uint32 slot_index,
    const void *data,
    Uint32 length);
# 2570 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern void SDL_PushGPUFragmentUniformData(
    SDL_GPUCommandBuffer *command_buffer,
    Uint32 slot_index,
    const void *data,
    Uint32 length);
# 2588 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern void SDL_PushGPUComputeUniformData(
    SDL_GPUCommandBuffer *command_buffer,
    Uint32 slot_index,
    const void *data,
    Uint32 length);
# 2660 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern SDL_GPURenderPass * SDL_BeginGPURenderPass(
    SDL_GPUCommandBuffer *command_buffer,
    const SDL_GPUColorTargetInfo *color_target_infos,
    Uint32 num_color_targets,
    const SDL_GPUDepthStencilTargetInfo *depth_stencil_target_info);
# 2676 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern void SDL_BindGPUGraphicsPipeline(
    SDL_GPURenderPass *render_pass,
    SDL_GPUGraphicsPipeline *graphics_pipeline);
# 2688 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern void SDL_SetGPUViewport(
    SDL_GPURenderPass *render_pass,
    const SDL_GPUViewport *viewport);
# 2700 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern void SDL_SetGPUScissor(
    SDL_GPURenderPass *render_pass,
    const SDL_Rect *scissor);
# 2715 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern void SDL_SetGPUBlendConstants(
    SDL_GPURenderPass *render_pass,
    SDL_FColor blend_constants);
# 2727 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern void SDL_SetGPUStencilReference(
    SDL_GPURenderPass *render_pass,
    Uint8 reference);
# 2743 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern void SDL_BindGPUVertexBuffers(
    SDL_GPURenderPass *render_pass,
    Uint32 first_slot,
    const SDL_GPUBufferBinding *bindings,
    Uint32 num_bindings);
# 2760 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern void SDL_BindGPUIndexBuffer(
    SDL_GPURenderPass *render_pass,
    const SDL_GPUBufferBinding *binding,
    SDL_GPUIndexElementSize index_element_size);
# 2779 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern void SDL_BindGPUVertexSamplers(
    SDL_GPURenderPass *render_pass,
    Uint32 first_slot,
    const SDL_GPUTextureSamplerBinding *texture_sampler_bindings,
    Uint32 num_bindings);
# 2798 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern void SDL_BindGPUVertexStorageTextures(
    SDL_GPURenderPass *render_pass,
    Uint32 first_slot,
    SDL_GPUTexture *const *storage_textures,
    Uint32 num_bindings);
# 2817 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern void SDL_BindGPUVertexStorageBuffers(
    SDL_GPURenderPass *render_pass,
    Uint32 first_slot,
    SDL_GPUBuffer *const *storage_buffers,
    Uint32 num_bindings);
# 2837 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern void SDL_BindGPUFragmentSamplers(
    SDL_GPURenderPass *render_pass,
    Uint32 first_slot,
    const SDL_GPUTextureSamplerBinding *texture_sampler_bindings,
    Uint32 num_bindings);
# 2856 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern void SDL_BindGPUFragmentStorageTextures(
    SDL_GPURenderPass *render_pass,
    Uint32 first_slot,
    SDL_GPUTexture *const *storage_textures,
    Uint32 num_bindings);
# 2875 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern void SDL_BindGPUFragmentStorageBuffers(
    SDL_GPURenderPass *render_pass,
    Uint32 first_slot,
    SDL_GPUBuffer *const *storage_buffers,
    Uint32 num_bindings);
# 2904 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern void SDL_DrawGPUIndexedPrimitives(
    SDL_GPURenderPass *render_pass,
    Uint32 num_indices,
    Uint32 num_instances,
    Uint32 first_index,
    Sint32 vertex_offset,
    Uint32 first_instance);
# 2930 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern void SDL_DrawGPUPrimitives(
    SDL_GPURenderPass *render_pass,
    Uint32 num_vertices,
    Uint32 num_instances,
    Uint32 first_vertex,
    Uint32 first_instance);
# 2953 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern void SDL_DrawGPUPrimitivesIndirect(
    SDL_GPURenderPass *render_pass,
    SDL_GPUBuffer *buffer,
    Uint32 offset,
    Uint32 draw_count);
# 2975 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern void SDL_DrawGPUIndexedPrimitivesIndirect(
    SDL_GPURenderPass *render_pass,
    SDL_GPUBuffer *buffer,
    Uint32 offset,
    Uint32 draw_count);
# 2991 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern void SDL_EndGPURenderPass(
    SDL_GPURenderPass *render_pass);
# 3033 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern SDL_GPUComputePass * SDL_BeginGPUComputePass(
    SDL_GPUCommandBuffer *command_buffer,
    const SDL_GPUStorageTextureReadWriteBinding *storage_texture_bindings,
    Uint32 num_storage_texture_bindings,
    const SDL_GPUStorageBufferReadWriteBinding *storage_buffer_bindings,
    Uint32 num_storage_buffer_bindings);
# 3048 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern void SDL_BindGPUComputePipeline(
    SDL_GPUComputePass *compute_pass,
    SDL_GPUComputePipeline *compute_pipeline);
# 3066 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern void SDL_BindGPUComputeSamplers(
    SDL_GPUComputePass *compute_pass,
    Uint32 first_slot,
    const SDL_GPUTextureSamplerBinding *texture_sampler_bindings,
    Uint32 num_bindings);
# 3085 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern void SDL_BindGPUComputeStorageTextures(
    SDL_GPUComputePass *compute_pass,
    Uint32 first_slot,
    SDL_GPUTexture *const *storage_textures,
    Uint32 num_bindings);
# 3104 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern void SDL_BindGPUComputeStorageBuffers(
    SDL_GPUComputePass *compute_pass,
    Uint32 first_slot,
    SDL_GPUBuffer *const *storage_buffers,
    Uint32 num_bindings);
# 3130 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern void SDL_DispatchGPUCompute(
    SDL_GPUComputePass *compute_pass,
    Uint32 groupcount_x,
    Uint32 groupcount_y,
    Uint32 groupcount_z);
# 3154 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern void SDL_DispatchGPUComputeIndirect(
    SDL_GPUComputePass *compute_pass,
    SDL_GPUBuffer *buffer,
    Uint32 offset);
# 3169 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern void SDL_EndGPUComputePass(
    SDL_GPUComputePass *compute_pass);
# 3187 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern void * SDL_MapGPUTransferBuffer(
    SDL_GPUDevice *device,
    SDL_GPUTransferBuffer *transfer_buffer,
    bool cycle);
# 3200 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern void SDL_UnmapGPUTransferBuffer(
    SDL_GPUDevice *device,
    SDL_GPUTransferBuffer *transfer_buffer);
# 3218 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern SDL_GPUCopyPass * SDL_BeginGPUCopyPass(
    SDL_GPUCommandBuffer *command_buffer);
# 3238 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern void SDL_UploadToGPUTexture(
    SDL_GPUCopyPass *copy_pass,
    const SDL_GPUTextureTransferInfo *source,
    const SDL_GPUTextureRegion *destination,
    bool cycle);
# 3260 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern void SDL_UploadToGPUBuffer(
    SDL_GPUCopyPass *copy_pass,
    const SDL_GPUTransferBufferLocation *source,
    const SDL_GPUBufferRegion *destination,
    bool cycle);
# 3283 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern void SDL_CopyGPUTextureToTexture(
    SDL_GPUCopyPass *copy_pass,
    const SDL_GPUTextureLocation *source,
    const SDL_GPUTextureLocation *destination,
    Uint32 w,
    Uint32 h,
    Uint32 d,
    bool cycle);
# 3309 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern void SDL_CopyGPUBufferToBuffer(
    SDL_GPUCopyPass *copy_pass,
    const SDL_GPUBufferLocation *source,
    const SDL_GPUBufferLocation *destination,
    Uint32 size,
    bool cycle);
# 3329 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern void SDL_DownloadFromGPUTexture(
    SDL_GPUCopyPass *copy_pass,
    const SDL_GPUTextureRegion *source,
    const SDL_GPUTextureTransferInfo *destination);
# 3346 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern void SDL_DownloadFromGPUBuffer(
    SDL_GPUCopyPass *copy_pass,
    const SDL_GPUBufferRegion *source,
    const SDL_GPUTransferBufferLocation *destination);
# 3358 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern void SDL_EndGPUCopyPass(
    SDL_GPUCopyPass *copy_pass);
# 3371 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern void SDL_GenerateMipmapsForGPUTexture(
    SDL_GPUCommandBuffer *command_buffer,
    SDL_GPUTexture *texture);
# 3385 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern void SDL_BlitGPUTexture(
    SDL_GPUCommandBuffer *command_buffer,
    const SDL_GPUBlitInfo *info);
# 3405 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern bool SDL_WindowSupportsGPUSwapchainComposition(
    SDL_GPUDevice *device,
    SDL_Window *window,
    SDL_GPUSwapchainComposition swapchain_composition);
# 3424 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern bool SDL_WindowSupportsGPUPresentMode(
    SDL_GPUDevice *device,
    SDL_Window *window,
    SDL_GPUPresentMode present_mode);
# 3453 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern bool SDL_ClaimWindowForGPUDevice(
    SDL_GPUDevice *device,
    SDL_Window *window);
# 3467 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern void SDL_ReleaseWindowFromGPUDevice(
    SDL_GPUDevice *device,
    SDL_Window *window);
# 3494 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern bool SDL_SetGPUSwapchainParameters(
    SDL_GPUDevice *device,
    SDL_Window *window,
    SDL_GPUSwapchainComposition swapchain_composition,
    SDL_GPUPresentMode present_mode);
# 3511 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern SDL_GPUTextureFormat SDL_GetGPUSwapchainTextureFormat(
    SDL_GPUDevice *device,
    SDL_Window *window);
# 3547 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern bool SDL_AcquireGPUSwapchainTexture(
    SDL_GPUCommandBuffer *command_buffer,
    SDL_Window *window,
    SDL_GPUTexture **swapchain_texture,
    Uint32 *swapchain_texture_width,
    Uint32 *swapchain_texture_height);
# 3574 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern bool SDL_SubmitGPUCommandBuffer(
    SDL_GPUCommandBuffer *command_buffer);
# 3600 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern SDL_GPUFence * SDL_SubmitGPUCommandBufferAndAcquireFence(
    SDL_GPUCommandBuffer *command_buffer);
# 3614 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern bool SDL_WaitForGPUIdle(
    SDL_GPUDevice *device);
# 3633 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern bool SDL_WaitForGPUFences(
    SDL_GPUDevice *device,
    bool wait_all,
    SDL_GPUFence *const *fences,
    Uint32 num_fences);
# 3650 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern bool SDL_QueryGPUFence(
    SDL_GPUDevice *device,
    SDL_GPUFence *fence);
# 3664 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern void SDL_ReleaseGPUFence(
    SDL_GPUDevice *device,
    SDL_GPUFence *fence);
# 3680 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern Uint32 SDL_GPUTextureFormatTexelBlockSize(
    SDL_GPUTextureFormat format);
# 3695 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern bool SDL_GPUTextureSupportsFormat(
    SDL_GPUDevice *device,
    SDL_GPUTextureFormat format,
    SDL_GPUTextureType type,
    SDL_GPUTextureUsageFlags usage);
# 3711 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern bool SDL_GPUTextureSupportsSampleCount(
    SDL_GPUDevice *device,
    SDL_GPUTextureFormat format,
    SDL_GPUSampleCount sample_count);
# 3727 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
extern Uint32 SDL_CalculateGPUTextureFormatSize(
    SDL_GPUTextureFormat format,
    Uint32 width,
    Uint32 height,
    Uint32 depth_or_layer_count);
# 3768 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h"
}

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_close_code.h" 1
# 3771 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_gpu.h" 2
# 47 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL.h" 2

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_haptic.h" 1
# 124 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_haptic.h"
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_begin_code.h" 1
# 125 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_haptic.h" 2


extern "C" {
# 150 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_haptic.h"
typedef struct SDL_Haptic SDL_Haptic;
# 534 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_haptic.h"
typedef struct SDL_HapticDirection
{
    Uint8 type;
    Sint32 dir[3];
} SDL_HapticDirection;
# 554 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_haptic.h"
typedef struct SDL_HapticConstant
{

    Uint16 type;
    SDL_HapticDirection direction;


    Uint32 length;
    Uint16 delay;


    Uint16 button;
    Uint16 interval;


    Sint16 level;


    Uint16 attack_length;
    Uint16 attack_level;
    Uint16 fade_length;
    Uint16 fade_level;
} SDL_HapticConstant;
# 640 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_haptic.h"
typedef struct SDL_HapticPeriodic
{

    Uint16 type;


    SDL_HapticDirection direction;


    Uint32 length;
    Uint16 delay;


    Uint16 button;
    Uint16 interval;


    Uint16 period;
    Sint16 magnitude;
    Sint16 offset;
    Uint16 phase;


    Uint16 attack_length;
    Uint16 attack_level;
    Uint16 fade_length;
    Uint16 fade_level;
} SDL_HapticPeriodic;
# 696 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_haptic.h"
typedef struct SDL_HapticCondition
{

    Uint16 type;

    SDL_HapticDirection direction;


    Uint32 length;
    Uint16 delay;


    Uint16 button;
    Uint16 interval;


    Uint16 right_sat[3];
    Uint16 left_sat[3];
    Sint16 right_coeff[3];
    Sint16 left_coeff[3];
    Uint16 deadband[3];
    Sint16 center[3];
} SDL_HapticCondition;
# 735 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_haptic.h"
typedef struct SDL_HapticRamp
{

    Uint16 type;
    SDL_HapticDirection direction;


    Uint32 length;
    Uint16 delay;


    Uint16 button;
    Uint16 interval;


    Sint16 start;
    Sint16 end;


    Uint16 attack_length;
    Uint16 attack_level;
    Uint16 fade_length;
    Uint16 fade_level;
} SDL_HapticRamp;
# 774 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_haptic.h"
typedef struct SDL_HapticLeftRight
{

    Uint16 type;


    Uint32 length;


    Uint16 large_magnitude;
    Uint16 small_magnitude;
} SDL_HapticLeftRight;
# 804 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_haptic.h"
typedef struct SDL_HapticCustom
{

    Uint16 type;
    SDL_HapticDirection direction;


    Uint32 length;
    Uint16 delay;


    Uint16 button;
    Uint16 interval;


    Uint8 channels;
    Uint16 period;
    Uint16 samples;
    Uint16 *data;


    Uint16 attack_length;
    Uint16 attack_level;
    Uint16 fade_length;
    Uint16 fade_level;
} SDL_HapticCustom;
# 903 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_haptic.h"
typedef union SDL_HapticEffect
{

    Uint16 type;
    SDL_HapticConstant constant;
    SDL_HapticPeriodic periodic;
    SDL_HapticCondition condition;
    SDL_HapticRamp ramp;
    SDL_HapticLeftRight leftright;
    SDL_HapticCustom custom;
} SDL_HapticEffect;
# 925 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_haptic.h"
typedef Uint32 SDL_HapticID;
# 943 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_haptic.h"
extern SDL_HapticID * SDL_GetHaptics(int *count);
# 960 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_haptic.h"
extern const char * SDL_GetHapticNameForID(SDL_HapticID instance_id);
# 985 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_haptic.h"
extern SDL_Haptic * SDL_OpenHaptic(SDL_HapticID instance_id);
# 997 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_haptic.h"
extern SDL_Haptic * SDL_GetHapticFromID(SDL_HapticID instance_id);
# 1008 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_haptic.h"
extern SDL_HapticID SDL_GetHapticID(SDL_Haptic *haptic);
# 1022 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_haptic.h"
extern const char * SDL_GetHapticName(SDL_Haptic *haptic);
# 1033 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_haptic.h"
extern bool SDL_IsMouseHaptic(void);
# 1046 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_haptic.h"
extern SDL_Haptic * SDL_OpenHapticFromMouse(void);
# 1058 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_haptic.h"
extern bool SDL_IsJoystickHaptic(SDL_Joystick *joystick);
# 1080 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_haptic.h"
extern SDL_Haptic * SDL_OpenHapticFromJoystick(SDL_Joystick *joystick);
# 1091 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_haptic.h"
extern void SDL_CloseHaptic(SDL_Haptic *haptic);
# 1109 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_haptic.h"
extern int SDL_GetMaxHapticEffects(SDL_Haptic *haptic);
# 1125 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_haptic.h"
extern int SDL_GetMaxHapticEffectsPlaying(SDL_Haptic *haptic);
# 1139 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_haptic.h"
extern Uint32 SDL_GetHapticFeatures(SDL_Haptic *haptic);
# 1153 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_haptic.h"
extern int SDL_GetNumHapticAxes(SDL_Haptic *haptic);
# 1167 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_haptic.h"
extern bool SDL_HapticEffectSupported(SDL_Haptic *haptic, const SDL_HapticEffect *effect);
# 1184 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_haptic.h"
extern int SDL_CreateHapticEffect(SDL_Haptic *haptic, const SDL_HapticEffect *effect);
# 1206 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_haptic.h"
extern bool SDL_UpdateHapticEffect(SDL_Haptic *haptic, int effect, const SDL_HapticEffect *data);
# 1230 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_haptic.h"
extern bool SDL_RunHapticEffect(SDL_Haptic *haptic, int effect, Uint32 iterations);
# 1245 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_haptic.h"
extern bool SDL_StopHapticEffect(SDL_Haptic *haptic, int effect);
# 1260 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_haptic.h"
extern void SDL_DestroyHapticEffect(SDL_Haptic *haptic, int effect);
# 1276 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_haptic.h"
extern bool SDL_GetHapticEffectStatus(SDL_Haptic *haptic, int effect);
# 1298 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_haptic.h"
extern bool SDL_SetHapticGain(SDL_Haptic *haptic, int gain);
# 1317 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_haptic.h"
extern bool SDL_SetHapticAutocenter(SDL_Haptic *haptic, int autocenter);
# 1336 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_haptic.h"
extern bool SDL_PauseHaptic(SDL_Haptic *haptic);
# 1351 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_haptic.h"
extern bool SDL_ResumeHaptic(SDL_Haptic *haptic);
# 1365 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_haptic.h"
extern bool SDL_StopHapticEffects(SDL_Haptic *haptic);
# 1377 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_haptic.h"
extern bool SDL_HapticRumbleSupported(SDL_Haptic *haptic);
# 1392 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_haptic.h"
extern bool SDL_InitHapticRumble(SDL_Haptic *haptic);
# 1408 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_haptic.h"
extern bool SDL_PlayHapticRumble(SDL_Haptic *haptic, float strength, Uint32 length);
# 1421 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_haptic.h"
extern bool SDL_StopHapticRumble(SDL_Haptic *haptic);



}

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_close_code.h" 1
# 1428 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_haptic.h" 2
# 49 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL.h" 2
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_hidapi.h" 1
# 59 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_hidapi.h"
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_begin_code.h" 1
# 60 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_hidapi.h" 2


extern "C" {







typedef struct SDL_hid_device SDL_hid_device;






typedef enum SDL_hid_bus_type {

    SDL_HID_API_BUS_UNKNOWN = 0x00,




    SDL_HID_API_BUS_USB = 0x01,






    SDL_HID_API_BUS_BLUETOOTH = 0x02,




    SDL_HID_API_BUS_I2C = 0x03,




    SDL_HID_API_BUS_SPI = 0x04

} SDL_hid_bus_type;
# 112 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_hidapi.h"
typedef struct SDL_hid_device_info
{

    char *path;

    unsigned short vendor_id;

    unsigned short product_id;

    wchar_t *serial_number;


    unsigned short release_number;

    wchar_t *manufacturer_string;

    wchar_t *product_string;


    unsigned short usage_page;


    unsigned short usage;






    int interface_number;



    int interface_class;
    int interface_subclass;
    int interface_protocol;


    SDL_hid_bus_type bus_type;


    struct SDL_hid_device_info *next;

} SDL_hid_device_info;
# 176 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_hidapi.h"
extern int SDL_hid_init(void);
# 191 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_hidapi.h"
extern int SDL_hid_exit(void);
# 212 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_hidapi.h"
extern Uint32 SDL_hid_device_change_count(void);
# 240 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_hidapi.h"
extern SDL_hid_device_info * SDL_hid_enumerate(unsigned short vendor_id, unsigned short product_id);
# 252 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_hidapi.h"
extern void SDL_hid_free_enumeration(SDL_hid_device_info *devs);
# 270 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_hidapi.h"
extern SDL_hid_device * SDL_hid_open(unsigned short vendor_id, unsigned short product_id, const wchar_t *serial_number);
# 284 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_hidapi.h"
extern SDL_hid_device * SDL_hid_open_path(const char *path);
# 311 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_hidapi.h"
extern int SDL_hid_write(SDL_hid_device *dev, const unsigned char *data, size_t length);
# 332 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_hidapi.h"
extern int SDL_hid_read_timeout(SDL_hid_device *dev, unsigned char *data, size_t length, int milliseconds);
# 353 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_hidapi.h"
extern int SDL_hid_read(SDL_hid_device *dev, unsigned char *data, size_t length);
# 372 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_hidapi.h"
extern int SDL_hid_set_nonblocking(SDL_hid_device *dev, int nonblock);
# 397 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_hidapi.h"
extern int SDL_hid_send_feature_report(SDL_hid_device *dev, const unsigned char *data, size_t length);
# 420 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_hidapi.h"
extern int SDL_hid_get_feature_report(SDL_hid_device *dev, unsigned char *data, size_t length);
# 443 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_hidapi.h"
extern int SDL_hid_get_input_report(SDL_hid_device *dev, unsigned char *data, size_t length);
# 454 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_hidapi.h"
extern int SDL_hid_close(SDL_hid_device *dev);
# 467 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_hidapi.h"
extern int SDL_hid_get_manufacturer_string(SDL_hid_device *dev, wchar_t *string, size_t maxlen);
# 480 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_hidapi.h"
extern int SDL_hid_get_product_string(SDL_hid_device *dev, wchar_t *string, size_t maxlen);
# 493 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_hidapi.h"
extern int SDL_hid_get_serial_number_string(SDL_hid_device *dev, wchar_t *string, size_t maxlen);
# 507 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_hidapi.h"
extern int SDL_hid_get_indexed_string(SDL_hid_device *dev, int string_index, wchar_t *string, size_t maxlen);
# 519 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_hidapi.h"
extern SDL_hid_device_info * SDL_hid_get_device_info(SDL_hid_device *dev);
# 535 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_hidapi.h"
extern int SDL_hid_get_report_descriptor(SDL_hid_device *dev, unsigned char *buf, size_t buf_size);
# 544 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_hidapi.h"
extern void SDL_hid_ble_scan(bool active);



}

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_close_code.h" 1
# 551 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_hidapi.h" 2
# 50 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL.h" 2
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_hints.h" 1
# 43 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_hints.h"
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_begin_code.h" 1
# 44 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_hints.h" 2


extern "C" {
# 4061 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_hints.h"
typedef enum SDL_HintPriority
{
    SDL_HINT_DEFAULT,
    SDL_HINT_NORMAL,
    SDL_HINT_OVERRIDE
} SDL_HintPriority;
# 4089 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_hints.h"
extern bool SDL_SetHintWithPriority(const char *name, const char *value, SDL_HintPriority priority);
# 4111 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_hints.h"
extern bool SDL_SetHint(const char *name, const char *value);
# 4131 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_hints.h"
extern bool SDL_ResetHint(const char *name);
# 4146 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_hints.h"
extern void SDL_ResetHints(void);
# 4166 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_hints.h"
extern const char * SDL_GetHint(const char *name);
# 4183 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_hints.h"
extern bool SDL_GetHintBoolean(const char *name, bool default_value);
# 4204 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_hints.h"
typedef void( *SDL_HintCallback)(void *userdata, const char *name, const char *oldValue, const char *newValue);
# 4225 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_hints.h"
extern bool SDL_AddHintCallback(const char *name, SDL_HintCallback callback, void *userdata);
# 4241 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_hints.h"
extern void SDL_RemoveHintCallback(const char *name,
                                                     SDL_HintCallback callback,
                                                     void *userdata);



}

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_close_code.h" 1
# 4250 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_hints.h" 2
# 51 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL.h" 2
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_init.h" 1
# 56 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_init.h"
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_begin_code.h" 1
# 57 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_init.h" 2


extern "C" {
# 78 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_init.h"
typedef Uint32 SDL_InitFlags;
# 109 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_init.h"
typedef enum SDL_AppResult
{
    SDL_APP_CONTINUE,
    SDL_APP_SUCCESS,
    SDL_APP_FAILURE
} SDL_AppResult;

typedef SDL_AppResult ( *SDL_AppInit_func)(void **appstate, int argc, char *argv[]);
typedef SDL_AppResult ( *SDL_AppIterate_func)(void *appstate);
typedef SDL_AppResult ( *SDL_AppEvent_func)(void *appstate, SDL_Event *event);
typedef void ( *SDL_AppQuit_func)(void *appstate, SDL_AppResult result);
# 176 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_init.h"
extern bool SDL_Init(SDL_InitFlags flags);
# 193 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_init.h"
extern bool SDL_InitSubSystem(SDL_InitFlags flags);
# 208 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_init.h"
extern void SDL_QuitSubSystem(SDL_InitFlags flags);
# 222 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_init.h"
extern SDL_InitFlags SDL_WasInit(SDL_InitFlags flags);
# 240 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_init.h"
extern void SDL_Quit(void);
# 278 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_init.h"
extern bool SDL_SetAppMetadata(const char *appname, const char *appversion, const char *appidentifier);
# 341 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_init.h"
extern bool SDL_SetAppMetadataProperty(const char *name, const char *value);
# 372 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_init.h"
extern const char * SDL_GetAppMetadataProperty(const char *name);



}

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_close_code.h" 1
# 379 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_init.h" 2
# 52 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL.h" 2




# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_loadso.h" 1
# 57 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_loadso.h"
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_begin_code.h" 1
# 58 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_loadso.h" 2


extern "C" {
# 72 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_loadso.h"
typedef struct SDL_SharedObject SDL_SharedObject;
# 88 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_loadso.h"
extern SDL_SharedObject * SDL_LoadObject(const char *sofile);
# 116 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_loadso.h"
extern SDL_FunctionPointer SDL_LoadFunction(SDL_SharedObject *handle, const char *name);
# 132 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_loadso.h"
extern void SDL_UnloadObject(SDL_SharedObject *handle);



}

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_close_code.h" 1
# 139 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_loadso.h" 2
# 57 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL.h" 2
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_locale.h" 1
# 34 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_locale.h"
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_begin_code.h" 1
# 35 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_locale.h" 2



extern "C" {
# 54 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_locale.h"
typedef struct SDL_Locale
{
    const char *language;
    const char *country;
} SDL_Locale;
# 101 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_locale.h"
extern SDL_Locale ** SDL_GetPreferredLocales(int *count);




}


# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_close_code.h" 1
# 110 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_locale.h" 2
# 58 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL.h" 2
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_log.h" 1
# 66 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_log.h"
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_begin_code.h" 1
# 67 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_log.h" 2


extern "C" {
# 81 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_log.h"
typedef enum SDL_LogCategory
{
    SDL_LOG_CATEGORY_APPLICATION,
    SDL_LOG_CATEGORY_ERROR,
    SDL_LOG_CATEGORY_ASSERT,
    SDL_LOG_CATEGORY_SYSTEM,
    SDL_LOG_CATEGORY_AUDIO,
    SDL_LOG_CATEGORY_VIDEO,
    SDL_LOG_CATEGORY_RENDER,
    SDL_LOG_CATEGORY_INPUT,
    SDL_LOG_CATEGORY_TEST,
    SDL_LOG_CATEGORY_GPU,


    SDL_LOG_CATEGORY_RESERVED2,
    SDL_LOG_CATEGORY_RESERVED3,
    SDL_LOG_CATEGORY_RESERVED4,
    SDL_LOG_CATEGORY_RESERVED5,
    SDL_LOG_CATEGORY_RESERVED6,
    SDL_LOG_CATEGORY_RESERVED7,
    SDL_LOG_CATEGORY_RESERVED8,
    SDL_LOG_CATEGORY_RESERVED9,
    SDL_LOG_CATEGORY_RESERVED10,
# 113 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_log.h"
    SDL_LOG_CATEGORY_CUSTOM
} SDL_LogCategory;






typedef enum SDL_LogPriority
{
    SDL_LOG_PRIORITY_INVALID,
    SDL_LOG_PRIORITY_TRACE,
    SDL_LOG_PRIORITY_VERBOSE,
    SDL_LOG_PRIORITY_DEBUG,
    SDL_LOG_PRIORITY_INFO,
    SDL_LOG_PRIORITY_WARN,
    SDL_LOG_PRIORITY_ERROR,
    SDL_LOG_PRIORITY_CRITICAL,
    SDL_LOG_PRIORITY_COUNT
} SDL_LogPriority;
# 147 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_log.h"
extern void SDL_SetLogPriorities(SDL_LogPriority priority);
# 163 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_log.h"
extern void SDL_SetLogPriority(int category, SDL_LogPriority priority);
# 177 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_log.h"
extern SDL_LogPriority SDL_GetLogPriority(int category);
# 191 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_log.h"
extern void SDL_ResetLogPriorities(void);
# 213 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_log.h"
extern bool SDL_SetLogPriorityPrefix(SDL_LogPriority priority, const char *prefix);
# 236 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_log.h"
extern void SDL_Log( const char *fmt, ...) __attribute__ (( format( __printf__, 1, 1 +1 )));
# 261 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_log.h"
extern void SDL_LogTrace(int category, const char *fmt, ...) __attribute__ (( format( __printf__, 2, 2 +1 )));
# 284 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_log.h"
extern void SDL_LogVerbose(int category, const char *fmt, ...) __attribute__ (( format( __printf__, 2, 2 +1 )));
# 308 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_log.h"
extern void SDL_LogDebug(int category, const char *fmt, ...) __attribute__ (( format( __printf__, 2, 2 +1 )));
# 332 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_log.h"
extern void SDL_LogInfo(int category, const char *fmt, ...) __attribute__ (( format( __printf__, 2, 2 +1 )));
# 356 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_log.h"
extern void SDL_LogWarn(int category, const char *fmt, ...) __attribute__ (( format( __printf__, 2, 2 +1 )));
# 380 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_log.h"
extern void SDL_LogError(int category, const char *fmt, ...) __attribute__ (( format( __printf__, 2, 2 +1 )));
# 404 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_log.h"
extern void SDL_LogCritical(int category, const char *fmt, ...) __attribute__ (( format( __printf__, 2, 2 +1 )));
# 429 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_log.h"
extern void SDL_LogMessage(int category,
                                            SDL_LogPriority priority,
                                            const char *fmt, ...) __attribute__ (( format( __printf__, 3, 3 +1 )));
# 455 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_log.h"
extern void SDL_LogMessageV(int category,
                                             SDL_LogPriority priority,
                                             const char *fmt, va_list ap) __attribute__(( format( __printf__, 3, 0 )));
# 474 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_log.h"
typedef void ( *SDL_LogOutputFunction)(void *userdata, int category, SDL_LogPriority priority, const char *message);
# 488 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_log.h"
extern SDL_LogOutputFunction SDL_GetDefaultLogOutputFunction(void);
# 505 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_log.h"
extern void SDL_GetLogOutputFunction(SDL_LogOutputFunction *callback, void **userdata);
# 520 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_log.h"
extern void SDL_SetLogOutputFunction(SDL_LogOutputFunction callback, void *userdata);




}

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_close_code.h" 1
# 528 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_log.h" 2
# 59 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL.h" 2
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_messagebox.h" 1
# 35 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_messagebox.h"
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_begin_code.h" 1
# 36 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_messagebox.h" 2


extern "C" {
# 48 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_messagebox.h"
typedef Uint32 SDL_MessageBoxFlags;
# 61 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_messagebox.h"
typedef Uint32 SDL_MessageBoxButtonFlags;
# 71 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_messagebox.h"
typedef struct SDL_MessageBoxButtonData
{
    SDL_MessageBoxButtonFlags flags;
    int buttonID;
    const char *text;
} SDL_MessageBoxButtonData;






typedef struct SDL_MessageBoxColor
{
    Uint8 r, g, b;
} SDL_MessageBoxColor;





typedef enum SDL_MessageBoxColorType
{
    SDL_MESSAGEBOX_COLOR_BACKGROUND,
    SDL_MESSAGEBOX_COLOR_TEXT,
    SDL_MESSAGEBOX_COLOR_BUTTON_BORDER,
    SDL_MESSAGEBOX_COLOR_BUTTON_BACKGROUND,
    SDL_MESSAGEBOX_COLOR_BUTTON_SELECTED,
    SDL_MESSAGEBOX_COLOR_COUNT
} SDL_MessageBoxColorType;






typedef struct SDL_MessageBoxColorScheme
{
    SDL_MessageBoxColor colors[SDL_MESSAGEBOX_COLOR_COUNT];
} SDL_MessageBoxColorScheme;






typedef struct SDL_MessageBoxData
{
    SDL_MessageBoxFlags flags;
    SDL_Window *window;
    const char *title;
    const char *message;

    int numbuttons;
    const SDL_MessageBoxButtonData *buttons;

    const SDL_MessageBoxColorScheme *colorScheme;
} SDL_MessageBoxData;
# 164 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_messagebox.h"
extern bool SDL_ShowMessageBox(const SDL_MessageBoxData *messageboxdata, int *buttonid);
# 206 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_messagebox.h"
extern bool SDL_ShowSimpleMessageBox(SDL_MessageBoxFlags flags, const char *title, const char *message, SDL_Window *window);




}

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_close_code.h" 1
# 214 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_messagebox.h" 2
# 60 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL.h" 2
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_metal.h" 1
# 33 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_metal.h"
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_begin_code.h" 1
# 34 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_metal.h" 2


extern "C" {







typedef void *SDL_MetalView;
# 69 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_metal.h"
extern SDL_MetalView SDL_Metal_CreateView(SDL_Window *window);
# 83 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_metal.h"
extern void SDL_Metal_DestroyView(SDL_MetalView view);
# 93 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_metal.h"
extern void * SDL_Metal_GetLayer(SDL_MetalView view);





}

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_close_code.h" 1
# 102 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_metal.h" 2
# 61 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL.h" 2
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_misc.h" 1
# 34 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_misc.h"
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_begin_code.h" 1
# 35 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_misc.h" 2



extern "C" {
# 70 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_misc.h"
extern bool SDL_OpenURL(const char *url);



}

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_close_code.h" 1
# 77 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_misc.h" 2
# 62 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL.h" 2




# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_platform.h" 1
# 34 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_platform.h"
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_begin_code.h" 1
# 35 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_platform.h" 2


extern "C" {
# 56 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_platform.h"
extern const char * SDL_GetPlatform(void);



}

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_close_code.h" 1
# 63 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_platform.h" 2
# 67 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL.h" 2

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_process.h" 1
# 51 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_process.h"
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_begin_code.h" 1
# 52 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_process.h" 2


extern "C" {


typedef struct SDL_Process SDL_Process;
# 99 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_process.h"
extern SDL_Process * SDL_CreateProcess(const char * const *args, bool pipe_stdio);
# 143 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_process.h"
typedef enum SDL_ProcessIO
{
    SDL_PROCESS_STDIO_INHERITED,
    SDL_PROCESS_STDIO_NULL,
    SDL_PROCESS_STDIO_APP,
    SDL_PROCESS_STDIO_REDIRECT
} SDL_ProcessIO;
# 211 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_process.h"
extern SDL_Process * SDL_CreateProcessWithProperties(SDL_PropertiesID props);
# 253 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_process.h"
extern SDL_PropertiesID SDL_GetProcessProperties(SDL_Process *process);
# 290 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_process.h"
extern void * SDL_ReadProcess(SDL_Process *process, size_t *datasize, int *exitcode);
# 316 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_process.h"
extern SDL_IOStream * SDL_GetProcessInput(SDL_Process *process);
# 340 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_process.h"
extern SDL_IOStream * SDL_GetProcessOutput(SDL_Process *process);
# 363 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_process.h"
extern bool SDL_KillProcess(SDL_Process *process, bool force);
# 390 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_process.h"
extern bool SDL_WaitProcess(SDL_Process *process, bool block, int *exitcode);
# 409 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_process.h"
extern void SDL_DestroyProcess(SDL_Process *process);



}

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_close_code.h" 1
# 416 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_process.h" 2
# 69 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL.h" 2





# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_storage.h" 1
# 36 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_storage.h"
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_begin_code.h" 1
# 37 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_storage.h" 2



extern "C" {
# 61 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_storage.h"
typedef struct SDL_StorageInterface
{

    Uint32 version;


    bool ( *close)(void *userdata);


    bool ( *ready)(void *userdata);


    bool ( *enumerate)(void *userdata, const char *path, SDL_EnumerateDirectoryCallback callback, void *callback_userdata);


    bool ( *info)(void *userdata, const char *path, SDL_PathInfo *info);


    bool ( *read_file)(void *userdata, const char *path, void *destination, Uint64 length);


    bool ( *write_file)(void *userdata, const char *path, const void *source, Uint64 length);


    bool ( *mkdir)(void *userdata, const char *path);


    bool ( *remove)(void *userdata, const char *path);


    bool ( *rename)(void *userdata, const char *oldpath, const char *newpath);


    bool ( *copy)(void *userdata, const char *oldpath, const char *newpath);


    Uint64 ( *space_remaining)(void *userdata);
} SDL_StorageInterface;







static_assert((sizeof(void *) == 4 && sizeof(SDL_StorageInterface) == 48) || (sizeof(void *) == 8 && sizeof(SDL_StorageInterface) == 96), "(sizeof(void *) == 4 && sizeof(SDL_StorageInterface) == 48) || (sizeof(void *) == 8 && sizeof(SDL_StorageInterface) == 96)")

                                                                ;
# 119 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_storage.h"
typedef struct SDL_Storage SDL_Storage;
# 136 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_storage.h"
extern SDL_Storage * SDL_OpenTitleStorage(const char *override, SDL_PropertiesID props);
# 162 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_storage.h"
extern SDL_Storage * SDL_OpenUserStorage(const char *org, const char *app, SDL_PropertiesID props);
# 186 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_storage.h"
extern SDL_Storage * SDL_OpenFileStorage(const char *path);
# 215 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_storage.h"
extern SDL_Storage * SDL_OpenStorage(const SDL_StorageInterface *iface, void *userdata);
# 233 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_storage.h"
extern bool SDL_CloseStorage(SDL_Storage *storage);
# 247 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_storage.h"
extern bool SDL_StorageReady(SDL_Storage *storage);
# 263 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_storage.h"
extern bool SDL_GetStorageFileSize(SDL_Storage *storage, const char *path, Uint64 *length);
# 282 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_storage.h"
extern bool SDL_ReadStorageFile(SDL_Storage *storage, const char *path, void *destination, Uint64 length);
# 300 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_storage.h"
extern bool SDL_WriteStorageFile(SDL_Storage *storage, const char *path, const void *source, Uint64 length);
# 314 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_storage.h"
extern bool SDL_CreateStorageDirectory(SDL_Storage *storage, const char *path);
# 338 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_storage.h"
extern bool SDL_EnumerateStorageDirectory(SDL_Storage *storage, const char *path, SDL_EnumerateDirectoryCallback callback, void *userdata);
# 352 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_storage.h"
extern bool SDL_RemoveStoragePath(SDL_Storage *storage, const char *path);
# 367 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_storage.h"
extern bool SDL_RenameStoragePath(SDL_Storage *storage, const char *oldpath, const char *newpath);
# 382 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_storage.h"
extern bool SDL_CopyStorageFile(SDL_Storage *storage, const char *oldpath, const char *newpath);
# 398 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_storage.h"
extern bool SDL_GetStoragePathInfo(SDL_Storage *storage, const char *path, SDL_PathInfo *info);
# 411 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_storage.h"
extern Uint64 SDL_GetStorageSpaceRemaining(SDL_Storage *storage);
# 448 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_storage.h"
extern char ** SDL_GlobStorageDirectory(SDL_Storage *storage, const char *path, const char *pattern, SDL_GlobFlags flags, int *count);



}

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_close_code.h" 1
# 455 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_storage.h" 2
# 75 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL.h" 2

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_system.h" 1
# 36 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_system.h"
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_begin_code.h" 1
# 37 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_system.h" 2


extern "C" {
# 48 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_system.h"
typedef struct tagMSG MSG;
# 72 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_system.h"
typedef bool ( *SDL_WindowsMessageHook)(void *userdata, MSG *msg);
# 88 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_system.h"
extern void SDL_SetWindowsMessageHook(SDL_WindowsMessageHook callback, void *userdata);
# 106 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_system.h"
extern int SDL_GetDirect3D9AdapterIndex(SDL_DisplayID displayID);
# 123 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_system.h"
extern bool SDL_GetDXGIOutputInfo(SDL_DisplayID displayID, int *adapterIndex, int *outputIndex);
# 132 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_system.h"
typedef union _XEvent XEvent;
typedef bool ( *SDL_X11EventHook)(void *userdata, XEvent *xevent);
# 146 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_system.h"
extern void SDL_SetX11EventHook(SDL_X11EventHook callback, void *userdata);
# 555 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_system.h"
extern bool SDL_IsTablet(void);
# 566 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_system.h"
extern bool SDL_IsTV(void);
# 585 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_system.h"
extern void SDL_OnApplicationWillTerminate(void);
# 602 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_system.h"
extern void SDL_OnApplicationDidReceiveMemoryWarning(void);
# 619 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_system.h"
extern void SDL_OnApplicationWillEnterBackground(void);
# 636 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_system.h"
extern void SDL_OnApplicationDidEnterBackground(void);
# 653 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_system.h"
extern void SDL_OnApplicationWillEnterForeground(void);
# 670 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_system.h"
extern void SDL_OnApplicationDidEnterForeground(void);
# 734 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_system.h"
}

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_close_code.h" 1
# 737 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_system.h" 2
# 77 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL.h" 2

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_time.h" 1
# 34 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_time.h"
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_begin_code.h" 1
# 35 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_time.h" 2


extern "C" {
# 46 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_time.h"
typedef struct SDL_DateTime
{
    int year;
    int month;
    int day;
    int hour;
    int minute;
    int second;
    int nanosecond;
    int day_of_week;
    int utc_offset;
} SDL_DateTime;
# 66 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_time.h"
typedef enum SDL_DateFormat
{
    SDL_DATE_FORMAT_YYYYMMDD = 0,
    SDL_DATE_FORMAT_DDMMYYYY = 1,
    SDL_DATE_FORMAT_MMDDYYYY = 2
} SDL_DateFormat;
# 80 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_time.h"
typedef enum SDL_TimeFormat
{
    SDL_TIME_FORMAT_24HR = 0,
    SDL_TIME_FORMAT_12HR = 1
} SDL_TimeFormat;
# 103 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_time.h"
extern bool SDL_GetDateTimeLocalePreferences(SDL_DateFormat *dateFormat, SDL_TimeFormat *timeFormat);
# 115 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_time.h"
extern bool SDL_GetCurrentTime(SDL_Time *ticks);
# 131 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_time.h"
extern bool SDL_TimeToDateTime(SDL_Time ticks, SDL_DateTime *dt, bool localTime);
# 146 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_time.h"
extern bool SDL_DateTimeToTime(const SDL_DateTime *dt, SDL_Time *ticks);
# 162 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_time.h"
extern void SDL_TimeToWindows(SDL_Time ticks, Uint32 *dwLowDateTime, Uint32 *dwHighDateTime);
# 177 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_time.h"
extern SDL_Time SDL_TimeFromWindows(Uint32 dwLowDateTime, Uint32 dwHighDateTime);
# 189 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_time.h"
extern int SDL_GetDaysInMonth(int year, int month);
# 202 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_time.h"
extern int SDL_GetDayOfYear(int year, int month, int day);
# 215 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_time.h"
extern int SDL_GetDayOfWeek(int year, int month, int day);



}

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_close_code.h" 1
# 222 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_time.h" 2
# 79 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL.h" 2
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_timer.h" 1
# 34 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_timer.h"
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_begin_code.h" 1
# 35 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_timer.h" 2


extern "C" {
# 61 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_timer.h"
extern Uint64 SDL_GetTicks(void);
# 71 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_timer.h"
extern Uint64 SDL_GetTicksNS(void);
# 88 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_timer.h"
extern Uint64 SDL_GetPerformanceCounter(void);
# 99 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_timer.h"
extern Uint64 SDL_GetPerformanceFrequency(void);
# 112 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_timer.h"
extern void SDL_Delay(Uint32 ms);
# 125 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_timer.h"
extern void SDL_DelayNS(Uint64 ns);
# 138 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_timer.h"
extern void SDL_DelayPrecise(Uint64 ns);






typedef Uint32 SDL_TimerID;
# 171 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_timer.h"
typedef Uint32 ( *SDL_TimerCallback)(void *userdata, SDL_TimerID timerID, Uint32 interval);
# 207 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_timer.h"
extern SDL_TimerID SDL_AddTimer(Uint32 interval, SDL_TimerCallback callback, void *userdata);
# 233 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_timer.h"
typedef Uint64 ( *SDL_NSTimerCallback)(void *userdata, SDL_TimerID timerID, Uint64 interval);
# 269 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_timer.h"
extern SDL_TimerID SDL_AddTimerNS(Uint64 interval, SDL_NSTimerCallback callback, void *userdata);
# 282 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_timer.h"
extern bool SDL_RemoveTimer(SDL_TimerID id);




}

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_close_code.h" 1
# 290 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_timer.h" 2
# 80 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL.h" 2

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_version.h" 1
# 34 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_version.h"
# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_begin_code.h" 1
# 35 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_version.h" 2


extern "C" {
# 146 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_version.h"
extern int SDL_GetVersion(void);
# 172 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_version.h"
extern const char * SDL_GetRevision(void);




}

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_close_code.h" 1
# 180 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_version.h" 2
# 82 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL.h" 2

# 1 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL_oldnames.h" 1
# 84 "D:/Libraries_CMake/libs/MinGW/SDL3/include/SDL3/SDL.h" 2
# 6 "D:/Institute/Third_year/PZ_Networks/1_3/Client/Entities/Entity/Entity.h" 2
# 14 "D:/Institute/Third_year/PZ_Networks/1_3/Client/Entities/Entity/Entity.h"
struct Boundary {
    long x1, y1, x2, y2;
};

struct Boundary_F {
    float x1, y1, x2, y2;
};


class Entity {
public:
    inline static constexpr float SCALE = 1;
    inline static constexpr long TILE_SIZE = static_cast<long>(32 * SCALE);
    inline static constexpr float TILE_SIZE_F = static_cast<float>(TILE_SIZE);

public:




    Entity (SDL_Texture* texture, SDL_Rect texture_box, SDL_Rect boundary_box, SDL_FPoint tile_position, SDL_Point position_offset);

    [[nodiscard]] SDL_Texture* get_texture () const;






    [[nodiscard]] const SDL_Point& get_position () const;
    [[nodiscard]] SDL_Point get_texture_size () const;
    [[nodiscard]] SDL_Rect get_source_rect () const;
    [[nodiscard]] SDL_Rect get_destination_rect () const;

    [[nodiscard]] Boundary get_boundary () const;

public:




    void move (SDL_FPoint new_tile_position);




    void move (SDL_Point new_tile_position);

protected:
    SDL_Texture* m_texture;

    SDL_FPoint m_true_position;
    SDL_Point m_position;

    SDL_Rect m_texture_box;
    SDL_Rect m_boundary_box;
    SDL_Point m_position_offset;

protected:

    void move_lt (SDL_Point new_position);
    void move_lt_true (SDL_FPoint new_position);




    void update_true_coordinates ();




    void update_integer_coordinates ();
};
# 4 "D:/Institute/Third_year/PZ_Networks/1_3/Client/Entities/Block/Block.h" 2

# 1 "D:/Programs/MinGW/include/c++/14.2.0/array" 1 3
# 32 "D:/Programs/MinGW/include/c++/14.2.0/array" 3
       
# 33 "D:/Programs/MinGW/include/c++/14.2.0/array" 3





# 1 "D:/Programs/MinGW/include/c++/14.2.0/compare" 1 3
# 33 "D:/Programs/MinGW/include/c++/14.2.0/compare" 3
       
# 34 "D:/Programs/MinGW/include/c++/14.2.0/compare" 3


# 1 "D:/Programs/MinGW/include/c++/14.2.0/bits/version.h" 1 3
# 47 "D:/Programs/MinGW/include/c++/14.2.0/bits/version.h" 3
       
# 48 "D:/Programs/MinGW/include/c++/14.2.0/bits/version.h" 3

# 1 "D:/Programs/MinGW/include/c++/14.2.0/x86_64-w64-mingw32/bits/c++config.h" 1 3
# 33 "D:/Programs/MinGW/include/c++/14.2.0/x86_64-w64-mingw32/bits/c++config.h" 3
       
# 34 "D:/Programs/MinGW/include/c++/14.2.0/x86_64-w64-mingw32/bits/c++config.h" 3
# 308 "D:/Programs/MinGW/include/c++/14.2.0/x86_64-w64-mingw32/bits/c++config.h" 3

# 308 "D:/Programs/MinGW/include/c++/14.2.0/x86_64-w64-mingw32/bits/c++config.h" 3
namespace std
{
  typedef long long unsigned int size_t;
  typedef long long int ptrdiff_t;


  typedef decltype(nullptr) nullptr_t;


#pragma GCC visibility push(default)


  extern "C++" __attribute__ ((__noreturn__, __always_inline__))
  inline void __terminate() noexcept
  {
    void terminate() noexcept __attribute__ ((__noreturn__,__cold__));
    terminate();
  }
#pragma GCC visibility pop
}
# 341 "D:/Programs/MinGW/include/c++/14.2.0/x86_64-w64-mingw32/bits/c++config.h" 3
namespace std
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
namespace __gnu_cxx
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
# 534 "D:/Programs/MinGW/include/c++/14.2.0/x86_64-w64-mingw32/bits/c++config.h" 3
namespace std
{
#pragma GCC visibility push(default)




  __attribute__((__always_inline__))
  constexpr inline bool
  __is_constant_evaluated() noexcept
  {


    if consteval { return true; } else { return false; }






  }
#pragma GCC visibility pop
}
# 573 "D:/Programs/MinGW/include/c++/14.2.0/x86_64-w64-mingw32/bits/c++config.h" 3
namespace std
{
#pragma GCC visibility push(default)

  extern "C++" __attribute__ ((__noreturn__))
  void
  __glibcxx_assert_fail
    (const char* __file, int __line, const char* __function,
     const char* __condition)
  noexcept;
#pragma GCC visibility pop
}
# 601 "D:/Programs/MinGW/include/c++/14.2.0/x86_64-w64-mingw32/bits/c++config.h" 3
namespace std
{
  __attribute__((__always_inline__,__visibility__("default")))
  inline void
  __glibcxx_assert_fail()
  { }
}
# 680 "D:/Programs/MinGW/include/c++/14.2.0/x86_64-w64-mingw32/bits/c++config.h" 3
# 1 "D:/Programs/MinGW/include/c++/14.2.0/x86_64-w64-mingw32/bits/os_defines.h" 1 3
# 681 "D:/Programs/MinGW/include/c++/14.2.0/x86_64-w64-mingw32/bits/c++config.h" 2 3


# 1 "D:/Programs/MinGW/include/c++/14.2.0/x86_64-w64-mingw32/bits/cpu_defines.h" 1 3
# 684 "D:/Programs/MinGW/include/c++/14.2.0/x86_64-w64-mingw32/bits/c++config.h" 2 3
# 825 "D:/Programs/MinGW/include/c++/14.2.0/x86_64-w64-mingw32/bits/c++config.h" 3
namespace __gnu_cxx
{
  typedef __decltype(0.0bf16) __bfloat16_t;
}
# 887 "D:/Programs/MinGW/include/c++/14.2.0/x86_64-w64-mingw32/bits/c++config.h" 3
# 1 "D:/Programs/MinGW/include/c++/14.2.0/pstl/pstl_config.h" 1 3
# 888 "D:/Programs/MinGW/include/c++/14.2.0/x86_64-w64-mingw32/bits/c++config.h" 2 3
# 50 "D:/Programs/MinGW/include/c++/14.2.0/bits/version.h" 2 3
# 37 "D:/Programs/MinGW/include/c++/14.2.0/compare" 2 3



# 1 "D:/Programs/MinGW/include/c++/14.2.0/concepts" 1 3
# 33 "D:/Programs/MinGW/include/c++/14.2.0/concepts" 3
       
# 34 "D:/Programs/MinGW/include/c++/14.2.0/concepts" 3


# 1 "D:/Programs/MinGW/include/c++/14.2.0/bits/version.h" 1 3
# 47 "D:/Programs/MinGW/include/c++/14.2.0/bits/version.h" 3
       
# 48 "D:/Programs/MinGW/include/c++/14.2.0/bits/version.h" 3
# 37 "D:/Programs/MinGW/include/c++/14.2.0/concepts" 2 3
# 46 "D:/Programs/MinGW/include/c++/14.2.0/concepts" 3
# 1 "D:/Programs/MinGW/include/c++/14.2.0/type_traits" 1 3
# 32 "D:/Programs/MinGW/include/c++/14.2.0/type_traits" 3
       
# 33 "D:/Programs/MinGW/include/c++/14.2.0/type_traits" 3
# 63 "D:/Programs/MinGW/include/c++/14.2.0/type_traits" 3
# 1 "D:/Programs/MinGW/include/c++/14.2.0/bits/version.h" 1 3
# 47 "D:/Programs/MinGW/include/c++/14.2.0/bits/version.h" 3
       
# 48 "D:/Programs/MinGW/include/c++/14.2.0/bits/version.h" 3
# 64 "D:/Programs/MinGW/include/c++/14.2.0/type_traits" 2 3

namespace std
{


  template<typename _Tp>
    class reference_wrapper;
# 86 "D:/Programs/MinGW/include/c++/14.2.0/type_traits" 3
  template<typename _Tp, _Tp __v>
    struct integral_constant
    {
      static constexpr _Tp value = __v;
      using value_type = _Tp;
      using type = integral_constant<_Tp, __v>;
      constexpr operator value_type() const noexcept { return value; }


      constexpr value_type operator()() const noexcept { return value; }

    };
# 106 "D:/Programs/MinGW/include/c++/14.2.0/type_traits" 3
  template<bool __v>
    using __bool_constant = integral_constant<bool, __v>;



  using true_type = __bool_constant<true>;


  using false_type = __bool_constant<false>;




  template<bool __v>
    using bool_constant = __bool_constant<__v>;






  template<bool, typename _Tp = void>
    struct enable_if
    { };


  template<typename _Tp>
    struct enable_if<true, _Tp>
    { using type = _Tp; };


  template<bool _Cond, typename _Tp = void>
    using __enable_if_t = typename enable_if<_Cond, _Tp>::type;

  template<bool>
    struct __conditional
    {
      template<typename _Tp, typename>
 using type = _Tp;
    };

  template<>
    struct __conditional<false>
    {
      template<typename, typename _Up>
 using type = _Up;
    };


  template<bool _Cond, typename _If, typename _Else>
    using __conditional_t
      = typename __conditional<_Cond>::template type<_If, _Else>;


  template <typename _Type>
    struct __type_identity
    { using type = _Type; };

  template<typename _Tp>
    using __type_identity_t = typename __type_identity<_Tp>::type;

  namespace __detail
  {

    template<typename _Tp, typename...>
      using __first_t = _Tp;


    template<typename... _Bn>
      auto __or_fn(int) -> __first_t<false_type,
         __enable_if_t<!bool(_Bn::value)>...>;

    template<typename... _Bn>
      auto __or_fn(...) -> true_type;

    template<typename... _Bn>
      auto __and_fn(int) -> __first_t<true_type,
          __enable_if_t<bool(_Bn::value)>...>;

    template<typename... _Bn>
      auto __and_fn(...) -> false_type;
  }




  template<typename... _Bn>
    struct __or_
    : decltype(__detail::__or_fn<_Bn...>(0))
    { };

  template<typename... _Bn>
    struct __and_
    : decltype(__detail::__and_fn<_Bn...>(0))
    { };

  template<typename _Pp>
    struct __not_
    : __bool_constant<!bool(_Pp::value)>
    { };





  template<typename... _Bn>
    inline constexpr bool __or_v = __or_<_Bn...>::value;
  template<typename... _Bn>
    inline constexpr bool __and_v = __and_<_Bn...>::value;

  namespace __detail
  {
    template<typename , typename _B1, typename... _Bn>
      struct __disjunction_impl
      { using type = _B1; };

    template<typename _B1, typename _B2, typename... _Bn>
      struct __disjunction_impl<__enable_if_t<!bool(_B1::value)>, _B1, _B2, _Bn...>
      { using type = typename __disjunction_impl<void, _B2, _Bn...>::type; };

    template<typename , typename _B1, typename... _Bn>
      struct __conjunction_impl
      { using type = _B1; };

    template<typename _B1, typename _B2, typename... _Bn>
      struct __conjunction_impl<__enable_if_t<bool(_B1::value)>, _B1, _B2, _Bn...>
      { using type = typename __conjunction_impl<void, _B2, _Bn...>::type; };
  }


  template<typename... _Bn>
    struct conjunction
    : __detail::__conjunction_impl<void, _Bn...>::type
    { };

  template<>
    struct conjunction<>
    : true_type
    { };

  template<typename... _Bn>
    struct disjunction
    : __detail::__disjunction_impl<void, _Bn...>::type
    { };

  template<>
    struct disjunction<>
    : false_type
    { };

  template<typename _Pp>
    struct negation
    : __not_<_Pp>::type
    { };




  template<typename... _Bn>
    inline constexpr bool conjunction_v = conjunction<_Bn...>::value;

  template<typename... _Bn>
    inline constexpr bool disjunction_v = disjunction<_Bn...>::value;

  template<typename _Pp>
    inline constexpr bool negation_v = negation<_Pp>::value;





  template<typename>
    struct is_reference;
  template<typename>
    struct is_function;
  template<typename>
    struct is_void;
  template<typename>
    struct remove_cv;
  template<typename>
    struct is_const;


  template<typename>
    struct __is_array_unknown_bounds;




  template <typename _Tp, size_t = sizeof(_Tp)>
    constexpr true_type __is_complete_or_unbounded(__type_identity<_Tp>)
    { return {}; }

  template <typename _TypeIdentity,
      typename _NestedType = typename _TypeIdentity::type>
    constexpr typename __or_<
      is_reference<_NestedType>,
      is_function<_NestedType>,
      is_void<_NestedType>,
      __is_array_unknown_bounds<_NestedType>
    >::type __is_complete_or_unbounded(_TypeIdentity)
    { return {}; }


  template<typename _Tp>
    using __remove_cv_t = typename remove_cv<_Tp>::type;





  template<typename _Tp>
    struct is_void
    : public false_type { };

  template<>
    struct is_void<void>
    : public true_type { };

  template<>
    struct is_void<const void>
    : public true_type { };

  template<>
    struct is_void<volatile void>
    : public true_type { };

  template<>
    struct is_void<const volatile void>
    : public true_type { };


  template<typename>
    struct __is_integral_helper
    : public false_type { };

  template<>
    struct __is_integral_helper<bool>
    : public true_type { };

  template<>
    struct __is_integral_helper<char>
    : public true_type { };

  template<>
    struct __is_integral_helper<signed char>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned char>
    : public true_type { };




  template<>
    struct __is_integral_helper<wchar_t>
    : public true_type { };


  template<>
    struct __is_integral_helper<char8_t>
    : public true_type { };


  template<>
    struct __is_integral_helper<char16_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<char32_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<short>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned short>
    : public true_type { };

  template<>
    struct __is_integral_helper<int>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned int>
    : public true_type { };

  template<>
    struct __is_integral_helper<long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long>
    : public true_type { };

  template<>
    struct __is_integral_helper<long long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long long>
    : public true_type { };




  __extension__
  template<>
    struct __is_integral_helper<__int128>
    : public true_type { };

  __extension__
  template<>
    struct __is_integral_helper<unsigned __int128>
    : public true_type { };
# 460 "D:/Programs/MinGW/include/c++/14.2.0/type_traits" 3
  template<typename _Tp>
    struct is_integral
    : public __is_integral_helper<__remove_cv_t<_Tp>>::type
    { };


  template<typename>
    struct __is_floating_point_helper
    : public false_type { };

  template<>
    struct __is_floating_point_helper<float>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<double>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<long double>
    : public true_type { };


  template<>
    struct __is_floating_point_helper<_Float16>
    : public true_type { };



  template<>
    struct __is_floating_point_helper<_Float32>
    : public true_type { };



  template<>
    struct __is_floating_point_helper<_Float64>
    : public true_type { };



  template<>
    struct __is_floating_point_helper<_Float128>
    : public true_type { };



  template<>
    struct __is_floating_point_helper<__gnu_cxx::__bfloat16_t>
    : public true_type { };



  template<>
    struct __is_floating_point_helper<__float128>
    : public true_type { };




  template<typename _Tp>
    struct is_floating_point
    : public __is_floating_point_helper<__remove_cv_t<_Tp>>::type
    { };



  template<typename _Tp>
    struct is_array
    : public __bool_constant<__is_array(_Tp)>
    { };
# 545 "D:/Programs/MinGW/include/c++/14.2.0/type_traits" 3
  template<typename>
    struct __is_pointer_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_pointer_helper<_Tp*>
    : public true_type { };


  template<typename _Tp>
    struct is_pointer
    : public __is_pointer_helper<__remove_cv_t<_Tp>>::type
    { };


  template<typename>
    struct is_lvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_lvalue_reference<_Tp&>
    : public true_type { };


  template<typename>
    struct is_rvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_rvalue_reference<_Tp&&>
    : public true_type { };



  template<typename _Tp>
    struct is_member_object_pointer
    : public __bool_constant<__is_member_object_pointer(_Tp)>
    { };
# 601 "D:/Programs/MinGW/include/c++/14.2.0/type_traits" 3
  template<typename _Tp>
    struct is_member_function_pointer
    : public __bool_constant<__is_member_function_pointer(_Tp)>
    { };
# 622 "D:/Programs/MinGW/include/c++/14.2.0/type_traits" 3
  template<typename _Tp>
    struct is_enum
    : public __bool_constant<__is_enum(_Tp)>
    { };


  template<typename _Tp>
    struct is_union
    : public __bool_constant<__is_union(_Tp)>
    { };


  template<typename _Tp>
    struct is_class
    : public __bool_constant<__is_class(_Tp)>
    { };



  template<typename _Tp>
    struct is_function
    : public __bool_constant<__is_function(_Tp)>
    { };
# 661 "D:/Programs/MinGW/include/c++/14.2.0/type_traits" 3
  template<typename _Tp>
    struct is_null_pointer
    : public false_type { };

  template<>
    struct is_null_pointer<std::nullptr_t>
    : public true_type { };

  template<>
    struct is_null_pointer<const std::nullptr_t>
    : public true_type { };

  template<>
    struct is_null_pointer<volatile std::nullptr_t>
    : public true_type { };

  template<>
    struct is_null_pointer<const volatile std::nullptr_t>
    : public true_type { };



  template<typename _Tp>
    struct __is_nullptr_t
    : public is_null_pointer<_Tp>
    { } __attribute__ ((__deprecated__ ("use '" "std::is_null_pointer" "' instead")));






  template<typename _Tp>
    struct is_reference
    : public __bool_constant<__is_reference(_Tp)>
    { };
# 715 "D:/Programs/MinGW/include/c++/14.2.0/type_traits" 3
  template<typename _Tp>
    struct is_arithmetic
    : public __or_<is_integral<_Tp>, is_floating_point<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_fundamental
    : public __or_<is_arithmetic<_Tp>, is_void<_Tp>,
     is_null_pointer<_Tp>>::type
    { };



  template<typename _Tp>
    struct is_object
    : public __bool_constant<__is_object(_Tp)>
    { };
# 741 "D:/Programs/MinGW/include/c++/14.2.0/type_traits" 3
  template<typename>
    struct is_member_pointer;


  template<typename _Tp>
    struct is_scalar
    : public __or_<is_arithmetic<_Tp>, is_enum<_Tp>, is_pointer<_Tp>,
                   is_member_pointer<_Tp>, is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_compound
    : public __bool_constant<!is_fundamental<_Tp>::value> { };



  template<typename _Tp>
    struct is_member_pointer
    : public __bool_constant<__is_member_pointer(_Tp)>
    { };
# 779 "D:/Programs/MinGW/include/c++/14.2.0/type_traits" 3
  template<typename, typename>
    struct is_same;


  template<typename _Tp, typename... _Types>
    using __is_one_of = __or_<is_same<_Tp, _Types>...>;


  __extension__
  template<typename _Tp>
    using __is_signed_integer = __is_one_of<__remove_cv_t<_Tp>,
   signed char, signed short, signed int, signed long,
   signed long long

   , signed __int128
# 804 "D:/Programs/MinGW/include/c++/14.2.0/type_traits" 3
   >;


  __extension__
  template<typename _Tp>
    using __is_unsigned_integer = __is_one_of<__remove_cv_t<_Tp>,
   unsigned char, unsigned short, unsigned int, unsigned long,
   unsigned long long

   , unsigned __int128
# 824 "D:/Programs/MinGW/include/c++/14.2.0/type_traits" 3
   >;


  template<typename _Tp>
    using __is_standard_integer
      = __or_<__is_signed_integer<_Tp>, __is_unsigned_integer<_Tp>>;


  template<typename...> using __void_t = void;





  template<typename>
    struct is_const
    : public false_type { };

  template<typename _Tp>
    struct is_const<_Tp const>
    : public true_type { };


  template<typename>
    struct is_volatile
    : public false_type { };

  template<typename _Tp>
    struct is_volatile<_Tp volatile>
    : public true_type { };


  template<typename _Tp>
    struct is_trivial
    : public __bool_constant<__is_trivial(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_copyable
    : public __bool_constant<__is_trivially_copyable(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_standard_layout
    : public __bool_constant<__is_standard_layout(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };






  template<typename _Tp>
    struct
    __attribute__ ((__deprecated__ ("use '" "is_standard_layout && is_trivial" "' instead")))
    is_pod
    : public __bool_constant<__is_pod(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };





  template<typename _Tp>
    struct
    [[__deprecated__]]
    is_literal_type
    : public __bool_constant<__is_literal_type(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_empty
    : public __bool_constant<__is_empty(_Tp)>
    { };


  template<typename _Tp>
    struct is_polymorphic
    : public __bool_constant<__is_polymorphic(_Tp)>
    { };




  template<typename _Tp>
    struct is_final
    : public __bool_constant<__is_final(_Tp)>
    { };



  template<typename _Tp>
    struct is_abstract
    : public __bool_constant<__is_abstract(_Tp)>
    { };


  template<typename _Tp,
    bool = is_arithmetic<_Tp>::value>
    struct __is_signed_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_signed_helper<_Tp, true>
    : public __bool_constant<_Tp(-1) < _Tp(0)>
    { };



  template<typename _Tp>
    struct is_signed
    : public __is_signed_helper<_Tp>::type
    { };


  template<typename _Tp>
    struct is_unsigned
    : public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>>::type
    { };


  template<typename _Tp, typename _Up = _Tp&&>
    _Up
    __declval(int);

  template<typename _Tp>
    _Tp
    __declval(long);


  template<typename _Tp>
    auto declval() noexcept -> decltype(__declval<_Tp>(0));

  template<typename>
    struct remove_all_extents;


  template<typename _Tp>
    struct __is_array_known_bounds
    : public false_type
    { };

  template<typename _Tp, size_t _Size>
    struct __is_array_known_bounds<_Tp[_Size]>
    : public true_type
    { };

  template<typename _Tp>
    struct __is_array_unknown_bounds
    : public false_type
    { };

  template<typename _Tp>
    struct __is_array_unknown_bounds<_Tp[]>
    : public true_type
    { };
# 1006 "D:/Programs/MinGW/include/c++/14.2.0/type_traits" 3
  struct __do_is_destructible_impl
  {
    template<typename _Tp, typename = decltype(declval<_Tp&>().~_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_destructible_impl
    : public __do_is_destructible_impl
    {
      using type = decltype(__test<_Tp>(0));
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_destructible_safe;

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, false>
    : public __is_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, true>
    : public true_type { };



  template<typename _Tp>
    struct is_destructible
    : public __is_destructible_safe<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };







  struct __do_is_nt_destructible_impl
  {
    template<typename _Tp>
      static __bool_constant<noexcept(declval<_Tp&>().~_Tp())>
      __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_nt_destructible_impl
    : public __do_is_nt_destructible_impl
    {
      using type = decltype(__test<_Tp>(0));
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_nt_destructible_safe;

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, false>
    : public __is_nt_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, true>
    : public true_type { };



  template<typename _Tp>
    struct is_nothrow_destructible
    : public __is_nt_destructible_safe<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename... _Args>
    using __is_constructible_impl
      = __bool_constant<__is_constructible(_Tp, _Args...)>;



  template<typename _Tp, typename... _Args>
    struct is_constructible
      : public __is_constructible_impl<_Tp, _Args...>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_default_constructible
    : public __is_constructible_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename = void>
    struct __add_lvalue_reference_helper
    { using type = _Tp; };

  template<typename _Tp>
    struct __add_lvalue_reference_helper<_Tp, __void_t<_Tp&>>
    { using type = _Tp&; };

  template<typename _Tp>
    using __add_lval_ref_t = typename __add_lvalue_reference_helper<_Tp>::type;



  template<typename _Tp>
    struct is_copy_constructible
    : public __is_constructible_impl<_Tp, __add_lval_ref_t<const _Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename = void>
    struct __add_rvalue_reference_helper
    { using type = _Tp; };

  template<typename _Tp>
    struct __add_rvalue_reference_helper<_Tp, __void_t<_Tp&&>>
    { using type = _Tp&&; };

  template<typename _Tp>
    using __add_rval_ref_t = typename __add_rvalue_reference_helper<_Tp>::type;



  template<typename _Tp>
    struct is_move_constructible
    : public __is_constructible_impl<_Tp, __add_rval_ref_t<_Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename... _Args>
    using __is_nothrow_constructible_impl
      = __bool_constant<__is_nothrow_constructible(_Tp, _Args...)>;



  template<typename _Tp, typename... _Args>
    struct is_nothrow_constructible
    : public __is_nothrow_constructible_impl<_Tp, _Args...>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_nothrow_default_constructible
    : public __is_nothrow_constructible_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_nothrow_copy_constructible
    : public __is_nothrow_constructible_impl<_Tp, __add_lval_ref_t<const _Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_nothrow_move_constructible
    : public __is_nothrow_constructible_impl<_Tp, __add_rval_ref_t<_Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename _Up>
    using __is_assignable_impl = __bool_constant<__is_assignable(_Tp, _Up)>;



  template<typename _Tp, typename _Up>
    struct is_assignable
    : public __is_assignable_impl<_Tp, _Up>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_copy_assignable
    : public __is_assignable_impl<__add_lval_ref_t<_Tp>,
      __add_lval_ref_t<const _Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_move_assignable
    : public __is_assignable_impl<__add_lval_ref_t<_Tp>, __add_rval_ref_t<_Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename _Up>
    using __is_nothrow_assignable_impl
      = __bool_constant<__is_nothrow_assignable(_Tp, _Up)>;



  template<typename _Tp, typename _Up>
    struct is_nothrow_assignable
    : public __is_nothrow_assignable_impl<_Tp, _Up>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_nothrow_copy_assignable
    : public __is_nothrow_assignable_impl<__add_lval_ref_t<_Tp>,
       __add_lval_ref_t<const _Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_nothrow_move_assignable
    : public __is_nothrow_assignable_impl<__add_lval_ref_t<_Tp>,
       __add_rval_ref_t<_Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename... _Args>
    using __is_trivially_constructible_impl
      = __bool_constant<__is_trivially_constructible(_Tp, _Args...)>;



  template<typename _Tp, typename... _Args>
    struct is_trivially_constructible
    : public __is_trivially_constructible_impl<_Tp, _Args...>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_default_constructible
    : public __is_trivially_constructible_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    constexpr bool __is_implicitly_default_constructible_v
      = requires (void(&__f)(_Tp)) { __f({}); };

  template<typename _Tp>
    struct __is_implicitly_default_constructible
    : __bool_constant<__is_implicitly_default_constructible_v<_Tp>>
    { };
# 1351 "D:/Programs/MinGW/include/c++/14.2.0/type_traits" 3
  template<typename _Tp>
    struct is_trivially_copy_constructible
    : public __is_trivially_constructible_impl<_Tp, __add_lval_ref_t<const _Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_move_constructible
    : public __is_trivially_constructible_impl<_Tp, __add_rval_ref_t<_Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename _Up>
    using __is_trivially_assignable_impl
      = __bool_constant<__is_trivially_assignable(_Tp, _Up)>;



  template<typename _Tp, typename _Up>
    struct is_trivially_assignable
    : public __is_trivially_assignable_impl<_Tp, _Up>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_copy_assignable
    : public __is_trivially_assignable_impl<__add_lval_ref_t<_Tp>,
         __add_lval_ref_t<const _Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_move_assignable
    : public __is_trivially_assignable_impl<__add_lval_ref_t<_Tp>,
         __add_rval_ref_t<_Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_destructible
    : public __and_<__is_destructible_safe<_Tp>,
      __bool_constant<__has_trivial_destructor(_Tp)>>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };



  template<typename _Tp>
    struct has_virtual_destructor
    : public __bool_constant<__has_virtual_destructor(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };





  template<typename _Tp>
    struct alignment_of
    : public integral_constant<std::size_t, alignof(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename>
    struct rank
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, std::size_t _Size>
    struct rank<_Tp[_Size]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };

  template<typename _Tp>
    struct rank<_Tp[]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };


  template<typename, unsigned _Uint = 0>
    struct extent
    : public integral_constant<size_t, 0> { };

  template<typename _Tp, size_t _Size>
    struct extent<_Tp[_Size], 0>
    : public integral_constant<size_t, _Size> { };

  template<typename _Tp, unsigned _Uint, size_t _Size>
    struct extent<_Tp[_Size], _Uint>
    : public extent<_Tp, _Uint - 1>::type { };

  template<typename _Tp>
    struct extent<_Tp[], 0>
    : public integral_constant<size_t, 0> { };

  template<typename _Tp, unsigned _Uint>
    struct extent<_Tp[], _Uint>
    : public extent<_Tp, _Uint - 1>::type { };






  template<typename _Tp, typename _Up>
    struct is_same
    : public __bool_constant<__is_same(_Tp, _Up)>
    { };
# 1491 "D:/Programs/MinGW/include/c++/14.2.0/type_traits" 3
  template<typename _Base, typename _Derived>
    struct is_base_of
    : public __bool_constant<__is_base_of(_Base, _Derived)>
    { };


  template<typename _From, typename _To>
    struct is_convertible
    : public __bool_constant<__is_convertible(_From, _To)>
    { };
# 1540 "D:/Programs/MinGW/include/c++/14.2.0/type_traits" 3
  template<typename _ToElementType, typename _FromElementType>
    using __is_array_convertible
      = is_convertible<_FromElementType(*)[], _ToElementType(*)[]>;





  template<typename _From, typename _To>
    inline constexpr bool is_nothrow_convertible_v
      = __is_nothrow_convertible(_From, _To);


  template<typename _From, typename _To>
    struct is_nothrow_convertible
    : public bool_constant<is_nothrow_convertible_v<_From, _To>>
    { };
# 1603 "D:/Programs/MinGW/include/c++/14.2.0/type_traits" 3
  template<typename _Tp>
    struct remove_const
    { using type = _Tp; };

  template<typename _Tp>
    struct remove_const<_Tp const>
    { using type = _Tp; };


  template<typename _Tp>
    struct remove_volatile
    { using type = _Tp; };

  template<typename _Tp>
    struct remove_volatile<_Tp volatile>
    { using type = _Tp; };



  template<typename _Tp>
    struct remove_cv
    { using type = __remove_cv(_Tp); };
# 1644 "D:/Programs/MinGW/include/c++/14.2.0/type_traits" 3
  template<typename _Tp>
    struct add_const
    { using type = _Tp const; };


  template<typename _Tp>
    struct add_volatile
    { using type = _Tp volatile; };


  template<typename _Tp>
    struct add_cv
    { using type = _Tp const volatile; };



  template<typename _Tp>
    using remove_const_t = typename remove_const<_Tp>::type;


  template<typename _Tp>
    using remove_volatile_t = typename remove_volatile<_Tp>::type;


  template<typename _Tp>
    using remove_cv_t = typename remove_cv<_Tp>::type;


  template<typename _Tp>
    using add_const_t = typename add_const<_Tp>::type;


  template<typename _Tp>
    using add_volatile_t = typename add_volatile<_Tp>::type;


  template<typename _Tp>
    using add_cv_t = typename add_cv<_Tp>::type;






  template<typename _Tp>
    struct remove_reference
    { using type = __remove_reference(_Tp); };
# 1706 "D:/Programs/MinGW/include/c++/14.2.0/type_traits" 3
  template<typename _Tp>
    struct add_lvalue_reference
    { using type = __add_lval_ref_t<_Tp>; };


  template<typename _Tp>
    struct add_rvalue_reference
    { using type = __add_rval_ref_t<_Tp>; };



  template<typename _Tp>
    using remove_reference_t = typename remove_reference<_Tp>::type;


  template<typename _Tp>
    using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;


  template<typename _Tp>
    using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;







  template<typename _Unqualified, bool _IsConst, bool _IsVol>
    struct __cv_selector;

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, false>
    { using __type = _Unqualified; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, true>
    { using __type = volatile _Unqualified; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, false>
    { using __type = const _Unqualified; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, true>
    { using __type = const volatile _Unqualified; };

  template<typename _Qualified, typename _Unqualified,
    bool _IsConst = is_const<_Qualified>::value,
    bool _IsVol = is_volatile<_Qualified>::value>
    class __match_cv_qualifiers
    {
      using __match = __cv_selector<_Unqualified, _IsConst, _IsVol>;

    public:
      using __type = typename __match::__type;
    };


  template<typename _Tp>
    struct __make_unsigned
    { using __type = _Tp; };

  template<>
    struct __make_unsigned<char>
    { using __type = unsigned char; };

  template<>
    struct __make_unsigned<signed char>
    { using __type = unsigned char; };

  template<>
    struct __make_unsigned<short>
    { using __type = unsigned short; };

  template<>
    struct __make_unsigned<int>
    { using __type = unsigned int; };

  template<>
    struct __make_unsigned<long>
    { using __type = unsigned long; };

  template<>
    struct __make_unsigned<long long>
    { using __type = unsigned long long; };


  __extension__
  template<>
    struct __make_unsigned<__int128>
    { using __type = unsigned __int128; };
# 1819 "D:/Programs/MinGW/include/c++/14.2.0/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = __is_enum(_Tp)>
    class __make_unsigned_selector;

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, true, false>
    {
      using __unsigned_type
 = typename __make_unsigned<__remove_cv_t<_Tp>>::__type;

    public:
      using __type
 = typename __match_cv_qualifiers<_Tp, __unsigned_type>::__type;
    };

  class __make_unsigned_selector_base
  {
  protected:
    template<typename...> struct _List { };

    template<typename _Tp, typename... _Up>
      struct _List<_Tp, _Up...> : _List<_Up...>
      { static constexpr size_t __size = sizeof(_Tp); };

    template<size_t _Sz, typename _Tp, bool = (_Sz <= _Tp::__size)>
      struct __select;

    template<size_t _Sz, typename _Uint, typename... _UInts>
      struct __select<_Sz, _List<_Uint, _UInts...>, true>
      { using __type = _Uint; };

    template<size_t _Sz, typename _Uint, typename... _UInts>
      struct __select<_Sz, _List<_Uint, _UInts...>, false>
      : __select<_Sz, _List<_UInts...>>
      { };
  };


  template<typename _Tp>
    class __make_unsigned_selector<_Tp, false, true>
    : __make_unsigned_selector_base
    {

      using _UInts = _List<unsigned char, unsigned short, unsigned int,
      unsigned long, unsigned long long>;

      using __unsigned_type = typename __select<sizeof(_Tp), _UInts>::__type;

    public:
      using __type
 = typename __match_cv_qualifiers<_Tp, __unsigned_type>::__type;
    };





  template<>
    struct __make_unsigned<wchar_t>
    {
      using __type
 = typename __make_unsigned_selector<wchar_t, false, true>::__type;
    };


  template<>
    struct __make_unsigned<char8_t>
    {
      using __type
 = typename __make_unsigned_selector<char8_t, false, true>::__type;
    };


  template<>
    struct __make_unsigned<char16_t>
    {
      using __type
 = typename __make_unsigned_selector<char16_t, false, true>::__type;
    };

  template<>
    struct __make_unsigned<char32_t>
    {
      using __type
 = typename __make_unsigned_selector<char32_t, false, true>::__type;
    };






  template<typename _Tp>
    struct make_unsigned
    { using type = typename __make_unsigned_selector<_Tp>::__type; };


  template<> struct make_unsigned<bool>;
  template<> struct make_unsigned<bool const>;
  template<> struct make_unsigned<bool volatile>;
  template<> struct make_unsigned<bool const volatile>;




  template<typename _Tp>
    struct __make_signed
    { using __type = _Tp; };

  template<>
    struct __make_signed<char>
    { using __type = signed char; };

  template<>
    struct __make_signed<unsigned char>
    { using __type = signed char; };

  template<>
    struct __make_signed<unsigned short>
    { using __type = signed short; };

  template<>
    struct __make_signed<unsigned int>
    { using __type = signed int; };

  template<>
    struct __make_signed<unsigned long>
    { using __type = signed long; };

  template<>
    struct __make_signed<unsigned long long>
    { using __type = signed long long; };


  __extension__
  template<>
    struct __make_signed<unsigned __int128>
    { using __type = __int128; };
# 1979 "D:/Programs/MinGW/include/c++/14.2.0/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = __is_enum(_Tp)>
    class __make_signed_selector;

  template<typename _Tp>
    class __make_signed_selector<_Tp, true, false>
    {
      using __signed_type
 = typename __make_signed<__remove_cv_t<_Tp>>::__type;

    public:
      using __type
 = typename __match_cv_qualifiers<_Tp, __signed_type>::__type;
    };


  template<typename _Tp>
    class __make_signed_selector<_Tp, false, true>
    {
      using __unsigned_type = typename __make_unsigned_selector<_Tp>::__type;

    public:
      using __type = typename __make_signed_selector<__unsigned_type>::__type;
    };





  template<>
    struct __make_signed<wchar_t>
    {
      using __type
 = typename __make_signed_selector<wchar_t, false, true>::__type;
    };


  template<>
    struct __make_signed<char8_t>
    {
      using __type
 = typename __make_signed_selector<char8_t, false, true>::__type;
    };


  template<>
    struct __make_signed<char16_t>
    {
      using __type
 = typename __make_signed_selector<char16_t, false, true>::__type;
    };

  template<>
    struct __make_signed<char32_t>
    {
      using __type
 = typename __make_signed_selector<char32_t, false, true>::__type;
    };






  template<typename _Tp>
    struct make_signed
    { using type = typename __make_signed_selector<_Tp>::__type; };


  template<> struct make_signed<bool>;
  template<> struct make_signed<bool const>;
  template<> struct make_signed<bool volatile>;
  template<> struct make_signed<bool const volatile>;



  template<typename _Tp>
    using make_signed_t = typename make_signed<_Tp>::type;


  template<typename _Tp>
    using make_unsigned_t = typename make_unsigned<_Tp>::type;





  template<typename _Tp>
    struct remove_extent
    { using type = _Tp; };

  template<typename _Tp, std::size_t _Size>
    struct remove_extent<_Tp[_Size]>
    { using type = _Tp; };

  template<typename _Tp>
    struct remove_extent<_Tp[]>
    { using type = _Tp; };


  template<typename _Tp>
    struct remove_all_extents
    { using type = _Tp; };

  template<typename _Tp, std::size_t _Size>
    struct remove_all_extents<_Tp[_Size]>
    { using type = typename remove_all_extents<_Tp>::type; };

  template<typename _Tp>
    struct remove_all_extents<_Tp[]>
    { using type = typename remove_all_extents<_Tp>::type; };



  template<typename _Tp>
    using remove_extent_t = typename remove_extent<_Tp>::type;


  template<typename _Tp>
    using remove_all_extents_t = typename remove_all_extents<_Tp>::type;






  template<typename _Tp>
    struct remove_pointer
    { using type = __remove_pointer(_Tp); };
# 2124 "D:/Programs/MinGW/include/c++/14.2.0/type_traits" 3
  template<typename _Tp, typename = void>
    struct __add_pointer_helper
    { using type = _Tp; };

  template<typename _Tp>
    struct __add_pointer_helper<_Tp, __void_t<_Tp*>>
    { using type = _Tp*; };


  template<typename _Tp>
    struct add_pointer
    : public __add_pointer_helper<_Tp>
    { };

  template<typename _Tp>
    struct add_pointer<_Tp&>
    { using type = _Tp*; };

  template<typename _Tp>
    struct add_pointer<_Tp&&>
    { using type = _Tp*; };



  template<typename _Tp>
    using remove_pointer_t = typename remove_pointer<_Tp>::type;


  template<typename _Tp>
    using add_pointer_t = typename add_pointer<_Tp>::type;


  template<std::size_t _Len>
    struct __aligned_storage_msa
    {
      union __type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__)) { } __align;
      };
    };
# 2179 "D:/Programs/MinGW/include/c++/14.2.0/type_traits" 3
  template<std::size_t _Len, std::size_t _Align =
    __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    struct
    [[__deprecated__]]
    aligned_storage
    {
      union type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__((_Align)))) { } __align;
      };
    };

  template <typename... _Types>
    struct __strictest_alignment
    {
      static const size_t _S_alignment = 0;
      static const size_t _S_size = 0;
    };

  template <typename _Tp, typename... _Types>
    struct __strictest_alignment<_Tp, _Types...>
    {
      static const size_t _S_alignment =
        alignof(_Tp) > __strictest_alignment<_Types...>::_S_alignment
 ? alignof(_Tp) : __strictest_alignment<_Types...>::_S_alignment;
      static const size_t _S_size =
        sizeof(_Tp) > __strictest_alignment<_Types...>::_S_size
 ? sizeof(_Tp) : __strictest_alignment<_Types...>::_S_size;
    };

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
# 2225 "D:/Programs/MinGW/include/c++/14.2.0/type_traits" 3
  template <size_t _Len, typename... _Types>
    struct
    [[__deprecated__]]
    aligned_union
    {
    private:
      static_assert(sizeof...(_Types) != 0, "At least one type is required");

      using __strictest = __strictest_alignment<_Types...>;
      static const size_t _S_len = _Len > __strictest::_S_size
 ? _Len : __strictest::_S_size;
    public:

      static const size_t alignment_value = __strictest::_S_alignment;

      using type = typename aligned_storage<_S_len, alignment_value>::type;
    };

  template <size_t _Len, typename... _Types>
    const size_t aligned_union<_Len, _Types...>::alignment_value;
#pragma GCC diagnostic pop





  template<typename _Up>
    struct __decay_selector
    : __conditional_t<is_const<const _Up>::value,
        remove_cv<_Up>,
        add_pointer<_Up>>
    { };

  template<typename _Up, size_t _Nm>
    struct __decay_selector<_Up[_Nm]>
    { using type = _Up*; };

  template<typename _Up>
    struct __decay_selector<_Up[]>
    { using type = _Up*; };




  template<typename _Tp>
    struct decay
    { using type = typename __decay_selector<_Tp>::type; };

  template<typename _Tp>
    struct decay<_Tp&>
    { using type = typename __decay_selector<_Tp>::type; };

  template<typename _Tp>
    struct decay<_Tp&&>
    { using type = typename __decay_selector<_Tp>::type; };




  template<typename _Tp>
    struct __strip_reference_wrapper
    {
      using __type = _Tp;
    };

  template<typename _Tp>
    struct __strip_reference_wrapper<reference_wrapper<_Tp> >
    {
      using __type = _Tp&;
    };


  template<typename _Tp>
    using __decay_t = typename decay<_Tp>::type;

  template<typename _Tp>
    using __decay_and_strip = __strip_reference_wrapper<__decay_t<_Tp>>;





  template<typename... _Cond>
    using _Require = __enable_if_t<__and_<_Cond...>::value>;


  template<typename _Tp>
    using __remove_cvref_t
     = typename remove_cv<typename remove_reference<_Tp>::type>::type;




  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct conditional
    { using type = _Iftrue; };


  template<typename _Iftrue, typename _Iffalse>
    struct conditional<false, _Iftrue, _Iffalse>
    { using type = _Iffalse; };


  template<typename... _Tp>
    struct common_type;
# 2340 "D:/Programs/MinGW/include/c++/14.2.0/type_traits" 3
  template<typename _Tp>
    struct __success_type
    { using type = _Tp; };

  struct __failure_type
  { };

  struct __do_common_type_impl
  {
    template<typename _Tp, typename _Up>
      using __cond_t
 = decltype(true ? std::declval<_Tp>() : std::declval<_Up>());



    template<typename _Tp, typename _Up>
      static __success_type<__decay_t<__cond_t<_Tp, _Up>>>
      _S_test(int);




    template<typename _Tp, typename _Up>
      static __success_type<__remove_cvref_t<__cond_t<const _Tp&, const _Up&>>>
      _S_test_2(int);


    template<typename, typename>
      static __failure_type
      _S_test_2(...);

    template<typename _Tp, typename _Up>
      static decltype(_S_test_2<_Tp, _Up>(0))
      _S_test(...);
  };


  template<>
    struct common_type<>
    { };


  template<typename _Tp0>
    struct common_type<_Tp0>
    : public common_type<_Tp0, _Tp0>
    { };


  template<typename _Tp1, typename _Tp2,
    typename _Dp1 = __decay_t<_Tp1>, typename _Dp2 = __decay_t<_Tp2>>
    struct __common_type_impl
    {


      using type = common_type<_Dp1, _Dp2>;
    };

  template<typename _Tp1, typename _Tp2>
    struct __common_type_impl<_Tp1, _Tp2, _Tp1, _Tp2>
    : private __do_common_type_impl
    {


      using type = decltype(_S_test<_Tp1, _Tp2>(0));
    };


  template<typename _Tp1, typename _Tp2>
    struct common_type<_Tp1, _Tp2>
    : public __common_type_impl<_Tp1, _Tp2>::type
    { };

  template<typename...>
    struct __common_type_pack
    { };

  template<typename, typename, typename = void>
    struct __common_type_fold;


  template<typename _Tp1, typename _Tp2, typename... _Rp>
    struct common_type<_Tp1, _Tp2, _Rp...>
    : public __common_type_fold<common_type<_Tp1, _Tp2>,
    __common_type_pack<_Rp...>>
    { };




  template<typename _CTp, typename... _Rp>
    struct __common_type_fold<_CTp, __common_type_pack<_Rp...>,
         __void_t<typename _CTp::type>>
    : public common_type<typename _CTp::type, _Rp...>
    { };


  template<typename _CTp, typename _Rp>
    struct __common_type_fold<_CTp, _Rp, void>
    { };

  template<typename _Tp, bool = __is_enum(_Tp)>
    struct __underlying_type_impl
    {
      using type = __underlying_type(_Tp);
    };

  template<typename _Tp>
    struct __underlying_type_impl<_Tp, false>
    { };



  template<typename _Tp>
    struct underlying_type
    : public __underlying_type_impl<_Tp>
    { };


  template<typename _Tp>
    struct __declval_protector
    {
      static const bool __stop = false;
    };






  template<typename _Tp>
    auto declval() noexcept -> decltype(__declval<_Tp>(0))
    {
      static_assert(__declval_protector<_Tp>::__stop,
      "declval() must not be used!");
      return __declval<_Tp>(0);
    }


  template<typename _Signature>
    struct result_of;




  struct __invoke_memfun_ref { };
  struct __invoke_memfun_deref { };
  struct __invoke_memobj_ref { };
  struct __invoke_memobj_deref { };
  struct __invoke_other { };


  template<typename _Tp, typename _Tag>
    struct __result_of_success : __success_type<_Tp>
    { using __invoke_type = _Tag; };


  struct __result_of_memfun_ref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      (std::declval<_Tp1>().*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_ref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_ref
    : private __result_of_memfun_ref_impl
    {
      using type = decltype(_S_test<_MemPtr, _Arg, _Args...>(0));
    };


  struct __result_of_memfun_deref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      ((*std::declval<_Tp1>()).*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_deref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_deref
    : private __result_of_memfun_deref_impl
    {
      using type = decltype(_S_test<_MemPtr, _Arg, _Args...>(0));
    };


  struct __result_of_memobj_ref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      std::declval<_Tp1>().*std::declval<_Fp>()
      ), __invoke_memobj_ref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_ref
    : private __result_of_memobj_ref_impl
    {
      using type = decltype(_S_test<_MemPtr, _Arg>(0));
    };


  struct __result_of_memobj_deref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      (*std::declval<_Tp1>()).*std::declval<_Fp>()
      ), __invoke_memobj_deref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_deref
    : private __result_of_memobj_deref_impl
    {
      using type = decltype(_S_test<_MemPtr, _Arg>(0));
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj;

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, _Arg>
    {
      using _Argval = __remove_cvref_t<_Arg>;
      using _MemPtr = _Res _Class::*;
      using type = typename __conditional_t<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memobj_ref<_MemPtr, _Arg>,
        __result_of_memobj_deref<_MemPtr, _Arg>
      >::type;
    };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun;

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, _Arg, _Args...>
    {
      using _Argval = typename remove_reference<_Arg>::type;
      using _MemPtr = _Res _Class::*;
      using type = typename __conditional_t<is_base_of<_Class, _Argval>::value,
        __result_of_memfun_ref<_MemPtr, _Arg, _Args...>,
        __result_of_memfun_deref<_MemPtr, _Arg, _Args...>
      >::type;
    };






  template<typename _Tp, typename _Up = __remove_cvref_t<_Tp>>
    struct __inv_unwrap
    {
      using type = _Tp;
    };

  template<typename _Tp, typename _Up>
    struct __inv_unwrap<_Tp, reference_wrapper<_Up>>
    {
      using type = _Up&;
    };

  template<bool, bool, typename _Functor, typename... _ArgTypes>
    struct __result_of_impl
    {
      using type = __failure_type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_impl<true, false, _MemPtr, _Arg>
    : public __result_of_memobj<__decay_t<_MemPtr>,
    typename __inv_unwrap<_Arg>::type>
    { };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_impl<false, true, _MemPtr, _Arg, _Args...>
    : public __result_of_memfun<__decay_t<_MemPtr>,
    typename __inv_unwrap<_Arg>::type, _Args...>
    { };


  struct __result_of_other_impl
  {
    template<typename _Fn, typename... _Args>
      static __result_of_success<decltype(
      std::declval<_Fn>()(std::declval<_Args>()...)
      ), __invoke_other> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _Functor, typename... _ArgTypes>
    struct __result_of_impl<false, false, _Functor, _ArgTypes...>
    : private __result_of_other_impl
    {
      using type = decltype(_S_test<_Functor, _ArgTypes...>(0));
    };


  template<typename _Functor, typename... _ArgTypes>
    struct __invoke_result
    : public __result_of_impl<
        is_member_object_pointer<
          typename remove_reference<_Functor>::type
        >::value,
        is_member_function_pointer<
          typename remove_reference<_Functor>::type
        >::value,
 _Functor, _ArgTypes...
      >::type
    { };


  template<typename _Fn, typename... _Args>
    using __invoke_result_t = typename __invoke_result<_Fn, _Args...>::type;


  template<typename _Functor, typename... _ArgTypes>
    struct result_of<_Functor(_ArgTypes...)>
    : public __invoke_result<_Functor, _ArgTypes...>
    { } __attribute__ ((__deprecated__ ("use '" "std::invoke_result" "' instead")));


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

  template<size_t _Len, size_t _Align =
     __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    using aligned_storage_t [[__deprecated__]] = typename aligned_storage<_Len, _Align>::type;

  template <size_t _Len, typename... _Types>
    using aligned_union_t [[__deprecated__]] = typename aligned_union<_Len, _Types...>::type;
#pragma GCC diagnostic pop


  template<typename _Tp>
    using decay_t = typename decay<_Tp>::type;


  template<bool _Cond, typename _Tp = void>
    using enable_if_t = typename enable_if<_Cond, _Tp>::type;


  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    using conditional_t = typename conditional<_Cond, _Iftrue, _Iffalse>::type;


  template<typename... _Tp>
    using common_type_t = typename common_type<_Tp...>::type;


  template<typename _Tp>
    using underlying_type_t = typename underlying_type<_Tp>::type;


  template<typename _Tp>
    using result_of_t = typename result_of<_Tp>::type;




  template<typename...> using void_t = void;
# 2727 "D:/Programs/MinGW/include/c++/14.2.0/type_traits" 3
  template<typename _Def, template<typename...> class _Op, typename... _Args>
    struct __detected_or
    {
      using type = _Def;
      using __is_detected = false_type;
    };


  template<typename _Def, template<typename...> class _Op, typename... _Args>
    requires requires { typename _Op<_Args...>; }
    struct __detected_or<_Def, _Op, _Args...>
    {
      using type = _Op<_Args...>;
      using __is_detected = true_type;
    };
# 2767 "D:/Programs/MinGW/include/c++/14.2.0/type_traits" 3
  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or_t
      = typename __detected_or<_Default, _Op, _Args...>::type;
# 2786 "D:/Programs/MinGW/include/c++/14.2.0/type_traits" 3
  template <typename _Tp>
    struct __is_swappable;

  template <typename _Tp>
    struct __is_nothrow_swappable;

  template<typename>
    struct __is_tuple_like_impl : false_type
    { };


  template<typename _Tp>
    struct __is_tuple_like
    : public __is_tuple_like_impl<__remove_cvref_t<_Tp>>::type
    { };


  template<typename _Tp>
    constexpr
    inline
    _Require<__not_<__is_tuple_like<_Tp>>,
      is_move_constructible<_Tp>,
      is_move_assignable<_Tp>>
    swap(_Tp&, _Tp&)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
             is_nothrow_move_assignable<_Tp>>::value);

  template<typename _Tp, size_t _Nm>
    constexpr
    inline
    __enable_if_t<__is_swappable<_Tp>::value>
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value);


  namespace __swappable_details {
    using std::swap;

    struct __do_is_swappable_impl
    {
      template<typename _Tp, typename
               = decltype(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))>
        static true_type __test(int);

      template<typename>
        static false_type __test(...);
    };

    struct __do_is_nothrow_swappable_impl
    {
      template<typename _Tp>
        static __bool_constant<
          noexcept(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))
        > __test(int);

      template<typename>
        static false_type __test(...);
    };

  }

  template<typename _Tp>
    struct __is_swappable_impl
    : public __swappable_details::__do_is_swappable_impl
    {
      using type = decltype(__test<_Tp>(0));
    };

  template<typename _Tp>
    struct __is_nothrow_swappable_impl
    : public __swappable_details::__do_is_nothrow_swappable_impl
    {
      using type = decltype(__test<_Tp>(0));
    };

  template<typename _Tp>
    struct __is_swappable
    : public __is_swappable_impl<_Tp>::type
    { };

  template<typename _Tp>
    struct __is_nothrow_swappable
    : public __is_nothrow_swappable_impl<_Tp>::type
    { };






  template<typename _Tp>
    struct is_swappable
    : public __is_swappable_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_nothrow_swappable
    : public __is_nothrow_swappable_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };



  template<typename _Tp>
    inline constexpr bool is_swappable_v =
      is_swappable<_Tp>::value;


  template<typename _Tp>
    inline constexpr bool is_nothrow_swappable_v =
      is_nothrow_swappable<_Tp>::value;



  namespace __swappable_with_details {
    using std::swap;

    struct __do_is_swappable_with_impl
    {
      template<typename _Tp, typename _Up, typename
               = decltype(swap(std::declval<_Tp>(), std::declval<_Up>())),
               typename
               = decltype(swap(std::declval<_Up>(), std::declval<_Tp>()))>
        static true_type __test(int);

      template<typename, typename>
        static false_type __test(...);
    };

    struct __do_is_nothrow_swappable_with_impl
    {
      template<typename _Tp, typename _Up>
        static __bool_constant<
          noexcept(swap(std::declval<_Tp>(), std::declval<_Up>()))
          &&
          noexcept(swap(std::declval<_Up>(), std::declval<_Tp>()))
        > __test(int);

      template<typename, typename>
        static false_type __test(...);
    };

  }

  template<typename _Tp, typename _Up>
    struct __is_swappable_with_impl
    : public __swappable_with_details::__do_is_swappable_with_impl
    {
      using type = decltype(__test<_Tp, _Up>(0));
    };


  template<typename _Tp>
    struct __is_swappable_with_impl<_Tp&, _Tp&>
    : public __swappable_details::__do_is_swappable_impl
    {
      using type = decltype(__test<_Tp&>(0));
    };

  template<typename _Tp, typename _Up>
    struct __is_nothrow_swappable_with_impl
    : public __swappable_with_details::__do_is_nothrow_swappable_with_impl
    {
      using type = decltype(__test<_Tp, _Up>(0));
    };


  template<typename _Tp>
    struct __is_nothrow_swappable_with_impl<_Tp&, _Tp&>
    : public __swappable_details::__do_is_nothrow_swappable_impl
    {
      using type = decltype(__test<_Tp&>(0));
    };



  template<typename _Tp, typename _Up>
    struct is_swappable_with
    : public __is_swappable_with_impl<_Tp, _Up>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "first template argument must be a complete class or an unbounded array");
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Up>{}),
 "second template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename _Up>
    struct is_nothrow_swappable_with
    : public __is_nothrow_swappable_with_impl<_Tp, _Up>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "first template argument must be a complete class or an unbounded array");
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Up>{}),
 "second template argument must be a complete class or an unbounded array");
    };



  template<typename _Tp, typename _Up>
    inline constexpr bool is_swappable_with_v =
      is_swappable_with<_Tp, _Up>::value;


  template<typename _Tp, typename _Up>
    inline constexpr bool is_nothrow_swappable_with_v =
      is_nothrow_swappable_with<_Tp, _Up>::value;
# 3008 "D:/Programs/MinGW/include/c++/14.2.0/type_traits" 3
  template<typename _Result, typename _Ret,
    bool = is_void<_Ret>::value, typename = void>
    struct __is_invocable_impl
    : false_type
    {
      using __nothrow_conv = false_type;
    };


  template<typename _Result, typename _Ret>
    struct __is_invocable_impl<_Result, _Ret,
                                true,
          __void_t<typename _Result::type>>
    : true_type
    {
      using __nothrow_conv = true_type;
    };

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"

  template<typename _Result, typename _Ret>
    struct __is_invocable_impl<_Result, _Ret,
                                false,
          __void_t<typename _Result::type>>
    {
    private:

      using _Res_t = typename _Result::type;



      static _Res_t _S_get() noexcept;


      template<typename _Tp>
 static void _S_conv(__type_identity_t<_Tp>) noexcept;


      template<typename _Tp,
        bool _Nothrow = noexcept(_S_conv<_Tp>(_S_get())),
        typename = decltype(_S_conv<_Tp>(_S_get())),

        bool _Dangle = __reference_converts_from_temporary(_Tp, _Res_t)



       >
 static __bool_constant<_Nothrow && !_Dangle>
 _S_test(int);

      template<typename _Tp, bool = false>
 static false_type
 _S_test(...);

    public:

      using type = decltype(_S_test<_Ret, true>(1));


      using __nothrow_conv = decltype(_S_test<_Ret>(1));
    };
#pragma GCC diagnostic pop

  template<typename _Fn, typename... _ArgTypes>
    struct __is_invocable
    : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type
    { };

  template<typename _Fn, typename _Tp, typename... _Args>
    constexpr bool __call_is_nt(__invoke_memfun_ref)
    {
      using _Up = typename __inv_unwrap<_Tp>::type;
      return noexcept((std::declval<_Up>().*std::declval<_Fn>())(
     std::declval<_Args>()...));
    }

  template<typename _Fn, typename _Tp, typename... _Args>
    constexpr bool __call_is_nt(__invoke_memfun_deref)
    {
      return noexcept(((*std::declval<_Tp>()).*std::declval<_Fn>())(
     std::declval<_Args>()...));
    }

  template<typename _Fn, typename _Tp>
    constexpr bool __call_is_nt(__invoke_memobj_ref)
    {
      using _Up = typename __inv_unwrap<_Tp>::type;
      return noexcept(std::declval<_Up>().*std::declval<_Fn>());
    }

  template<typename _Fn, typename _Tp>
    constexpr bool __call_is_nt(__invoke_memobj_deref)
    {
      return noexcept((*std::declval<_Tp>()).*std::declval<_Fn>());
    }

  template<typename _Fn, typename... _Args>
    constexpr bool __call_is_nt(__invoke_other)
    {
      return noexcept(std::declval<_Fn>()(std::declval<_Args>()...));
    }

  template<typename _Result, typename _Fn, typename... _Args>
    struct __call_is_nothrow
    : __bool_constant<
 std::__call_is_nt<_Fn, _Args...>(typename _Result::__invoke_type{})
      >
    { };

  template<typename _Fn, typename... _Args>
    using __call_is_nothrow_
      = __call_is_nothrow<__invoke_result<_Fn, _Args...>, _Fn, _Args...>;


  template<typename _Fn, typename... _Args>
    struct __is_nothrow_invocable
    : __and_<__is_invocable<_Fn, _Args...>,
             __call_is_nothrow_<_Fn, _Args...>>::type
    { };

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"
  struct __nonesuchbase {};
  struct __nonesuch : private __nonesuchbase {
    ~__nonesuch() = delete;
    __nonesuch(__nonesuch const&) = delete;
    void operator=(__nonesuch const&) = delete;
  };
#pragma GCC diagnostic pop




  template<typename _Functor, typename... _ArgTypes>
    struct invoke_result
    : public __invoke_result<_Functor, _ArgTypes...>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Functor>{}),
 "_Functor must be a complete class or an unbounded array");
      static_assert((std::__is_complete_or_unbounded(
 __type_identity<_ArgTypes>{}) && ...),
 "each argument type must be a complete class or an unbounded array");
    };


  template<typename _Fn, typename... _Args>
    using invoke_result_t = typename invoke_result<_Fn, _Args...>::type;


  template<typename _Fn, typename... _ArgTypes>
    struct is_invocable
    : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),
 "_Fn must be a complete class or an unbounded array");
      static_assert((std::__is_complete_or_unbounded(
 __type_identity<_ArgTypes>{}) && ...),
 "each argument type must be a complete class or an unbounded array");
    };


  template<typename _Ret, typename _Fn, typename... _ArgTypes>
    struct is_invocable_r
    : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, _Ret>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),
 "_Fn must be a complete class or an unbounded array");
      static_assert((std::__is_complete_or_unbounded(
 __type_identity<_ArgTypes>{}) && ...),
 "each argument type must be a complete class or an unbounded array");
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Ret>{}),
 "_Ret must be a complete class or an unbounded array");
    };


  template<typename _Fn, typename... _ArgTypes>
    struct is_nothrow_invocable
    : __and_<__is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>,
      __call_is_nothrow_<_Fn, _ArgTypes...>>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),
 "_Fn must be a complete class or an unbounded array");
      static_assert((std::__is_complete_or_unbounded(
 __type_identity<_ArgTypes>{}) && ...),
 "each argument type must be a complete class or an unbounded array");
    };





  template<typename _Result, typename _Ret>
    using __is_nt_invocable_impl
      = typename __is_invocable_impl<_Result, _Ret>::__nothrow_conv;



  template<typename _Ret, typename _Fn, typename... _ArgTypes>
    struct is_nothrow_invocable_r
    : __and_<__is_nt_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, _Ret>,
             __call_is_nothrow_<_Fn, _ArgTypes...>>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),
 "_Fn must be a complete class or an unbounded array");
      static_assert((std::__is_complete_or_unbounded(
 __type_identity<_ArgTypes>{}) && ...),
 "each argument type must be a complete class or an unbounded array");
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Ret>{}),
 "_Ret must be a complete class or an unbounded array");
    };
# 3236 "D:/Programs/MinGW/include/c++/14.2.0/type_traits" 3
template <typename _Tp>
  inline constexpr bool is_void_v = is_void<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_null_pointer_v = is_null_pointer<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_integral_v = is_integral<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_floating_point_v = is_floating_point<_Tp>::value;


template <typename _Tp>
  inline constexpr bool is_array_v = __is_array(_Tp);
# 3257 "D:/Programs/MinGW/include/c++/14.2.0/type_traits" 3
template <typename _Tp>
  inline constexpr bool is_pointer_v = is_pointer<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_lvalue_reference_v = false;
template <typename _Tp>
  inline constexpr bool is_lvalue_reference_v<_Tp&> = true;
template <typename _Tp>
  inline constexpr bool is_rvalue_reference_v = false;
template <typename _Tp>
  inline constexpr bool is_rvalue_reference_v<_Tp&&> = true;


template <typename _Tp>
  inline constexpr bool is_member_object_pointer_v =
    __is_member_object_pointer(_Tp);







template <typename _Tp>
  inline constexpr bool is_member_function_pointer_v =
    __is_member_function_pointer(_Tp);






template <typename _Tp>
  inline constexpr bool is_enum_v = __is_enum(_Tp);
template <typename _Tp>
  inline constexpr bool is_union_v = __is_union(_Tp);
template <typename _Tp>
  inline constexpr bool is_class_v = __is_class(_Tp);



template <typename _Tp>
  inline constexpr bool is_reference_v = __is_reference(_Tp);
# 3308 "D:/Programs/MinGW/include/c++/14.2.0/type_traits" 3
template <typename _Tp>
  inline constexpr bool is_arithmetic_v = is_arithmetic<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_fundamental_v = is_fundamental<_Tp>::value;


template <typename _Tp>
  inline constexpr bool is_object_v = __is_object(_Tp);





template <typename _Tp>
  inline constexpr bool is_scalar_v = is_scalar<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_compound_v = !is_fundamental_v<_Tp>;


template <typename _Tp>
  inline constexpr bool is_member_pointer_v = __is_member_pointer(_Tp);





template <typename _Tp>
  inline constexpr bool is_const_v = false;
template <typename _Tp>
  inline constexpr bool is_const_v<const _Tp> = true;


template <typename _Tp>
  inline constexpr bool is_function_v = __is_function(_Tp);
# 3351 "D:/Programs/MinGW/include/c++/14.2.0/type_traits" 3
template <typename _Tp>
  inline constexpr bool is_volatile_v = false;
template <typename _Tp>
  inline constexpr bool is_volatile_v<volatile _Tp> = true;

template <typename _Tp>
  inline constexpr bool is_trivial_v = __is_trivial(_Tp);
template <typename _Tp>
  inline constexpr bool is_trivially_copyable_v = __is_trivially_copyable(_Tp);
template <typename _Tp>
  inline constexpr bool is_standard_layout_v = __is_standard_layout(_Tp);
template <typename _Tp>
  __attribute__ ((__deprecated__ ("use '" "is_standard_layout_v && is_trivial_v" "' instead")))
  inline constexpr bool is_pod_v = __is_pod(_Tp);
template <typename _Tp>
  [[__deprecated__]]
  inline constexpr bool is_literal_type_v = __is_literal_type(_Tp);
template <typename _Tp>
  inline constexpr bool is_empty_v = __is_empty(_Tp);
template <typename _Tp>
  inline constexpr bool is_polymorphic_v = __is_polymorphic(_Tp);
template <typename _Tp>
  inline constexpr bool is_abstract_v = __is_abstract(_Tp);
template <typename _Tp>
  inline constexpr bool is_final_v = __is_final(_Tp);

template <typename _Tp>
  inline constexpr bool is_signed_v = is_signed<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_unsigned_v = is_unsigned<_Tp>::value;

template <typename _Tp, typename... _Args>
  inline constexpr bool is_constructible_v = __is_constructible(_Tp, _Args...);
template <typename _Tp>
  inline constexpr bool is_default_constructible_v = __is_constructible(_Tp);
template <typename _Tp>
  inline constexpr bool is_copy_constructible_v
    = __is_constructible(_Tp, __add_lval_ref_t<const _Tp>);
template <typename _Tp>
  inline constexpr bool is_move_constructible_v
    = __is_constructible(_Tp, __add_rval_ref_t<_Tp>);

template <typename _Tp, typename _Up>
  inline constexpr bool is_assignable_v = __is_assignable(_Tp, _Up);
template <typename _Tp>
  inline constexpr bool is_copy_assignable_v
    = __is_assignable(__add_lval_ref_t<_Tp>, __add_lval_ref_t<const _Tp>);
template <typename _Tp>
  inline constexpr bool is_move_assignable_v
    = __is_assignable(__add_lval_ref_t<_Tp>, __add_rval_ref_t<_Tp>);

template <typename _Tp>
  inline constexpr bool is_destructible_v = is_destructible<_Tp>::value;

template <typename _Tp, typename... _Args>
  inline constexpr bool is_trivially_constructible_v
    = __is_trivially_constructible(_Tp, _Args...);
template <typename _Tp>
  inline constexpr bool is_trivially_default_constructible_v
    = __is_trivially_constructible(_Tp);
template <typename _Tp>
  inline constexpr bool is_trivially_copy_constructible_v
    = __is_trivially_constructible(_Tp, __add_lval_ref_t<const _Tp>);
template <typename _Tp>
  inline constexpr bool is_trivially_move_constructible_v
    = __is_trivially_constructible(_Tp, __add_rval_ref_t<_Tp>);

template <typename _Tp, typename _Up>
  inline constexpr bool is_trivially_assignable_v
    = __is_trivially_assignable(_Tp, _Up);
template <typename _Tp>
  inline constexpr bool is_trivially_copy_assignable_v
    = __is_trivially_assignable(__add_lval_ref_t<_Tp>,
    __add_lval_ref_t<const _Tp>);
template <typename _Tp>
  inline constexpr bool is_trivially_move_assignable_v
    = __is_trivially_assignable(__add_lval_ref_t<_Tp>,
    __add_rval_ref_t<_Tp>);


template <typename _Tp>
  inline constexpr bool is_trivially_destructible_v = false;

template <typename _Tp>
  requires (!is_reference_v<_Tp>) && requires (_Tp& __t) { __t.~_Tp(); }
  inline constexpr bool is_trivially_destructible_v<_Tp>
    = __has_trivial_destructor(_Tp);
template <typename _Tp>
  inline constexpr bool is_trivially_destructible_v<_Tp&> = true;
template <typename _Tp>
  inline constexpr bool is_trivially_destructible_v<_Tp&&> = true;
template <typename _Tp, size_t _Nm>
  inline constexpr bool is_trivially_destructible_v<_Tp[_Nm]>
    = is_trivially_destructible_v<_Tp>;






template <typename _Tp, typename... _Args>
  inline constexpr bool is_nothrow_constructible_v
    = __is_nothrow_constructible(_Tp, _Args...);
template <typename _Tp>
  inline constexpr bool is_nothrow_default_constructible_v
    = __is_nothrow_constructible(_Tp);
template <typename _Tp>
  inline constexpr bool is_nothrow_copy_constructible_v
    = __is_nothrow_constructible(_Tp, __add_lval_ref_t<const _Tp>);
template <typename _Tp>
  inline constexpr bool is_nothrow_move_constructible_v
    = __is_nothrow_constructible(_Tp, __add_rval_ref_t<_Tp>);

template <typename _Tp, typename _Up>
  inline constexpr bool is_nothrow_assignable_v
    = __is_nothrow_assignable(_Tp, _Up);
template <typename _Tp>
  inline constexpr bool is_nothrow_copy_assignable_v
    = __is_nothrow_assignable(__add_lval_ref_t<_Tp>,
         __add_lval_ref_t<const _Tp>);
template <typename _Tp>
  inline constexpr bool is_nothrow_move_assignable_v
    = __is_nothrow_assignable(__add_lval_ref_t<_Tp>, __add_rval_ref_t<_Tp>);

template <typename _Tp>
  inline constexpr bool is_nothrow_destructible_v =
    is_nothrow_destructible<_Tp>::value;

template <typename _Tp>
  inline constexpr bool has_virtual_destructor_v
    = __has_virtual_destructor(_Tp);

template <typename _Tp>
  inline constexpr size_t alignment_of_v = alignment_of<_Tp>::value;

template <typename _Tp>
  inline constexpr size_t rank_v = 0;
template <typename _Tp, size_t _Size>
  inline constexpr size_t rank_v<_Tp[_Size]> = 1 + rank_v<_Tp>;
template <typename _Tp>
  inline constexpr size_t rank_v<_Tp[]> = 1 + rank_v<_Tp>;

template <typename _Tp, unsigned _Idx = 0>
  inline constexpr size_t extent_v = 0;
template <typename _Tp, size_t _Size>
  inline constexpr size_t extent_v<_Tp[_Size], 0> = _Size;
template <typename _Tp, unsigned _Idx, size_t _Size>
  inline constexpr size_t extent_v<_Tp[_Size], _Idx> = extent_v<_Tp, _Idx - 1>;
template <typename _Tp>
  inline constexpr size_t extent_v<_Tp[], 0> = 0;
template <typename _Tp, unsigned _Idx>
  inline constexpr size_t extent_v<_Tp[], _Idx> = extent_v<_Tp, _Idx - 1>;


template <typename _Tp, typename _Up>
  inline constexpr bool is_same_v = __is_same(_Tp, _Up);






template <typename _Base, typename _Derived>
  inline constexpr bool is_base_of_v = __is_base_of(_Base, _Derived);

template <typename _From, typename _To>
  inline constexpr bool is_convertible_v = __is_convertible(_From, _To);




template<typename _Fn, typename... _Args>
  inline constexpr bool is_invocable_v = is_invocable<_Fn, _Args...>::value;
template<typename _Fn, typename... _Args>
  inline constexpr bool is_nothrow_invocable_v
    = is_nothrow_invocable<_Fn, _Args...>::value;
template<typename _Ret, typename _Fn, typename... _Args>
  inline constexpr bool is_invocable_r_v
    = is_invocable_r<_Ret, _Fn, _Args...>::value;
template<typename _Ret, typename _Fn, typename... _Args>
  inline constexpr bool is_nothrow_invocable_r_v
    = is_nothrow_invocable_r<_Ret, _Fn, _Args...>::value;






  template<typename _Tp>
    struct has_unique_object_representations
    : bool_constant<__has_unique_object_representations(
      remove_cv_t<remove_all_extents_t<_Tp>>
      )>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };



  template<typename _Tp>
    inline constexpr bool has_unique_object_representations_v
      = has_unique_object_representations<_Tp>::value;






  template<typename _Tp>
    struct is_aggregate
    : bool_constant<__is_aggregate(remove_cv_t<_Tp>)>
    { };






  template<typename _Tp>
    inline constexpr bool is_aggregate_v = __is_aggregate(remove_cv_t<_Tp>);
# 3581 "D:/Programs/MinGW/include/c++/14.2.0/type_traits" 3
  template<typename _Tp>
    struct remove_cvref
    { using type = __remove_cvref(_Tp); };
# 3598 "D:/Programs/MinGW/include/c++/14.2.0/type_traits" 3
  template<typename _Tp>
    using remove_cvref_t = typename remove_cvref<_Tp>::type;
# 3608 "D:/Programs/MinGW/include/c++/14.2.0/type_traits" 3
  template<typename _Tp>
    struct type_identity { using type = _Tp; };

  template<typename _Tp>
    using type_identity_t = typename type_identity<_Tp>::type;
# 3621 "D:/Programs/MinGW/include/c++/14.2.0/type_traits" 3
  template<typename _Tp>
    struct unwrap_reference { using type = _Tp; };

  template<typename _Tp>
    struct unwrap_reference<reference_wrapper<_Tp>> { using type = _Tp&; };

  template<typename _Tp>
    using unwrap_reference_t = typename unwrap_reference<_Tp>::type;






  template<typename _Tp>
    struct unwrap_ref_decay { using type = unwrap_reference_t<decay_t<_Tp>>; };

  template<typename _Tp>
    using unwrap_ref_decay_t = typename unwrap_ref_decay<_Tp>::type;
# 3648 "D:/Programs/MinGW/include/c++/14.2.0/type_traits" 3
  template<typename _Tp>
    inline constexpr bool is_bounded_array_v = __is_bounded_array(_Tp);
# 3661 "D:/Programs/MinGW/include/c++/14.2.0/type_traits" 3
  template<typename _Tp>
    inline constexpr bool is_unbounded_array_v = false;

  template<typename _Tp>
    inline constexpr bool is_unbounded_array_v<_Tp[]> = true;



  template<typename _Tp>
    struct is_bounded_array
    : public bool_constant<is_bounded_array_v<_Tp>>
    { };



  template<typename _Tp>
    struct is_unbounded_array
    : public bool_constant<is_unbounded_array_v<_Tp>>
    { };





  template<typename _Tp, typename _Up>
    struct is_layout_compatible
    : bool_constant<__is_layout_compatible(_Tp, _Up)>
    { };



  template<typename _Tp, typename _Up>
    constexpr bool is_layout_compatible_v
      = __is_layout_compatible(_Tp, _Up);







  template<typename _S1, typename _S2, typename _M1, typename _M2>
    constexpr bool
    is_corresponding_member(_M1 _S1::*__m1, _M2 _S2::*__m2) noexcept
    { return __builtin_is_corresponding_member(__m1, __m2); }







  template<typename _Base, typename _Derived>
    struct is_pointer_interconvertible_base_of
    : bool_constant<__is_pointer_interconvertible_base_of(_Base, _Derived)>
    { };



  template<typename _Base, typename _Derived>
    constexpr bool is_pointer_interconvertible_base_of_v
      = __is_pointer_interconvertible_base_of(_Base, _Derived);
# 3732 "D:/Programs/MinGW/include/c++/14.2.0/type_traits" 3
  template<typename _Tp, typename _Mem>
    constexpr bool
    is_pointer_interconvertible_with_class(_Mem _Tp::*__mp) noexcept
    { return __builtin_is_pointer_interconvertible_with_class(__mp); }
# 3744 "D:/Programs/MinGW/include/c++/14.2.0/type_traits" 3
  template<typename _Tp>
    struct is_scoped_enum
    : bool_constant<__is_scoped_enum(_Tp)>
    { };
# 3765 "D:/Programs/MinGW/include/c++/14.2.0/type_traits" 3
  template<typename _Tp>
    inline constexpr bool is_scoped_enum_v = __is_scoped_enum(_Tp);
# 3778 "D:/Programs/MinGW/include/c++/14.2.0/type_traits" 3
  template<typename _Tp, typename _Up>
    struct reference_constructs_from_temporary
    : public bool_constant<__reference_constructs_from_temporary(_Tp, _Up)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{})
      && std::__is_complete_or_unbounded(__type_identity<_Up>{}),
 "template argument must be a complete class or an unbounded array");
    };





  template<typename _Tp, typename _Up>
    struct reference_converts_from_temporary
    : public bool_constant<__reference_converts_from_temporary(_Tp, _Up)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{})
      && std::__is_complete_or_unbounded(__type_identity<_Up>{}),
 "template argument must be a complete class or an unbounded array");
    };



  template<typename _Tp, typename _Up>
    inline constexpr bool reference_constructs_from_temporary_v
      = reference_constructs_from_temporary<_Tp, _Up>::value;



  template<typename _Tp, typename _Up>
    inline constexpr bool reference_converts_from_temporary_v
      = reference_converts_from_temporary<_Tp, _Up>::value;





  constexpr inline bool
  is_constant_evaluated() noexcept
  {

    if consteval { return true; } else { return false; }



  }




  template<typename _From, typename _To>
    using __copy_cv = typename __match_cv_qualifiers<_From, _To>::__type;

  template<typename _Xp, typename _Yp>
    using __cond_res
      = decltype(false ? declval<_Xp(&)()>()() : declval<_Yp(&)()>()());

  template<typename _Ap, typename _Bp, typename = void>
    struct __common_ref_impl
    { };


  template<typename _Ap, typename _Bp>
    using __common_ref = typename __common_ref_impl<_Ap, _Bp>::type;


  template<typename _Xp, typename _Yp>
    using __condres_cvref
      = __cond_res<__copy_cv<_Xp, _Yp>&, __copy_cv<_Yp, _Xp>&>;


  template<typename _Xp, typename _Yp>
    struct __common_ref_impl<_Xp&, _Yp&, __void_t<__condres_cvref<_Xp, _Yp>>>
    : enable_if<is_reference_v<__condres_cvref<_Xp, _Yp>>,
  __condres_cvref<_Xp, _Yp>>
    { };


  template<typename _Xp, typename _Yp>
    using __common_ref_C = remove_reference_t<__common_ref<_Xp&, _Yp&>>&&;


  template<typename _Xp, typename _Yp>
    struct __common_ref_impl<_Xp&&, _Yp&&,
      _Require<is_convertible<_Xp&&, __common_ref_C<_Xp, _Yp>>,
        is_convertible<_Yp&&, __common_ref_C<_Xp, _Yp>>>>
    { using type = __common_ref_C<_Xp, _Yp>; };


  template<typename _Xp, typename _Yp>
    using __common_ref_D = __common_ref<const _Xp&, _Yp&>;


  template<typename _Xp, typename _Yp>
    struct __common_ref_impl<_Xp&&, _Yp&,
      _Require<is_convertible<_Xp&&, __common_ref_D<_Xp, _Yp>>>>
    { using type = __common_ref_D<_Xp, _Yp>; };


  template<typename _Xp, typename _Yp>
    struct __common_ref_impl<_Xp&, _Yp&&>
    : __common_ref_impl<_Yp&&, _Xp&>
    { };


  template<typename _Tp, typename _Up,
    template<typename> class _TQual, template<typename> class _UQual>
    struct basic_common_reference
    { };


  template<typename _Tp>
    struct __xref
    { template<typename _Up> using __type = __copy_cv<_Tp, _Up>; };

  template<typename _Tp>
    struct __xref<_Tp&>
    { template<typename _Up> using __type = __copy_cv<_Tp, _Up>&; };

  template<typename _Tp>
    struct __xref<_Tp&&>
    { template<typename _Up> using __type = __copy_cv<_Tp, _Up>&&; };

  template<typename _Tp1, typename _Tp2>
    using __basic_common_ref
      = typename basic_common_reference<remove_cvref_t<_Tp1>,
     remove_cvref_t<_Tp2>,
     __xref<_Tp1>::template __type,
     __xref<_Tp2>::template __type>::type;


  template<typename... _Tp>
    struct common_reference;

  template<typename... _Tp>
    using common_reference_t = typename common_reference<_Tp...>::type;


  template<>
    struct common_reference<>
    { };


  template<typename _Tp0>
    struct common_reference<_Tp0>
    { using type = _Tp0; };


  template<typename _Tp1, typename _Tp2, int _Bullet = 1, typename = void>
    struct __common_reference_impl
    : __common_reference_impl<_Tp1, _Tp2, _Bullet + 1>
    { };


  template<typename _Tp1, typename _Tp2>
    struct common_reference<_Tp1, _Tp2>
    : __common_reference_impl<_Tp1, _Tp2>
    { };


  template<typename _Tp1, typename _Tp2>
    struct __common_reference_impl<_Tp1&, _Tp2&, 1,
       void_t<__common_ref<_Tp1&, _Tp2&>>>
    { using type = __common_ref<_Tp1&, _Tp2&>; };

  template<typename _Tp1, typename _Tp2>
    struct __common_reference_impl<_Tp1&&, _Tp2&&, 1,
       void_t<__common_ref<_Tp1&&, _Tp2&&>>>
    { using type = __common_ref<_Tp1&&, _Tp2&&>; };

  template<typename _Tp1, typename _Tp2>
    struct __common_reference_impl<_Tp1&, _Tp2&&, 1,
       void_t<__common_ref<_Tp1&, _Tp2&&>>>
    { using type = __common_ref<_Tp1&, _Tp2&&>; };

  template<typename _Tp1, typename _Tp2>
    struct __common_reference_impl<_Tp1&&, _Tp2&, 1,
       void_t<__common_ref<_Tp1&&, _Tp2&>>>
    { using type = __common_ref<_Tp1&&, _Tp2&>; };


  template<typename _Tp1, typename _Tp2>
    struct __common_reference_impl<_Tp1, _Tp2, 2,
       void_t<__basic_common_ref<_Tp1, _Tp2>>>
    { using type = __basic_common_ref<_Tp1, _Tp2>; };


  template<typename _Tp1, typename _Tp2>
    struct __common_reference_impl<_Tp1, _Tp2, 3,
       void_t<__cond_res<_Tp1, _Tp2>>>
    { using type = __cond_res<_Tp1, _Tp2>; };


  template<typename _Tp1, typename _Tp2>
    struct __common_reference_impl<_Tp1, _Tp2, 4,
       void_t<common_type_t<_Tp1, _Tp2>>>
    { using type = common_type_t<_Tp1, _Tp2>; };


  template<typename _Tp1, typename _Tp2>
    struct __common_reference_impl<_Tp1, _Tp2, 5, void>
    { };


  template<typename _Tp1, typename _Tp2, typename... _Rest>
    struct common_reference<_Tp1, _Tp2, _Rest...>
    : __common_type_fold<common_reference<_Tp1, _Tp2>,
    __common_type_pack<_Rest...>>
    { };


  template<typename _Tp1, typename _Tp2, typename... _Rest>
    struct __common_type_fold<common_reference<_Tp1, _Tp2>,
         __common_type_pack<_Rest...>,
         void_t<common_reference_t<_Tp1, _Tp2>>>
    : public common_reference<common_reference_t<_Tp1, _Tp2>, _Rest...>
    { };







}
# 47 "D:/Programs/MinGW/include/c++/14.2.0/concepts" 2 3

namespace std
{




  namespace __detail
  {
    template<typename _Tp, typename _Up>
      concept __same_as = std::is_same_v<_Tp, _Up>;
  }


  template<typename _Tp, typename _Up>
    concept same_as
      = __detail::__same_as<_Tp, _Up> && __detail::__same_as<_Up, _Tp>;

  namespace __detail
  {
    template<typename _Tp, typename _Up>
      concept __different_from
 = !same_as<remove_cvref_t<_Tp>, remove_cvref_t<_Up>>;
  }


  template<typename _Derived, typename _Base>
    concept derived_from = __is_base_of(_Base, _Derived)
      && is_convertible_v<const volatile _Derived*, const volatile _Base*>;


  template<typename _From, typename _To>
    concept convertible_to = is_convertible_v<_From, _To>
      && requires { static_cast<_To>(std::declval<_From>()); };


  template<typename _Tp, typename _Up>
    concept common_reference_with
      = same_as<common_reference_t<_Tp, _Up>, common_reference_t<_Up, _Tp>>
      && convertible_to<_Tp, common_reference_t<_Tp, _Up>>
      && convertible_to<_Up, common_reference_t<_Tp, _Up>>;


  template<typename _Tp, typename _Up>
    concept common_with
      = same_as<common_type_t<_Tp, _Up>, common_type_t<_Up, _Tp>>
      && requires {
 static_cast<common_type_t<_Tp, _Up>>(std::declval<_Tp>());
 static_cast<common_type_t<_Tp, _Up>>(std::declval<_Up>());
      }
      && common_reference_with<add_lvalue_reference_t<const _Tp>,
          add_lvalue_reference_t<const _Up>>
      && common_reference_with<add_lvalue_reference_t<common_type_t<_Tp, _Up>>,
          common_reference_t<
     add_lvalue_reference_t<const _Tp>,
     add_lvalue_reference_t<const _Up>>>;



  template<typename _Tp>
    concept integral = is_integral_v<_Tp>;

  template<typename _Tp>
    concept signed_integral = integral<_Tp> && is_signed_v<_Tp>;

  template<typename _Tp>
    concept unsigned_integral = integral<_Tp> && !signed_integral<_Tp>;

  template<typename _Tp>
    concept floating_point = is_floating_point_v<_Tp>;

  namespace __detail
  {
    template<typename _Tp>
      using __cref = const remove_reference_t<_Tp>&;

    template<typename _Tp>
      concept __class_or_enum
 = is_class_v<_Tp> || is_union_v<_Tp> || is_enum_v<_Tp>;

    template<typename _Tp>
      constexpr bool __destructible_impl = false;
    template<typename _Tp>
      requires requires(_Tp& __t) { { __t.~_Tp() } noexcept; }
      constexpr bool __destructible_impl<_Tp> = true;

    template<typename _Tp>
      constexpr bool __destructible = __destructible_impl<_Tp>;
    template<typename _Tp>
      constexpr bool __destructible<_Tp&> = true;
    template<typename _Tp>
      constexpr bool __destructible<_Tp&&> = true;
    template<typename _Tp, size_t _Nm>
      constexpr bool __destructible<_Tp[_Nm]> = __destructible<_Tp>;

  }


  template<typename _Lhs, typename _Rhs>
    concept assignable_from
      = is_lvalue_reference_v<_Lhs>
      && common_reference_with<__detail::__cref<_Lhs>, __detail::__cref<_Rhs>>
      && requires(_Lhs __lhs, _Rhs&& __rhs) {
 { __lhs = static_cast<_Rhs&&>(__rhs) } -> same_as<_Lhs>;
      };


  template<typename _Tp>
    concept destructible = __detail::__destructible<_Tp>;


  template<typename _Tp, typename... _Args>
    concept constructible_from
      = destructible<_Tp> && is_constructible_v<_Tp, _Args...>;


  template<typename _Tp>
    concept default_initializable = constructible_from<_Tp>
      && requires
      {
 _Tp{};
 (void) ::new _Tp;
      };


  template<typename _Tp>
    concept move_constructible
    = constructible_from<_Tp, _Tp> && convertible_to<_Tp, _Tp>;


  template<typename _Tp>
    concept copy_constructible
      = move_constructible<_Tp>
      && constructible_from<_Tp, _Tp&> && convertible_to<_Tp&, _Tp>
      && constructible_from<_Tp, const _Tp&> && convertible_to<const _Tp&, _Tp>
      && constructible_from<_Tp, const _Tp> && convertible_to<const _Tp, _Tp>;



  namespace ranges
  {

    namespace __swap
    {
      template<typename _Tp> void swap(_Tp&, _Tp&) = delete;

      template<typename _Tp, typename _Up>
 concept __adl_swap
   = (std::__detail::__class_or_enum<remove_reference_t<_Tp>>
     || std::__detail::__class_or_enum<remove_reference_t<_Up>>)
   && requires(_Tp&& __t, _Up&& __u) {
     swap(static_cast<_Tp&&>(__t), static_cast<_Up&&>(__u));
   };

      struct _Swap
      {
      private:
 template<typename _Tp, typename _Up>
   static constexpr bool
   _S_noexcept()
   {
     if constexpr (__adl_swap<_Tp, _Up>)
       return noexcept(swap(std::declval<_Tp>(), std::declval<_Up>()));
     else
       return is_nothrow_move_constructible_v<remove_reference_t<_Tp>>
     && is_nothrow_move_assignable_v<remove_reference_t<_Tp>>;
   }

      public:
 template<typename _Tp, typename _Up>
   requires __adl_swap<_Tp, _Up>
   || (same_as<_Tp, _Up> && is_lvalue_reference_v<_Tp>
       && move_constructible<remove_reference_t<_Tp>>
       && assignable_from<_Tp, remove_reference_t<_Tp>>)
   constexpr void
   operator()(_Tp&& __t, _Up&& __u) const
   noexcept(_S_noexcept<_Tp, _Up>())
   {
     if constexpr (__adl_swap<_Tp, _Up>)
       swap(static_cast<_Tp&&>(__t), static_cast<_Up&&>(__u));
     else
       {
  auto __tmp = static_cast<remove_reference_t<_Tp>&&>(__t);
  __t = static_cast<remove_reference_t<_Tp>&&>(__u);
  __u = static_cast<remove_reference_t<_Tp>&&>(__tmp);
       }
   }

 template<typename _Tp, typename _Up, size_t _Num>
   requires requires(const _Swap& __swap, _Tp& __e1, _Up& __e2) {
     __swap(__e1, __e2);
   }
   constexpr void
   operator()(_Tp (&__e1)[_Num], _Up (&__e2)[_Num]) const
   noexcept(noexcept(std::declval<const _Swap&>()(*__e1, *__e2)))
   {
     for (size_t __n = 0; __n < _Num; ++__n)
       (*this)(__e1[__n], __e2[__n]);
   }
      };
    }


    inline namespace _Cpo {
      inline constexpr __swap::_Swap swap{};
    }
  }

  template<typename _Tp>
    concept swappable
      = requires(_Tp& __a, _Tp& __b) { ranges::swap(__a, __b); };

  template<typename _Tp, typename _Up>
    concept swappable_with = common_reference_with<_Tp, _Up>
      && requires(_Tp&& __t, _Up&& __u) {
 ranges::swap(static_cast<_Tp&&>(__t), static_cast<_Tp&&>(__t));
 ranges::swap(static_cast<_Up&&>(__u), static_cast<_Up&&>(__u));
 ranges::swap(static_cast<_Tp&&>(__t), static_cast<_Up&&>(__u));
 ranges::swap(static_cast<_Up&&>(__u), static_cast<_Tp&&>(__t));
      };



  template<typename _Tp>
    concept movable = is_object_v<_Tp> && move_constructible<_Tp>
      && assignable_from<_Tp&, _Tp> && swappable<_Tp>;

  template<typename _Tp>
    concept copyable = copy_constructible<_Tp> && movable<_Tp>
      && assignable_from<_Tp&, _Tp&> && assignable_from<_Tp&, const _Tp&>
      && assignable_from<_Tp&, const _Tp>;

  template<typename _Tp>
    concept semiregular = copyable<_Tp> && default_initializable<_Tp>;




  namespace __detail
  {
    template<typename _Tp>
      concept __boolean_testable_impl = convertible_to<_Tp, bool>;

    template<typename _Tp>
      concept __boolean_testable
 = __boolean_testable_impl<_Tp>
   && requires(_Tp&& __t)
   { { !static_cast<_Tp&&>(__t) } -> __boolean_testable_impl; };
  }



  namespace __detail
  {
    template<typename _Tp, typename _Up>
      concept __weakly_eq_cmp_with
 = requires(__detail::__cref<_Tp> __t, __detail::__cref<_Up> __u) {
   { __t == __u } -> __boolean_testable;
   { __t != __u } -> __boolean_testable;
   { __u == __t } -> __boolean_testable;
   { __u != __t } -> __boolean_testable;
 };
  }

  template<typename _Tp>
    concept equality_comparable = __detail::__weakly_eq_cmp_with<_Tp, _Tp>;

  template<typename _Tp, typename _Up>
    concept equality_comparable_with
      = equality_comparable<_Tp> && equality_comparable<_Up>
      && common_reference_with<__detail::__cref<_Tp>, __detail::__cref<_Up>>
      && equality_comparable<common_reference_t<__detail::__cref<_Tp>,
      __detail::__cref<_Up>>>
      && __detail::__weakly_eq_cmp_with<_Tp, _Up>;

  namespace __detail
  {
    template<typename _Tp, typename _Up>
      concept __partially_ordered_with
 = requires(const remove_reference_t<_Tp>& __t,
     const remove_reference_t<_Up>& __u) {
   { __t < __u } -> __boolean_testable;
   { __t > __u } -> __boolean_testable;
   { __t <= __u } -> __boolean_testable;
   { __t >= __u } -> __boolean_testable;
   { __u < __t } -> __boolean_testable;
   { __u > __t } -> __boolean_testable;
   { __u <= __t } -> __boolean_testable;
   { __u >= __t } -> __boolean_testable;
 };
  }


  template<typename _Tp>
    concept totally_ordered
      = equality_comparable<_Tp>
      && __detail::__partially_ordered_with<_Tp, _Tp>;

  template<typename _Tp, typename _Up>
    concept totally_ordered_with
      = totally_ordered<_Tp> && totally_ordered<_Up>
      && equality_comparable_with<_Tp, _Up>
      && totally_ordered<common_reference_t<__detail::__cref<_Tp>,
         __detail::__cref<_Up>>>
      && __detail::__partially_ordered_with<_Tp, _Up>;

  template<typename _Tp>
    concept regular = semiregular<_Tp> && equality_comparable<_Tp>;




  template<typename _Fn, typename... _Args>
    concept invocable = is_invocable_v<_Fn, _Args...>;


  template<typename _Fn, typename... _Args>
    concept regular_invocable = invocable<_Fn, _Args...>;


  template<typename _Fn, typename... _Args>
    concept predicate = regular_invocable<_Fn, _Args...>
      && __detail::__boolean_testable<invoke_result_t<_Fn, _Args...>>;


  template<typename _Rel, typename _Tp, typename _Up>
    concept relation
      = predicate<_Rel, _Tp, _Tp> && predicate<_Rel, _Up, _Up>
      && predicate<_Rel, _Tp, _Up> && predicate<_Rel, _Up, _Tp>;


  template<typename _Rel, typename _Tp, typename _Up>
    concept equivalence_relation = relation<_Rel, _Tp, _Up>;


  template<typename _Rel, typename _Tp, typename _Up>
    concept strict_weak_order = relation<_Rel, _Tp, _Up>;


}
# 41 "D:/Programs/MinGW/include/c++/14.2.0/compare" 2 3

namespace std
{


  namespace __cmp_cat
  {
    using type = signed char;

    enum class _Ord : type { equivalent = 0, less = -1, greater = 1 };

    enum class _Ncmp : type { _Unordered = 2 };

    struct __unspec
    {
      consteval __unspec(__unspec*) noexcept { }
    };
  }

  class partial_ordering
  {

    __cmp_cat::type _M_value;

    constexpr explicit
    partial_ordering(__cmp_cat::_Ord __v) noexcept
    : _M_value(__cmp_cat::type(__v))
    { }

    constexpr explicit
    partial_ordering(__cmp_cat::_Ncmp __v) noexcept
    : _M_value(__cmp_cat::type(__v))
    { }

    friend class weak_ordering;
    friend class strong_ordering;

  public:

    static const partial_ordering less;
    static const partial_ordering equivalent;
    static const partial_ordering greater;
    static const partial_ordering unordered;


    [[nodiscard]]
    friend constexpr bool
    operator==(partial_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value == 0; }

    [[nodiscard]]
    friend constexpr bool
    operator==(partial_ordering, partial_ordering) noexcept = default;

    [[nodiscard]]
    friend constexpr bool
    operator< (partial_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value == -1; }

    [[nodiscard]]
    friend constexpr bool
    operator> (partial_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value == 1; }

    [[nodiscard]]
    friend constexpr bool
    operator<=(partial_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value <= 0; }

    [[nodiscard]]
    friend constexpr bool
    operator>=(partial_ordering __v, __cmp_cat::__unspec) noexcept
    { return __cmp_cat::type(__v._M_value & 1) == __v._M_value; }

    [[nodiscard]]
    friend constexpr bool
    operator< (__cmp_cat::__unspec, partial_ordering __v) noexcept
    { return __v._M_value == 1; }

    [[nodiscard]]
    friend constexpr bool
    operator> (__cmp_cat::__unspec, partial_ordering __v) noexcept
    { return __v._M_value == -1; }

    [[nodiscard]]
    friend constexpr bool
    operator<=(__cmp_cat::__unspec, partial_ordering __v) noexcept
    { return __cmp_cat::type(__v._M_value & 1) == __v._M_value; }

    [[nodiscard]]
    friend constexpr bool
    operator>=(__cmp_cat::__unspec, partial_ordering __v) noexcept
    { return 0 >= __v._M_value; }

    [[nodiscard]]
    friend constexpr partial_ordering
    operator<=>(partial_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v; }

    [[nodiscard]]
    friend constexpr partial_ordering
    operator<=>(__cmp_cat::__unspec, partial_ordering __v) noexcept
    {
      if (__v._M_value & 1)
 return partial_ordering(__cmp_cat::_Ord(-__v._M_value));
      else
 return __v;
    }
  };


  inline constexpr partial_ordering
  partial_ordering::less(__cmp_cat::_Ord::less);

  inline constexpr partial_ordering
  partial_ordering::equivalent(__cmp_cat::_Ord::equivalent);

  inline constexpr partial_ordering
  partial_ordering::greater(__cmp_cat::_Ord::greater);

  inline constexpr partial_ordering
  partial_ordering::unordered(__cmp_cat::_Ncmp::_Unordered);

  class weak_ordering
  {
    __cmp_cat::type _M_value;

    constexpr explicit
    weak_ordering(__cmp_cat::_Ord __v) noexcept : _M_value(__cmp_cat::type(__v))
    { }

    friend class strong_ordering;

  public:

    static const weak_ordering less;
    static const weak_ordering equivalent;
    static const weak_ordering greater;

    [[nodiscard]]
    constexpr operator partial_ordering() const noexcept
    { return partial_ordering(__cmp_cat::_Ord(_M_value)); }


    [[nodiscard]]
    friend constexpr bool
    operator==(weak_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value == 0; }

    [[nodiscard]]
    friend constexpr bool
    operator==(weak_ordering, weak_ordering) noexcept = default;

    [[nodiscard]]
    friend constexpr bool
    operator< (weak_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value < 0; }

    [[nodiscard]]
    friend constexpr bool
    operator> (weak_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value > 0; }

    [[nodiscard]]
    friend constexpr bool
    operator<=(weak_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value <= 0; }

    [[nodiscard]]
    friend constexpr bool
    operator>=(weak_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value >= 0; }

    [[nodiscard]]
    friend constexpr bool
    operator< (__cmp_cat::__unspec, weak_ordering __v) noexcept
    { return 0 < __v._M_value; }

    [[nodiscard]]
    friend constexpr bool
    operator> (__cmp_cat::__unspec, weak_ordering __v) noexcept
    { return 0 > __v._M_value; }

    [[nodiscard]]
    friend constexpr bool
    operator<=(__cmp_cat::__unspec, weak_ordering __v) noexcept
    { return 0 <= __v._M_value; }

    [[nodiscard]]
    friend constexpr bool
    operator>=(__cmp_cat::__unspec, weak_ordering __v) noexcept
    { return 0 >= __v._M_value; }

    [[nodiscard]]
    friend constexpr weak_ordering
    operator<=>(weak_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v; }

    [[nodiscard]]
    friend constexpr weak_ordering
    operator<=>(__cmp_cat::__unspec, weak_ordering __v) noexcept
    { return weak_ordering(__cmp_cat::_Ord(-__v._M_value)); }
  };


  inline constexpr weak_ordering
  weak_ordering::less(__cmp_cat::_Ord::less);

  inline constexpr weak_ordering
  weak_ordering::equivalent(__cmp_cat::_Ord::equivalent);

  inline constexpr weak_ordering
  weak_ordering::greater(__cmp_cat::_Ord::greater);

  class strong_ordering
  {
    __cmp_cat::type _M_value;

    constexpr explicit
    strong_ordering(__cmp_cat::_Ord __v) noexcept
    : _M_value(__cmp_cat::type(__v))
    { }

  public:

    static const strong_ordering less;
    static const strong_ordering equal;
    static const strong_ordering equivalent;
    static const strong_ordering greater;

    [[nodiscard]]
    constexpr operator partial_ordering() const noexcept
    { return partial_ordering(__cmp_cat::_Ord(_M_value)); }

    [[nodiscard]]
    constexpr operator weak_ordering() const noexcept
    { return weak_ordering(__cmp_cat::_Ord(_M_value)); }


    [[nodiscard]]
    friend constexpr bool
    operator==(strong_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value == 0; }

    [[nodiscard]]
    friend constexpr bool
    operator==(strong_ordering, strong_ordering) noexcept = default;

    [[nodiscard]]
    friend constexpr bool
    operator< (strong_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value < 0; }

    [[nodiscard]]
    friend constexpr bool
    operator> (strong_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value > 0; }

    [[nodiscard]]
    friend constexpr bool
    operator<=(strong_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value <= 0; }

    [[nodiscard]]
    friend constexpr bool
    operator>=(strong_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value >= 0; }

    [[nodiscard]]
    friend constexpr bool
    operator< (__cmp_cat::__unspec, strong_ordering __v) noexcept
    { return 0 < __v._M_value; }

    [[nodiscard]]
    friend constexpr bool
    operator> (__cmp_cat::__unspec, strong_ordering __v) noexcept
    { return 0 > __v._M_value; }

    [[nodiscard]]
    friend constexpr bool
    operator<=(__cmp_cat::__unspec, strong_ordering __v) noexcept
    { return 0 <= __v._M_value; }

    [[nodiscard]]
    friend constexpr bool
    operator>=(__cmp_cat::__unspec, strong_ordering __v) noexcept
    { return 0 >= __v._M_value; }

    [[nodiscard]]
    friend constexpr strong_ordering
    operator<=>(strong_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v; }

    [[nodiscard]]
    friend constexpr strong_ordering
    operator<=>(__cmp_cat::__unspec, strong_ordering __v) noexcept
    { return strong_ordering(__cmp_cat::_Ord(-__v._M_value)); }
  };


  inline constexpr strong_ordering
  strong_ordering::less(__cmp_cat::_Ord::less);

  inline constexpr strong_ordering
  strong_ordering::equal(__cmp_cat::_Ord::equivalent);

  inline constexpr strong_ordering
  strong_ordering::equivalent(__cmp_cat::_Ord::equivalent);

  inline constexpr strong_ordering
  strong_ordering::greater(__cmp_cat::_Ord::greater);



  [[nodiscard]]
  constexpr bool
  is_eq(partial_ordering __cmp) noexcept
  { return __cmp == 0; }

  [[nodiscard]]
  constexpr bool
  is_neq(partial_ordering __cmp) noexcept
  { return __cmp != 0; }

  [[nodiscard]]
  constexpr bool
  is_lt (partial_ordering __cmp) noexcept
  { return __cmp < 0; }

  [[nodiscard]]
  constexpr bool
  is_lteq(partial_ordering __cmp) noexcept
  { return __cmp <= 0; }

  [[nodiscard]]
  constexpr bool
  is_gt (partial_ordering __cmp) noexcept
  { return __cmp > 0; }

  [[nodiscard]]
  constexpr bool
  is_gteq(partial_ordering __cmp) noexcept
  { return __cmp >= 0; }

  namespace __detail
  {
    template<typename _Tp>
      inline constexpr unsigned __cmp_cat_id = 1;
    template<>
      inline constexpr unsigned __cmp_cat_id<partial_ordering> = 2;
    template<>
      inline constexpr unsigned __cmp_cat_id<weak_ordering> = 4;
    template<>
      inline constexpr unsigned __cmp_cat_id<strong_ordering> = 8;

    template<typename... _Ts>
      constexpr auto __common_cmp_cat()
      {
 constexpr unsigned __cats = (__cmp_cat_id<_Ts> | ...);

 if constexpr (__cats & 1)
   return;


 else if constexpr (bool(__cats & __cmp_cat_id<partial_ordering>))
   return partial_ordering::equivalent;


 else if constexpr (bool(__cats & __cmp_cat_id<weak_ordering>))
   return weak_ordering::equivalent;

 else
   return strong_ordering::equivalent;
      }
  }


  template<typename... _Ts>
    struct common_comparison_category
    {
      using type = decltype(__detail::__common_cmp_cat<_Ts...>());
    };



  template<typename _Tp>
    struct common_comparison_category<_Tp>
    { using type = void; };

  template<>
    struct common_comparison_category<partial_ordering>
    { using type = partial_ordering; };

  template<>
    struct common_comparison_category<weak_ordering>
    { using type = weak_ordering; };

  template<>
    struct common_comparison_category<strong_ordering>
    { using type = strong_ordering; };

  template<>
    struct common_comparison_category<>
    { using type = strong_ordering; };

  template<typename... _Ts>
    using common_comparison_category_t
      = typename common_comparison_category<_Ts...>::type;



  namespace __detail
  {
    template<typename _Tp, typename _Cat>
      concept __compares_as
 = same_as<common_comparison_category_t<_Tp, _Cat>, _Cat>;
  }


  template<typename _Tp, typename _Cat = partial_ordering>
    concept three_way_comparable
      = __detail::__weakly_eq_cmp_with<_Tp, _Tp>
      && __detail::__partially_ordered_with<_Tp, _Tp>
      && requires(const remove_reference_t<_Tp>& __a,
    const remove_reference_t<_Tp>& __b)
      {
 { __a <=> __b } -> __detail::__compares_as<_Cat>;
      };

  template<typename _Tp, typename _Up, typename _Cat = partial_ordering>
    concept three_way_comparable_with
      = three_way_comparable<_Tp, _Cat>
      && three_way_comparable<_Up, _Cat>
      && common_reference_with<const remove_reference_t<_Tp>&,
          const remove_reference_t<_Up>&>
      && three_way_comparable<
   common_reference_t<const remove_reference_t<_Tp>&,
        const remove_reference_t<_Up>&>, _Cat>
      && __detail::__weakly_eq_cmp_with<_Tp, _Up>
      && __detail::__partially_ordered_with<_Tp, _Up>
      && requires(const remove_reference_t<_Tp>& __t,
    const remove_reference_t<_Up>& __u)
      {
 { __t <=> __u } -> __detail::__compares_as<_Cat>;
 { __u <=> __t } -> __detail::__compares_as<_Cat>;
      };

  namespace __detail
  {
    template<typename _Tp, typename _Up>
      using __cmp3way_res_t
 = decltype(std::declval<_Tp>() <=> std::declval<_Up>());






    template<typename _Tp, typename _Up>
      struct __cmp3way_res_impl
      { };

    template<typename _Tp, typename _Up>
      requires requires { typename __cmp3way_res_t<__cref<_Tp>, __cref<_Up>>; }
      struct __cmp3way_res_impl<_Tp, _Up>
      {
 using type = __cmp3way_res_t<__cref<_Tp>, __cref<_Up>>;
      };
  }


  template<typename _Tp, typename _Up = _Tp>
    struct compare_three_way_result
    : __detail::__cmp3way_res_impl<_Tp, _Up>
    { };


  template<typename _Tp, typename _Up = _Tp>
    using compare_three_way_result_t
      = typename __detail::__cmp3way_res_impl<_Tp, _Up>::type;

  namespace __detail
  {




    template<typename _Tp, typename _Up>
      concept __3way_builtin_ptr_cmp
 = requires(_Tp&& __t, _Up&& __u)
   { static_cast<_Tp&&>(__t) <=> static_cast<_Up&&>(__u); }
   && convertible_to<_Tp, const volatile void*>
   && convertible_to<_Up, const volatile void*>
   && ! requires(_Tp&& __t, _Up&& __u)
   { operator<=>(static_cast<_Tp&&>(__t), static_cast<_Up&&>(__u)); }
   && ! requires(_Tp&& __t, _Up&& __u)
   { static_cast<_Tp&&>(__t).operator<=>(static_cast<_Up&&>(__u)); };
  }





  struct compare_three_way
  {
    template<typename _Tp, typename _Up>
      requires three_way_comparable_with<_Tp, _Up>
      constexpr auto
      operator() [[nodiscard]] (_Tp&& __t, _Up&& __u) const
      noexcept(noexcept(std::declval<_Tp>() <=> std::declval<_Up>()))
      {
 if constexpr (__detail::__3way_builtin_ptr_cmp<_Tp, _Up>)
   {
     auto __pt = static_cast<const volatile void*>(__t);
     auto __pu = static_cast<const volatile void*>(__u);
     if (std::__is_constant_evaluated())
       return __pt <=> __pu;
     auto __it = reinterpret_cast<long long unsigned int>(__pt);
     auto __iu = reinterpret_cast<long long unsigned int>(__pu);
     return __it <=> __iu;
   }
 else
   return static_cast<_Tp&&>(__t) <=> static_cast<_Up&&>(__u);
      }

    using is_transparent = void;
  };



  namespace __compare
  {
    template<floating_point _Tp>
      constexpr weak_ordering
      __fp_weak_ordering(_Tp __e, _Tp __f)
      {


 auto __cat = [](_Tp __fp) -> int {
   const int __sign = __builtin_signbit(__fp) ? -1 : 1;
   if (__builtin_isnormal(__fp))
     return (__fp == 0 ? 1 : 3) * __sign;
   if (__builtin_isnan(__fp))
     return 5 * __sign;
   if (int __inf = __builtin_isinf_sign(__fp))
     return 4 * __inf;
   return 2 * __sign;
 };

 auto __po = __e <=> __f;
 if (is_lt(__po))
   return weak_ordering::less;
 else if (is_gt(__po))
   return weak_ordering::greater;
 else if (__po == partial_ordering::equivalent)
   return weak_ordering::equivalent;
 else
   {

     auto __isnan_sign = [](_Tp __fp) -> int {
       return __builtin_isnan(__fp)
  ? __builtin_signbit(__fp) ? -1 : 1
  : 0;
     };
     auto __ord = __isnan_sign(__e) <=> __isnan_sign(__f);
     if (is_eq(__ord))
       return weak_ordering::equivalent;
     else if (is_lt(__ord))
       return weak_ordering::less;
     else
       return weak_ordering::greater;
   }
      }

    void strong_order() = delete;

    template<typename _Tp, typename _Up>
      concept __adl_strong = requires(_Tp&& __t, _Up&& __u)
 {
   strong_ordering(strong_order(static_cast<_Tp&&>(__t),
           static_cast<_Up&&>(__u)));
 };

    void weak_order() = delete;

    template<typename _Tp, typename _Up>
      concept __adl_weak = requires(_Tp&& __t, _Up&& __u)
 {
   weak_ordering(weak_order(static_cast<_Tp&&>(__t),
       static_cast<_Up&&>(__u)));
 };

    void partial_order() = delete;

    template<typename _Tp, typename _Up>
      concept __adl_partial = requires(_Tp&& __t, _Up&& __u)
 {
   partial_ordering(partial_order(static_cast<_Tp&&>(__t),
      static_cast<_Up&&>(__u)));
 };

    template<typename _Ord, typename _Tp, typename _Up>
      concept __cmp3way = requires(_Tp&& __t, _Up&& __u, compare_three_way __c)
 {
   _Ord(__c(static_cast<_Tp&&>(__t), static_cast<_Up&&>(__u)));
 };

    template<typename _Tp, typename _Up>
      concept __strongly_ordered
 = __adl_strong<_Tp, _Up>
   || floating_point<remove_reference_t<_Tp>>
   || __cmp3way<strong_ordering, _Tp, _Up>;

    template<typename _Tp, typename _Up>
      concept __decayed_same_as = same_as<decay_t<_Tp>, decay_t<_Up>>;

    class _Strong_order
    {
      template<typename _Tp, typename _Up>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (floating_point<decay_t<_Tp>>)
     return true;
   else if constexpr (__adl_strong<_Tp, _Up>)
     return noexcept(strong_ordering(strong_order(std::declval<_Tp>(),
        std::declval<_Up>())));
   else if constexpr (__cmp3way<strong_ordering, _Tp, _Up>)
     return noexcept(compare_three_way()(std::declval<_Tp>(),
      std::declval<_Up>()));
 }

      friend class _Weak_order;
      friend class _Strong_fallback;


      enum class _Fp_fmt
      {
 _Binary16, _Binary32, _Binary64, _Binary128,
 _X86_80bit,
 _M68k_80bit,
 _Dbldbl,
 _Bfloat16,
      };
# 699 "D:/Programs/MinGW/include/c++/14.2.0/compare" 3
      template<typename _Tp>
 static consteval _Fp_fmt
 _S_fp_fmt() noexcept
 {

   using enum _Fp_fmt;
# 719 "D:/Programs/MinGW/include/c++/14.2.0/compare" 3
   if constexpr (__is_same(_Tp, long double))
     return (-16381) == -16381 ? _X86_80bit : _M68k_80bit;


   if constexpr (__is_same(_Tp, __float80))
     return _X86_80bit;


   if constexpr (__is_same(_Tp, decltype(0.0bf16)))
     return _Bfloat16;


   constexpr int __width = sizeof(_Tp) * 8;

   if constexpr (__width == 16)
     return _Binary16;
   else if constexpr (__width == 32)
     return _Binary32;
   else if constexpr (__width == 64)
     return _Binary64;
   else if constexpr (__width == 128)
     return _Binary128;
 }


      using int64_t = long long int;
      using int32_t = int;
      using int16_t = short int;
      using uint64_t = long long unsigned int;
      using uint16_t = short unsigned int;


      template<typename _Tp>
 struct _Int
 {

   uint64_t _M_lo;
   _Tp _M_hi;





   constexpr explicit
   _Int(_Tp __hi, uint64_t __lo) noexcept : _M_hi(__hi)
   { _M_lo = __lo; }

   constexpr explicit
   _Int(uint64_t __lo) noexcept : _M_hi(0)
   { _M_lo = __lo; }

   constexpr bool operator==(const _Int&) const = default;
# 781 "D:/Programs/MinGW/include/c++/14.2.0/compare" 3
   constexpr _Int&
   operator^=(const _Int& __rhs) noexcept
   {
     _M_hi ^= __rhs._M_hi;
     _M_lo ^= __rhs._M_lo;
     return *this;
   }

   constexpr strong_ordering
   operator<=>(const _Int& __rhs) const noexcept
   {
     strong_ordering __cmp = _M_hi <=> __rhs._M_hi;
     if (__cmp != strong_ordering::equal)
       return __cmp;
     return _M_lo <=> __rhs._M_lo;
   }
 };

      template<typename _Tp>
 static constexpr _Tp
 _S_compl(_Tp __t) noexcept
 {
   constexpr int __width = sizeof(_Tp) * 8;

   make_unsigned_t<_Tp> __sign = __t >> (__width - 1);


   return __t ^ (__sign >> 1);
 }


      template<typename _Tp>
 static constexpr _Int<_Tp>
 _S_compl(_Int<_Tp> __t) noexcept
 {
   constexpr int __width = sizeof(_Tp) * 8;
   make_unsigned_t<_Tp> __sign = __t._M_hi >> (__width - 1);
   __t._M_hi ^= (__sign >> 1 );
   uint64_t __sign64 = (_Tp)__sign;
   __t._M_lo ^= __sign64;
   return __t;
 }


      template<typename _Tp>
 constexpr static auto
 _S_fp_bits(_Tp __val) noexcept
 {
   if constexpr (sizeof(_Tp) == sizeof(int64_t))
     return __builtin_bit_cast(int64_t, __val);
   else if constexpr (sizeof(_Tp) == sizeof(int32_t))
     return __builtin_bit_cast(int32_t, __val);
   else if constexpr (sizeof(_Tp) == sizeof(int16_t))
     return __builtin_bit_cast(int16_t, __val);
   else
     {

       using enum _Fp_fmt;

       constexpr auto __fmt = _S_fp_fmt<_Tp>();
       if constexpr (__fmt == _X86_80bit || __fmt == _M68k_80bit)
  {
    if constexpr (sizeof(_Tp) == 3 * sizeof(int32_t))
      {
        auto __ival = __builtin_bit_cast(_Int<int32_t>, __val);
        return _Int<int16_t>(__ival._M_hi, __ival._M_lo);
      }
    else
      {
        auto __ival = __builtin_bit_cast(_Int<int64_t>, __val);
        return _Int<int16_t>(__ival._M_hi, __ival._M_lo);
      }
  }
       else if constexpr (sizeof(_Tp) == 2 * sizeof(int64_t))
  {

    return __builtin_bit_cast(__int128, __val);



  }
       else
  static_assert(sizeof(_Tp) == sizeof(int64_t),
         "unsupported floating-point type");
     }
 }

      template<typename _Tp>
 static constexpr strong_ordering
 _S_fp_cmp(_Tp __x, _Tp __y) noexcept
 {
# 885 "D:/Programs/MinGW/include/c++/14.2.0/compare" 3
   auto __ix = _S_fp_bits(__x);
   auto __iy = _S_fp_bits(__y);

   if (__ix == __iy)
     return strong_ordering::equal;


   using enum _Fp_fmt;

   constexpr auto __fmt = _S_fp_fmt<_Tp>();

   if constexpr (__fmt == _Dbldbl)
     {


       struct _Unpacked { double _M_hi; int64_t _M_lo; };
       auto __x2 = __builtin_bit_cast(_Unpacked, __x);
       auto __y2 = __builtin_bit_cast(_Unpacked, __y);


       auto __cmp = _S_fp_cmp(__x2._M_hi, __y2._M_hi);
       if (__cmp != strong_ordering::equal)
  return __cmp;



       if (__builtin_isnan(__x2._M_hi))
  return strong_ordering::equal;


       if (((__x2._M_lo | __y2._M_lo) & 0x7fffffffffffffffULL) == 0)
  return strong_ordering::equal;


       return _S_compl(__x2._M_lo) <=> _S_compl(__y2._M_lo);
     }
   else
     {
       if constexpr (__fmt == _M68k_80bit)
  {



    constexpr uint16_t __maxexp = 0x7fff;
    if ((__ix._M_hi & __maxexp) == __maxexp)
      __ix._M_lo |= 1ull << 63;
    if ((__iy._M_hi & __maxexp) == __maxexp)
      __iy._M_lo |= 1ull << 63;
  }
       else
  {
# 952 "D:/Programs/MinGW/include/c++/14.2.0/compare" 3
  }
       return _S_compl(__ix) <=> _S_compl(__iy);
     }
 }

    public:
      template<typename _Tp, __decayed_same_as<_Tp> _Up>
 requires __strongly_ordered<_Tp, _Up>
 constexpr strong_ordering
 operator() [[nodiscard]] (_Tp&& __e, _Up&& __f) const
 noexcept(_S_noexcept<_Tp, _Up>())
 {
   if constexpr (floating_point<decay_t<_Tp>>)
     return _S_fp_cmp(__e, __f);
   else if constexpr (__adl_strong<_Tp, _Up>)
     return strong_ordering(strong_order(static_cast<_Tp&&>(__e),
      static_cast<_Up&&>(__f)));
   else if constexpr (__cmp3way<strong_ordering, _Tp, _Up>)
     return compare_three_way()(static_cast<_Tp&&>(__e),
           static_cast<_Up&&>(__f));
 }
    };

    template<typename _Tp, typename _Up>
      concept __weakly_ordered
 = floating_point<remove_reference_t<_Tp>>
   || __adl_weak<_Tp, _Up>
   || __cmp3way<weak_ordering, _Tp, _Up>
   || __strongly_ordered<_Tp, _Up>;

    class _Weak_order
    {
      template<typename _Tp, typename _Up>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (floating_point<decay_t<_Tp>>)
     return true;
   else if constexpr (__adl_weak<_Tp, _Up>)
     return noexcept(weak_ordering(weak_order(std::declval<_Tp>(),
           std::declval<_Up>())));
   else if constexpr (__cmp3way<weak_ordering, _Tp, _Up>)
     return noexcept(compare_three_way()(std::declval<_Tp>(),
      std::declval<_Up>()));
   else if constexpr (__strongly_ordered<_Tp, _Up>)
     return _Strong_order::_S_noexcept<_Tp, _Up>();
 }

      friend class _Partial_order;
      friend class _Weak_fallback;

    public:
      template<typename _Tp, __decayed_same_as<_Tp> _Up>
 requires __weakly_ordered<_Tp, _Up>
 constexpr weak_ordering
 operator() [[nodiscard]] (_Tp&& __e, _Up&& __f) const
 noexcept(_S_noexcept<_Tp, _Up>())
 {
   if constexpr (floating_point<decay_t<_Tp>>)
     return __compare::__fp_weak_ordering(__e, __f);
   else if constexpr (__adl_weak<_Tp, _Up>)
     return weak_ordering(weak_order(static_cast<_Tp&&>(__e),
         static_cast<_Up&&>(__f)));
   else if constexpr (__cmp3way<weak_ordering, _Tp, _Up>)
     return compare_three_way()(static_cast<_Tp&&>(__e),
           static_cast<_Up&&>(__f));
   else if constexpr (__strongly_ordered<_Tp, _Up>)
     return _Strong_order{}(static_cast<_Tp&&>(__e),
       static_cast<_Up&&>(__f));
 }
    };

    template<typename _Tp, typename _Up>
      concept __partially_ordered
 = __adl_partial<_Tp, _Up>
 || __cmp3way<partial_ordering, _Tp, _Up>
 || __weakly_ordered<_Tp, _Up>;

    class _Partial_order
    {
      template<typename _Tp, typename _Up>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (__adl_partial<_Tp, _Up>)
     return noexcept(partial_ordering(partial_order(std::declval<_Tp>(),
        std::declval<_Up>())));
   else if constexpr (__cmp3way<partial_ordering, _Tp, _Up>)
     return noexcept(compare_three_way()(std::declval<_Tp>(),
      std::declval<_Up>()));
   else if constexpr (__weakly_ordered<_Tp, _Up>)
     return _Weak_order::_S_noexcept<_Tp, _Up>();
 }

      friend class _Partial_fallback;

    public:
      template<typename _Tp, __decayed_same_as<_Tp> _Up>
 requires __partially_ordered<_Tp, _Up>
 constexpr partial_ordering
 operator() [[nodiscard]] (_Tp&& __e, _Up&& __f) const
 noexcept(_S_noexcept<_Tp, _Up>())
 {
   if constexpr (__adl_partial<_Tp, _Up>)
     return partial_ordering(partial_order(static_cast<_Tp&&>(__e),
        static_cast<_Up&&>(__f)));
   else if constexpr (__cmp3way<partial_ordering, _Tp, _Up>)
     return compare_three_way()(static_cast<_Tp&&>(__e),
           static_cast<_Up&&>(__f));
   else if constexpr (__weakly_ordered<_Tp, _Up>)
     return _Weak_order{}(static_cast<_Tp&&>(__e),
     static_cast<_Up&&>(__f));
 }
    };

    template<typename _Tp, typename _Up>
      concept __op_eq_lt = requires(_Tp&& __t, _Up&& __u)
 {
   { static_cast<_Tp&&>(__t) == static_cast<_Up&&>(__u) }
     -> convertible_to<bool>;
   { static_cast<_Tp&&>(__t) < static_cast<_Up&&>(__u) }
     -> convertible_to<bool>;
 };

    class _Strong_fallback
    {
      template<typename _Tp, typename _Up>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (__strongly_ordered<_Tp, _Up>)
     return _Strong_order::_S_noexcept<_Tp, _Up>();
   else
     return noexcept(bool(std::declval<_Tp>() == std::declval<_Up>()))
       && noexcept(bool(std::declval<_Tp>() < std::declval<_Up>()));
 }

    public:
      template<typename _Tp, __decayed_same_as<_Tp> _Up>
 requires __strongly_ordered<_Tp, _Up> || __op_eq_lt<_Tp, _Up>
 constexpr strong_ordering
 operator() [[nodiscard]] (_Tp&& __e, _Up&& __f) const
 noexcept(_S_noexcept<_Tp, _Up>())
 {
   if constexpr (__strongly_ordered<_Tp, _Up>)
     return _Strong_order{}(static_cast<_Tp&&>(__e),
       static_cast<_Up&&>(__f));
   else
     return static_cast<_Tp&&>(__e) == static_cast<_Up&&>(__f)
       ? strong_ordering::equal
       : static_cast<_Tp&&>(__e) < static_cast<_Up&&>(__f)
       ? strong_ordering::less
       : strong_ordering::greater;
 }
    };

    class _Weak_fallback
    {
      template<typename _Tp, typename _Up>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (__weakly_ordered<_Tp, _Up>)
     return _Weak_order::_S_noexcept<_Tp, _Up>();
   else
     return noexcept(bool(std::declval<_Tp>() == std::declval<_Up>()))
       && noexcept(bool(std::declval<_Tp>() < std::declval<_Up>()));
 }

    public:
      template<typename _Tp, __decayed_same_as<_Tp> _Up>
 requires __weakly_ordered<_Tp, _Up> || __op_eq_lt<_Tp, _Up>
 constexpr weak_ordering
 operator() [[nodiscard]] (_Tp&& __e, _Up&& __f) const
 noexcept(_S_noexcept<_Tp, _Up>())
 {
   if constexpr (__weakly_ordered<_Tp, _Up>)
     return _Weak_order{}(static_cast<_Tp&&>(__e),
     static_cast<_Up&&>(__f));
   else
     return static_cast<_Tp&&>(__e) == static_cast<_Up&&>(__f)
       ? weak_ordering::equivalent
       : static_cast<_Tp&&>(__e) < static_cast<_Up&&>(__f)
       ? weak_ordering::less
       : weak_ordering::greater;
 }
    };



    template<typename _Tp, typename _Up>
      concept __op_eq_lt_lt = __op_eq_lt<_Tp, _Up>
 && requires(_Tp&& __t, _Up&& __u)
 {
   { static_cast<_Up&&>(__u) < static_cast<_Tp&&>(__t) }
     -> convertible_to<bool>;
 };

    class _Partial_fallback
    {
      template<typename _Tp, typename _Up>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (__partially_ordered<_Tp, _Up>)
     return _Partial_order::_S_noexcept<_Tp, _Up>();
   else
     return noexcept(bool(std::declval<_Tp>() == std::declval<_Up>()))
       && noexcept(bool(std::declval<_Tp>() < std::declval<_Up>()));
 }

    public:
      template<typename _Tp, __decayed_same_as<_Tp> _Up>
 requires __partially_ordered<_Tp, _Up> || __op_eq_lt_lt<_Tp, _Up>
 constexpr partial_ordering
 operator() [[nodiscard]] (_Tp&& __e, _Up&& __f) const
 noexcept(_S_noexcept<_Tp, _Up>())
 {
   if constexpr (__partially_ordered<_Tp, _Up>)
     return _Partial_order{}(static_cast<_Tp&&>(__e),
        static_cast<_Up&&>(__f));
   else
     return static_cast<_Tp&&>(__e) == static_cast<_Up&&>(__f)
       ? partial_ordering::equivalent
       : static_cast<_Tp&&>(__e) < static_cast<_Up&&>(__f)
       ? partial_ordering::less
       : static_cast<_Up&&>(__f) < static_cast<_Tp&&>(__e)
       ? partial_ordering::greater
       : partial_ordering::unordered;
 }
    };
  }



  inline namespace _Cpo
  {
    inline constexpr __compare::_Strong_order strong_order{};

    inline constexpr __compare::_Weak_order weak_order{};

    inline constexpr __compare::_Partial_order partial_order{};

    inline constexpr __compare::_Strong_fallback
      compare_strong_order_fallback{};

    inline constexpr __compare::_Weak_fallback
      compare_weak_order_fallback{};

    inline constexpr __compare::_Partial_fallback
      compare_partial_order_fallback{};
  }


  namespace __detail
  {

    inline constexpr struct _Synth3way
    {
      template<typename _Tp, typename _Up>
 static constexpr bool
 _S_noexcept(const _Tp* __t = nullptr, const _Up* __u = nullptr)
 {
   if constexpr (three_way_comparable_with<_Tp, _Up>)
     return noexcept(*__t <=> *__u);
   else
     return noexcept(*__t < *__u) && noexcept(*__u < *__t);
 }

      template<typename _Tp, typename _Up>
 [[nodiscard]]
 constexpr auto
 operator()(const _Tp& __t, const _Up& __u) const
 noexcept(_S_noexcept<_Tp, _Up>())
 requires requires
 {
   { __t < __u } -> __boolean_testable;
   { __u < __t } -> __boolean_testable;
 }
 {
   if constexpr (three_way_comparable_with<_Tp, _Up>)
     return __t <=> __u;
   else
     {
       if (__t < __u)
  return weak_ordering::less;
       else if (__u < __t)
  return weak_ordering::greater;
       else
  return weak_ordering::equivalent;
     }
 }
    } __synth3way = {};


    template<typename _Tp, typename _Up = _Tp>
      using __synth3way_t
 = decltype(__detail::__synth3way(std::declval<_Tp&>(),
      std::declval<_Up&>()));
  }


}
# 39 "D:/Programs/MinGW/include/c++/14.2.0/array" 2 3
# 1 "D:/Programs/MinGW/include/c++/14.2.0/initializer_list" 1 3
# 33 "D:/Programs/MinGW/include/c++/14.2.0/initializer_list" 3
       
# 34 "D:/Programs/MinGW/include/c++/14.2.0/initializer_list" 3







namespace std
{

  template<class _E>
    class initializer_list
    {
    public:
      typedef _E value_type;
      typedef const _E& reference;
      typedef const _E& const_reference;
      typedef size_t size_type;
      typedef const _E* iterator;
      typedef const _E* const_iterator;

    private:
      iterator _M_array;
      size_type _M_len;


      constexpr initializer_list(const_iterator __a, size_type __l)
      : _M_array(__a), _M_len(__l) { }

    public:
      constexpr initializer_list() noexcept
      : _M_array(0), _M_len(0) { }


      constexpr size_type
      size() const noexcept { return _M_len; }


      constexpr const_iterator
      begin() const noexcept { return _M_array; }


      constexpr const_iterator
      end() const noexcept { return begin() + size(); }
    };







  template<class _Tp>
    constexpr const _Tp*
    begin(initializer_list<_Tp> __ils) noexcept
    { return __ils.begin(); }







  template<class _Tp>
    constexpr const _Tp*
    end(initializer_list<_Tp> __ils) noexcept
    { return __ils.end(); }
}
# 40 "D:/Programs/MinGW/include/c++/14.2.0/array" 2 3


# 1 "D:/Programs/MinGW/include/c++/14.2.0/bits/functexcept.h" 1 3
# 40 "D:/Programs/MinGW/include/c++/14.2.0/bits/functexcept.h" 3
# 1 "D:/Programs/MinGW/include/c++/14.2.0/bits/exception_defines.h" 1 3
# 41 "D:/Programs/MinGW/include/c++/14.2.0/bits/functexcept.h" 2 3

namespace std
{




  void
  __throw_bad_exception(void) __attribute__((__noreturn__));


  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));

  void
  __throw_bad_array_new_length(void) __attribute__((__noreturn__));


  void
  __throw_bad_cast(void) __attribute__((__noreturn__,__cold__));

  void
  __throw_bad_typeid(void) __attribute__((__noreturn__,__cold__));


  void
  __throw_logic_error(const char*) __attribute__((__noreturn__,__cold__));

  void
  __throw_domain_error(const char*) __attribute__((__noreturn__,__cold__));

  void
  __throw_invalid_argument(const char*) __attribute__((__noreturn__,__cold__));

  void
  __throw_length_error(const char*) __attribute__((__noreturn__,__cold__));

  void
  __throw_out_of_range(const char*) __attribute__((__noreturn__,__cold__));

  void
  __throw_out_of_range_fmt(const char*, ...) __attribute__((__noreturn__,__cold__))
    __attribute__((__format__(__gnu_printf__, 1, 2)));

  void
  __throw_runtime_error(const char*) __attribute__((__noreturn__,__cold__));

  void
  __throw_range_error(const char*) __attribute__((__noreturn__,__cold__));

  void
  __throw_overflow_error(const char*) __attribute__((__noreturn__,__cold__));

  void
  __throw_underflow_error(const char*) __attribute__((__noreturn__,__cold__));


  void
  __throw_ios_failure(const char*) __attribute__((__noreturn__,__cold__));

  void
  __throw_ios_failure(const char*, int) __attribute__((__noreturn__,__cold__));


  void
  __throw_system_error(int) __attribute__((__noreturn__,__cold__));


  void
  __throw_future_error(int) __attribute__((__noreturn__,__cold__));


  void
  __throw_bad_function_call() __attribute__((__noreturn__,__cold__));
# 140 "D:/Programs/MinGW/include/c++/14.2.0/bits/functexcept.h" 3

}
# 43 "D:/Programs/MinGW/include/c++/14.2.0/array" 2 3
# 1 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_algobase.h" 1 3
# 61 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_algobase.h" 3
# 1 "D:/Programs/MinGW/include/c++/14.2.0/bits/cpp_type_traits.h" 1 3
# 35 "D:/Programs/MinGW/include/c++/14.2.0/bits/cpp_type_traits.h" 3
       
# 36 "D:/Programs/MinGW/include/c++/14.2.0/bits/cpp_type_traits.h" 3
# 67 "D:/Programs/MinGW/include/c++/14.2.0/bits/cpp_type_traits.h" 3
extern "C++" {

namespace std
{


  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };



  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };


  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };





  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };



  template<>
    struct __is_integer<char8_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };



  template<>
    struct __is_integer<char16_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char32_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 272 "D:/Programs/MinGW/include/c++/14.2.0/bits/cpp_type_traits.h" 3
__extension__ template<> struct __is_integer<__int128> { enum { __value = 1 }; typedef __true_type __type; }; __extension__ template<> struct __is_integer<unsigned __int128> { enum { __value = 1 }; typedef __true_type __type; };
# 289 "D:/Programs/MinGW/include/c++/14.2.0/bits/cpp_type_traits.h" 3
  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_floating<_Float16>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };



  template<>
    struct __is_floating<_Float32>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };



  template<>
    struct __is_floating<_Float64>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };



  template<>
    struct __is_floating<_Float128>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };



  template<>
    struct __is_floating<__gnu_cxx::__bfloat16_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };





  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };




  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };




  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_byte
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_byte<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  enum class byte : unsigned char;

  template<>
    struct __is_byte<byte>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };



  template<>
    struct __is_byte<char8_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename> struct iterator_traits;


  template<typename _Tp>
    struct __is_nonvolatile_trivially_copyable
    {
      enum { __value = __is_trivially_copyable(_Tp) };
    };




  template<typename _Tp>
    struct __is_nonvolatile_trivially_copyable<volatile _Tp>
    {
      enum { __value = 0 };
    };


  template<typename _OutputIter, typename _InputIter>
    struct __memcpyable
    {
      enum { __value = 0 };
    };

  template<typename _Tp>
    struct __memcpyable<_Tp*, _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };

  template<typename _Tp>
    struct __memcpyable<_Tp*, const _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };






  template<typename _Iter1, typename _Iter2>
    struct __memcmpable
    {
      enum { __value = 0 };
    };


  template<typename _Tp>
    struct __memcmpable<_Tp*, _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };

  template<typename _Tp>
    struct __memcmpable<const _Tp*, _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };

  template<typename _Tp>
    struct __memcmpable<_Tp*, const _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };







  template<typename _Tp, bool _TreatAsBytes =



 __is_byte<_Tp>::__value

    >
    struct __is_memcmp_ordered
    {
      static const bool __value = _Tp(-1) > _Tp(1);
    };

  template<typename _Tp>
    struct __is_memcmp_ordered<_Tp, false>
    {
      static const bool __value = false;
    };


  template<typename _Tp, typename _Up, bool = sizeof(_Tp) == sizeof(_Up)>
    struct __is_memcmp_ordered_with
    {
      static const bool __value = __is_memcmp_ordered<_Tp>::__value
 && __is_memcmp_ordered<_Up>::__value;
    };

  template<typename _Tp, typename _Up>
    struct __is_memcmp_ordered_with<_Tp, _Up, false>
    {
      static const bool __value = false;
    };
# 579 "D:/Programs/MinGW/include/c++/14.2.0/bits/cpp_type_traits.h" 3
  template<>
    struct __is_memcmp_ordered_with<std::byte, std::byte, true>
    { static constexpr bool __value = true; };

  template<typename _Tp, bool _SameSize>
    struct __is_memcmp_ordered_with<_Tp, std::byte, _SameSize>
    { static constexpr bool __value = false; };

  template<typename _Up, bool _SameSize>
    struct __is_memcmp_ordered_with<std::byte, _Up, _SameSize>
    { static constexpr bool __value = false; };





  template<typename _Tp>
    struct __is_move_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };



  template<typename _Iterator>
    constexpr
    inline _Iterator
    __miter_base(_Iterator __it)
    { return __it; }


}
}
# 62 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_algobase.h" 2 3
# 1 "D:/Programs/MinGW/include/c++/14.2.0/ext/type_traits.h" 1 3
# 32 "D:/Programs/MinGW/include/c++/14.2.0/ext/type_traits.h" 3
       
# 33 "D:/Programs/MinGW/include/c++/14.2.0/ext/type_traits.h" 3




extern "C++" {

namespace __gnu_cxx
{



  template<bool, typename>
    struct __enable_if
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };



  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;



  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };


  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;



  template<typename _Type>
    constexpr
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    constexpr
    inline bool
    __is_null_pointer(_Type)
    { return false; }


  constexpr bool
  __is_null_pointer(std::nullptr_t)
  { return true; }




  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
    struct __promote
    { typedef double __type; };




  template<typename _Tp>
    struct __promote<_Tp, false>
    { };

  template<>
    struct __promote<long double>
    { typedef long double __type; };

  template<>
    struct __promote<double>
    { typedef double __type; };

  template<>
    struct __promote<float>
    { typedef float __type; };


  template<>
    struct __promote<_Float16>
    { typedef _Float16 __type; };



  template<>
    struct __promote<_Float32>
    { typedef _Float32 __type; };



  template<>
    struct __promote<_Float64>
    { typedef _Float64 __type; };



  template<>
    struct __promote<_Float128>
    { typedef _Float128 __type; };



  template<>
    struct __promote<__gnu_cxx::__bfloat16_t>
    { typedef __gnu_cxx::__bfloat16_t __type; };




  template<typename... _Tp>
    using __promoted_t = decltype((typename __promote<_Tp>::__type(0) + ...));



  template<typename _Tp, typename _Up>
    using __promote_2 = __promote<__promoted_t<_Tp, _Up>>;

  template<typename _Tp, typename _Up, typename _Vp>
    using __promote_3 = __promote<__promoted_t<_Tp, _Up, _Vp>>;

  template<typename _Tp, typename _Up, typename _Vp, typename _Wp>
    using __promote_4 = __promote<__promoted_t<_Tp, _Up, _Vp, _Wp>>;
# 269 "D:/Programs/MinGW/include/c++/14.2.0/ext/type_traits.h" 3

}
}
# 63 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_algobase.h" 2 3
# 1 "D:/Programs/MinGW/include/c++/14.2.0/ext/numeric_traits.h" 1 3
# 32 "D:/Programs/MinGW/include/c++/14.2.0/ext/numeric_traits.h" 3
       
# 33 "D:/Programs/MinGW/include/c++/14.2.0/ext/numeric_traits.h" 3




namespace __gnu_cxx
{

# 50 "D:/Programs/MinGW/include/c++/14.2.0/ext/numeric_traits.h" 3
  template<typename _Tp>
    struct __is_integer_nonstrict
    : public std::__is_integer<_Tp>
    {
      using std::__is_integer<_Tp>::__value;


      enum { __width = __value ? sizeof(_Tp) * 8 : 0 };
    };

  template<typename _Value>
    struct __numeric_traits_integer
    {

      static_assert(__is_integer_nonstrict<_Value>::__value,
      "invalid specialization");




      static const bool __is_signed = (_Value)(-1) < 0;
      static const int __digits
 = __is_integer_nonstrict<_Value>::__width - __is_signed;


      static const _Value __max = __is_signed
 ? (((((_Value)1 << (__digits - 1)) - 1) << 1) + 1)
 : ~(_Value)0;
      static const _Value __min = __is_signed ? -__max - 1 : (_Value)0;
    };

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__min;

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__max;

  template<typename _Value>
    const bool __numeric_traits_integer<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_integer<_Value>::__digits;
# 137 "D:/Programs/MinGW/include/c++/14.2.0/ext/numeric_traits.h" 3
  template<typename _Tp>
    using __int_traits = __numeric_traits_integer<_Tp>;
# 157 "D:/Programs/MinGW/include/c++/14.2.0/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_floating
    {

      static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 64) * 643L / 2136);


      static const bool __is_signed = true;
      static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 18);
      static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932);
    };

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_digits10;

  template<typename _Value>
    const bool __numeric_traits_floating<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__digits10;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_exponent10;






  template<typename _Value>
    struct __numeric_traits
    : public __numeric_traits_integer<_Value>
    { };

  template<>
    struct __numeric_traits<float>
    : public __numeric_traits_floating<float>
    { };

  template<>
    struct __numeric_traits<double>
    : public __numeric_traits_floating<double>
    { };

  template<>
    struct __numeric_traits<long double>
    : public __numeric_traits_floating<long double>
    { };
# 238 "D:/Programs/MinGW/include/c++/14.2.0/ext/numeric_traits.h" 3

}
# 64 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_algobase.h" 2 3
# 1 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_pair.h" 1 3
# 61 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_pair.h" 3
# 1 "D:/Programs/MinGW/include/c++/14.2.0/bits/move.h" 1 3
# 40 "D:/Programs/MinGW/include/c++/14.2.0/bits/move.h" 3
namespace std
{







  template<typename _Tp>
    inline constexpr _Tp*
    __addressof(_Tp& __r) noexcept
    { return __builtin_addressof(__r); }
# 67 "D:/Programs/MinGW/include/c++/14.2.0/bits/move.h" 3
  template<typename _Tp>
    [[__nodiscard__]]
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
    { return static_cast<_Tp&&>(__t); }







  template<typename _Tp>
    [[__nodiscard__]]
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type&& __t) noexcept
    {
      static_assert(!std::is_lvalue_reference<_Tp>::value,
   "std::forward must not be used to convert an rvalue to an lvalue");
      return static_cast<_Tp&&>(__t);
    }


  template<typename _Tp, typename _Up>
  [[nodiscard]]
  constexpr decltype(auto)
  forward_like(_Up&& __x) noexcept
  {
    constexpr bool __as_rval = is_rvalue_reference_v<_Tp&&>;

    if constexpr (is_const_v<remove_reference_t<_Tp>>)
      {
 using _Up2 = remove_reference_t<_Up>;
 if constexpr (__as_rval)
   return static_cast<const _Up2&&>(__x);
 else
   return static_cast<const _Up2&>(__x);
      }
    else
      {
 if constexpr (__as_rval)
   return static_cast<remove_reference_t<_Up>&&>(__x);
 else
   return static_cast<_Up&>(__x);
      }
  }

  template<typename _Tp, typename _Up>
    using __like_t = decltype(std::forward_like<_Tp>(std::declval<_Up>()));







  template<typename _Tp>
    [[__nodiscard__]]
    constexpr typename std::remove_reference<_Tp>::type&&
    move(_Tp&& __t) noexcept
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }


  template<typename _Tp>
    struct __move_if_noexcept_cond
    : public __and_<__not_<is_nothrow_move_constructible<_Tp>>,
                    is_copy_constructible<_Tp>>::type { };
# 143 "D:/Programs/MinGW/include/c++/14.2.0/bits/move.h" 3
  template<typename _Tp>
    [[__nodiscard__]]
    constexpr
    __conditional_t<__move_if_noexcept_cond<_Tp>::value, const _Tp&, _Tp&&>
    move_if_noexcept(_Tp& __x) noexcept
    { return std::move(__x); }
# 159 "D:/Programs/MinGW/include/c++/14.2.0/bits/move.h" 3
  template<typename _Tp>
    [[__nodiscard__]]
    inline constexpr _Tp*
    addressof(_Tp& __r) noexcept
    { return std::__addressof(__r); }



  template<typename _Tp>
    const _Tp* addressof(const _Tp&&) = delete;


  template <typename _Tp, typename _Up = _Tp>
    constexpr
    inline _Tp
    __exchange(_Tp& __obj, _Up&& __new_val)
    {
      _Tp __old_val = std::move(__obj);
      __obj = std::forward<_Up>(__new_val);
      return __old_val;
    }
# 203 "D:/Programs/MinGW/include/c++/14.2.0/bits/move.h" 3
  template<typename _Tp>
    constexpr
    inline

    typename enable_if<__and_<__not_<__is_tuple_like<_Tp>>,
         is_move_constructible<_Tp>,
         is_move_assignable<_Tp>>::value>::type



    swap(_Tp& __a, _Tp& __b)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>, is_nothrow_move_assignable<_Tp>>::value)

    {




      _Tp __tmp = std::move(__a);
      __a = std::move(__b);
      __b = std::move(__tmp);
    }




  template<typename _Tp, size_t _Nm>
    constexpr
    inline

    typename enable_if<__is_swappable<_Tp>::value>::type



    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value)
    {
      for (size_t __n = 0; __n < _Nm; ++__n)
 swap(__a[__n], __b[__n]);
    }



}
# 62 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_pair.h" 2 3
# 1 "D:/Programs/MinGW/include/c++/14.2.0/bits/utility.h" 1 3
# 36 "D:/Programs/MinGW/include/c++/14.2.0/bits/utility.h" 3
       
# 37 "D:/Programs/MinGW/include/c++/14.2.0/bits/utility.h" 3






namespace std
{



  template<typename _Tp>
    struct tuple_size;





  template<typename _Tp,
    typename _Up = typename remove_cv<_Tp>::type,
    typename = typename enable_if<is_same<_Tp, _Up>::value>::type,
    size_t = tuple_size<_Tp>::value>
    using __enable_if_has_tuple_size = _Tp;

  template<typename _Tp>
    struct tuple_size<const __enable_if_has_tuple_size<_Tp>>
    : public tuple_size<_Tp> { };

  template<typename _Tp>
    struct tuple_size<volatile __enable_if_has_tuple_size<_Tp>>
    : public tuple_size<_Tp> { };

  template<typename _Tp>
    struct tuple_size<const volatile __enable_if_has_tuple_size<_Tp>>
    : public tuple_size<_Tp> { };


  template<typename _Tp>
    inline constexpr size_t tuple_size_v = tuple_size<_Tp>::value;



  template<size_t __i, typename _Tp>
    struct tuple_element;


  template<size_t __i, typename _Tp>
    using __tuple_element_t = typename tuple_element<__i, _Tp>::type;

  template<size_t __i, typename _Tp>
    struct tuple_element<__i, const _Tp>
    {
      using type = const __tuple_element_t<__i, _Tp>;
    };

  template<size_t __i, typename _Tp>
    struct tuple_element<__i, volatile _Tp>
    {
      using type = volatile __tuple_element_t<__i, _Tp>;
    };

  template<size_t __i, typename _Tp>
    struct tuple_element<__i, const volatile _Tp>
    {
      using type = const volatile __tuple_element_t<__i, _Tp>;
    };





  template<typename _Tp, typename... _Types>
    constexpr size_t
    __find_uniq_type_in_pack()
    {
      constexpr size_t __sz = sizeof...(_Types);
      constexpr bool __found[__sz] = { __is_same(_Tp, _Types) ... };
      size_t __n = __sz;
      for (size_t __i = 0; __i < __sz; ++__i)
 {
   if (__found[__i])
     {
       if (__n < __sz)
  return __sz;
       __n = __i;
     }
 }
      return __n;
    }
# 134 "D:/Programs/MinGW/include/c++/14.2.0/bits/utility.h" 3
  template<size_t __i, typename _Tp>
    using tuple_element_t = typename tuple_element<__i, _Tp>::type;




  template<size_t... _Indexes> struct _Index_tuple { };


  template<size_t _Num>
    struct _Build_index_tuple
    {
# 154 "D:/Programs/MinGW/include/c++/14.2.0/bits/utility.h" 3
      using __type = _Index_tuple<__integer_pack(_Num)...>;

    };




  template<typename _Tp, _Tp... _Idx>
    struct integer_sequence
    {

      static_assert(is_integral_v<_Tp>);

      typedef _Tp value_type;
      static constexpr size_t size() noexcept { return sizeof...(_Idx); }
    };


  template<typename _Tp, _Tp _Num>
    using make_integer_sequence



      = integer_sequence<_Tp, __integer_pack(_Num)...>;



  template<size_t... _Idx>
    using index_sequence = integer_sequence<size_t, _Idx...>;


  template<size_t _Num>
    using make_index_sequence = make_integer_sequence<size_t, _Num>;


  template<typename... _Types>
    using index_sequence_for = make_index_sequence<sizeof...(_Types)>;




  struct in_place_t {
    explicit in_place_t() = default;
  };

  inline constexpr in_place_t in_place{};

  template<typename _Tp> struct in_place_type_t
  {
    explicit in_place_type_t() = default;
  };

  template<typename _Tp>
    inline constexpr in_place_type_t<_Tp> in_place_type{};

  template<size_t _Idx> struct in_place_index_t
  {
    explicit in_place_index_t() = default;
  };

  template<size_t _Idx>
    inline constexpr in_place_index_t<_Idx> in_place_index{};

  template<typename>
    inline constexpr bool __is_in_place_type_v = false;

  template<typename _Tp>
    inline constexpr bool __is_in_place_type_v<in_place_type_t<_Tp>> = true;

  template<typename _Tp>
    using __is_in_place_type = bool_constant<__is_in_place_type_v<_Tp>>;

  template<typename>
    inline constexpr bool __is_in_place_index_v = false;

  template<size_t _Nm>
    inline constexpr bool __is_in_place_index_v<in_place_index_t<_Nm>> = true;




  template<size_t _Np, typename... _Types>
    struct _Nth_type
    { using type = __type_pack_element<_Np, _Types...>; };
# 276 "D:/Programs/MinGW/include/c++/14.2.0/bits/utility.h" 3
  namespace ranges::__detail
  {
    template<typename _Range>
      inline constexpr bool __is_subrange = false;
  }



}
# 63 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_pair.h" 2 3





namespace std
{

# 79 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_pair.h" 3
  struct piecewise_construct_t { explicit piecewise_construct_t() = default; };


  inline constexpr piecewise_construct_t piecewise_construct =
    piecewise_construct_t();




  template<typename _T1, typename _T2>
    struct pair;

  template<typename...>
    class tuple;





  template<typename _Tp, size_t _Nm>
    struct array;

  template<size_t...>
    struct _Index_tuple;

  template<size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&
    get(pair<_Tp1, _Tp2>& __in) noexcept;

  template<size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&&
    get(pair<_Tp1, _Tp2>&& __in) noexcept;

  template<size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&
    get(const pair<_Tp1, _Tp2>& __in) noexcept;

  template<size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&&
    get(const pair<_Tp1, _Tp2>&& __in) noexcept;

  template<size_t __i, typename... _Elements>
    constexpr __tuple_element_t<__i, tuple<_Elements...>>&
    get(tuple<_Elements...>& __t) noexcept;

  template<size_t __i, typename... _Elements>
    constexpr const __tuple_element_t<__i, tuple<_Elements...>>&
    get(const tuple<_Elements...>& __t) noexcept;

  template<size_t __i, typename... _Elements>
    constexpr __tuple_element_t<__i, tuple<_Elements...>>&&
    get(tuple<_Elements...>&& __t) noexcept;

  template<size_t __i, typename... _Elements>
    constexpr const __tuple_element_t<__i, tuple<_Elements...>>&&
    get(const tuple<_Elements...>&& __t) noexcept;

  template<size_t _Int, typename _Tp, size_t _Nm>
    constexpr _Tp&
    get(array<_Tp, _Nm>&) noexcept;

  template<size_t _Int, typename _Tp, size_t _Nm>
    constexpr _Tp&&
    get(array<_Tp, _Nm>&&) noexcept;

  template<size_t _Int, typename _Tp, size_t _Nm>
    constexpr const _Tp&
    get(const array<_Tp, _Nm>&) noexcept;

  template<size_t _Int, typename _Tp, size_t _Nm>
    constexpr const _Tp&&
    get(const array<_Tp, _Nm>&&) noexcept;
# 221 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_pair.h" 3
  template<typename _Tp>
    inline constexpr bool __is_tuple_v = false;

  template<typename... _Ts>
    inline constexpr bool __is_tuple_v<tuple<_Ts...>> = true;


  template<typename _Tp>
    inline constexpr bool __is_tuple_like_v = false;

  template<typename... _Elements>
    inline constexpr bool __is_tuple_like_v<tuple<_Elements...>> = true;

  template<typename _T1, typename _T2>
    inline constexpr bool __is_tuple_like_v<pair<_T1, _T2>> = true;

  template<typename _Tp, size_t _Nm>
    inline constexpr bool __is_tuple_like_v<array<_Tp, _Nm>> = true;



  template<typename _Tp>
    concept __tuple_like = __is_tuple_like_v<remove_cvref_t<_Tp>>;

  template<typename _Tp>
    concept __pair_like = __tuple_like<_Tp> && tuple_size_v<remove_cvref_t<_Tp>> == 2;

  template<typename _Tp, typename _Tuple>
    concept __eligible_tuple_like
      = __detail::__different_from<_Tp, _Tuple> && __tuple_like<_Tp>
 && (tuple_size_v<remove_cvref_t<_Tp>> == tuple_size_v<_Tuple>)
 && !ranges::__detail::__is_subrange<remove_cvref_t<_Tp>>;

  template<typename _Tp, typename _Pair>
    concept __eligible_pair_like
      = __detail::__different_from<_Tp, _Pair> && __pair_like<_Tp>
 && !ranges::__detail::__is_subrange<remove_cvref_t<_Tp>>;


  template<typename _U1, typename _U2> class __pair_base
  {







  };
# 283 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    struct pair
    : public __pair_base<_T1, _T2>
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;


      constexpr pair(const pair&) = default;
      constexpr pair(pair&&) = default;

      template<typename... _Args1, typename... _Args2>
 constexpr
 pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);


      constexpr void
      swap(pair& __p)
      noexcept(__and_<__is_nothrow_swappable<_T1>,
        __is_nothrow_swappable<_T2>>::value)
      {
 using std::swap;
 swap(first, __p.first);
 swap(second, __p.second);
      }
# 319 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_pair.h" 3
      constexpr void
      swap(const pair& __p) const
      noexcept(__and_v<__is_nothrow_swappable<const _T1>,
         __is_nothrow_swappable<const _T2>>)
      requires is_swappable_v<const _T1> && is_swappable_v<const _T2>
      {
 using std::swap;
 swap(first, __p.first);
 swap(second, __p.second);
      }


    private:
      template<typename... _Args1, size_t... _Indexes1,
        typename... _Args2, size_t... _Indexes2>
 constexpr
 pair(tuple<_Args1...>&, tuple<_Args2...>&,
      _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);
    public:





      constexpr
      explicit(__not_<__and_<__is_implicitly_default_constructible<_T1>,
        __is_implicitly_default_constructible<_T2>>>())
      pair()
      requires is_default_constructible_v<_T1>
        && is_default_constructible_v<_T2>
      : first(), second()
      { }

    private:


      template<typename _U1, typename _U2>
 static constexpr bool
 _S_constructible()
 {
   if constexpr (is_constructible_v<_T1, _U1>)
     return is_constructible_v<_T2, _U2>;
   return false;
 }

      template<typename _U1, typename _U2>
 static constexpr bool
 _S_nothrow_constructible()
 {
   if constexpr (is_nothrow_constructible_v<_T1, _U1>)
     return is_nothrow_constructible_v<_T2, _U2>;
   return false;
 }

      template<typename _U1, typename _U2>
 static constexpr bool
 _S_convertible()
 {
   if constexpr (is_convertible_v<_U1, _T1>)
     return is_convertible_v<_U2, _T2>;
   return false;
 }


      template<typename _U1, typename _U2>
 static constexpr bool
 _S_dangles()
 {

   if constexpr (__reference_constructs_from_temporary(_T1, _U1&&))
     return true;
   else
     return __reference_constructs_from_temporary(_T2, _U2&&);



 }


      template<typename _UPair>
 static constexpr bool
 _S_constructible_from_pair_like()
 {
   return _S_constructible<decltype(std::get<0>(std::declval<_UPair>())),
      decltype(std::get<1>(std::declval<_UPair>()))>();
 }

      template<typename _UPair>
 static constexpr bool
 _S_convertible_from_pair_like()
 {
   return _S_convertible<decltype(std::get<0>(std::declval<_UPair>())),
    decltype(std::get<1>(std::declval<_UPair>()))>();
 }

      template<typename _UPair>
 static constexpr bool
 _S_dangles_from_pair_like()
 {
   return _S_dangles<decltype(std::get<0>(std::declval<_UPair>())),
       decltype(std::get<1>(std::declval<_UPair>()))>();
 }



    public:


      constexpr explicit(!_S_convertible<const _T1&, const _T2&>())
      pair(const _T1& __x, const _T2& __y)
      noexcept(_S_nothrow_constructible<const _T1&, const _T2&>())
      requires (_S_constructible<const _T1&, const _T2&>())
      : first(__x), second(__y)
      { }



      template<typename _U1 = _T1, typename _U2 = _T2>



 requires (_S_constructible<_U1, _U2>()) && (!_S_dangles<_U1, _U2>())
 constexpr explicit(!_S_convertible<_U1, _U2>())
 pair(_U1&& __x, _U2&& __y)
 noexcept(_S_nothrow_constructible<_U1, _U2>())
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y))
 { }


      template<typename _U1 = _T1, typename _U2 = _T2>



 requires (_S_constructible<_U1, _U2>()) && (_S_dangles<_U1, _U2>())
 constexpr explicit(!_S_convertible<_U1, _U2>())
 pair(_U1&&, _U2&&) = delete;


      template<typename _U1, typename _U2>
 requires (_S_constructible<const _U1&, const _U2&>())
   && (!_S_dangles<_U1, _U2>())
 constexpr explicit(!_S_convertible<const _U1&, const _U2&>())
 pair(const pair<_U1, _U2>& __p)
 noexcept(_S_nothrow_constructible<const _U1&, const _U2&>())
 : first(__p.first), second(__p.second)
 { }

      template<typename _U1, typename _U2>
 requires (_S_constructible<const _U1&, const _U2&>())
       && (_S_dangles<const _U1&, const _U2&>())
 constexpr explicit(!_S_convertible<const _U1&, const _U2&>())
 pair(const pair<_U1, _U2>&) = delete;


      template<typename _U1, typename _U2>
 requires (_S_constructible<_U1, _U2>()) && (!_S_dangles<_U1, _U2>())
 constexpr explicit(!_S_convertible<_U1, _U2>())
 pair(pair<_U1, _U2>&& __p)
 noexcept(_S_nothrow_constructible<_U1, _U2>())
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second))
 { }

      template<typename _U1, typename _U2>
 requires (_S_constructible<_U1, _U2>()) && (_S_dangles<_U1, _U2>())
 constexpr explicit(!_S_convertible<_U1, _U2>())
 pair(pair<_U1, _U2>&&) = delete;



      template<typename _U1, typename _U2>
 requires (_S_constructible<_U1&, _U2&>()) && (!_S_dangles<_U1&, _U2&>())
 constexpr explicit(!_S_convertible<_U1&, _U2&>())
 pair(pair<_U1, _U2>& __p)
 noexcept(_S_nothrow_constructible<_U1&, _U2&>())
 : first(__p.first), second(__p.second)
 { }

      template<typename _U1, typename _U2>
 requires (_S_constructible<_U1&, _U2&>()) && (_S_dangles<_U1&, _U2&>())
 constexpr explicit(!_S_convertible<_U1&, _U2&>())
 pair(pair<_U1, _U2>&) = delete;


      template<typename _U1, typename _U2>
 requires (_S_constructible<const _U1, const _U2>())
   && (!_S_dangles<const _U1, const _U2>())
 constexpr explicit(!_S_convertible<const _U1, const _U2>())
 pair(const pair<_U1, _U2>&& __p)
 noexcept(_S_nothrow_constructible<const _U1, const _U2>())
 : first(std::forward<const _U1>(__p.first)),
   second(std::forward<const _U2>(__p.second))
 { }

      template<typename _U1, typename _U2>
 requires (_S_constructible<const _U1, const _U2>())
   && (_S_dangles<const _U1, const _U2>())
 constexpr explicit(!_S_convertible<const _U1, const _U2>())
 pair(const pair<_U1, _U2>&&) = delete;



      template<__eligible_pair_like<pair> _UPair>
 requires (_S_constructible_from_pair_like<_UPair>())
   && (!_S_dangles_from_pair_like<_UPair>())
 constexpr explicit(!_S_convertible_from_pair_like<_UPair>())
 pair(_UPair&& __p)
 : first(std::get<0>(std::forward<_UPair>(__p))),
   second(std::get<1>(std::forward<_UPair>(__p)))
 { }

      template<__eligible_pair_like<pair> _UPair>
 requires (_S_constructible_from_pair_like<_UPair>())
   && (_S_dangles_from_pair_like<_UPair>())
 constexpr explicit(!_S_convertible_from_pair_like<_UPair>())
 pair(_UPair&&) = delete;


  private:

      template<typename _U1, typename _U2>
 static constexpr bool
 _S_assignable()
 {
   if constexpr (is_assignable_v<_T1&, _U1>)
     return is_assignable_v<_T2&, _U2>;
   return false;
 }

      template<typename _U1, typename _U2>
 static constexpr bool
 _S_const_assignable()
 {
   if constexpr (is_assignable_v<const _T1&, _U1>)
     return is_assignable_v<const _T2&, _U2>;
   return false;
 }

      template<typename _U1, typename _U2>
 static constexpr bool
 _S_nothrow_assignable()
 {
   if constexpr (is_nothrow_assignable_v<_T1&, _U1>)
     return is_nothrow_assignable_v<_T2&, _U2>;
   return false;
 }


      template<typename _UPair>
 static constexpr bool
 _S_assignable_from_tuple_like()
 {
   return _S_assignable<decltype(std::get<0>(std::declval<_UPair>())),
          decltype(std::get<1>(std::declval<_UPair>()))>();
 }

      template<typename _UPair>
 static constexpr bool
 _S_const_assignable_from_tuple_like()
 {
   return _S_const_assignable<decltype(std::get<0>(std::declval<_UPair>())),
         decltype(std::get<1>(std::declval<_UPair>()))>();
 }



  public:

      pair& operator=(const pair&) = delete;


      constexpr pair&
      operator=(const pair& __p)
      noexcept(_S_nothrow_assignable<const _T1&, const _T2&>())
      requires (_S_assignable<const _T1&, const _T2&>())
      {
 first = __p.first;
 second = __p.second;
 return *this;
      }


      constexpr pair&
      operator=(pair&& __p)
      noexcept(_S_nothrow_assignable<_T1, _T2>())
      requires (_S_assignable<_T1, _T2>())
      {
 first = std::forward<first_type>(__p.first);
 second = std::forward<second_type>(__p.second);
 return *this;
      }


      template<typename _U1, typename _U2>
 constexpr pair&
 operator=(const pair<_U1, _U2>& __p)
 noexcept(_S_nothrow_assignable<const _U1&, const _U2&>())
 requires (_S_assignable<const _U1&, const _U2&>())
 {
   first = __p.first;
   second = __p.second;
   return *this;
 }


      template<typename _U1, typename _U2>
 constexpr pair&
 operator=(pair<_U1, _U2>&& __p)
 noexcept(_S_nothrow_assignable<_U1, _U2>())
 requires (_S_assignable<_U1, _U2>())
 {
   first = std::forward<_U1>(__p.first);
   second = std::forward<_U2>(__p.second);
   return *this;
 }



      constexpr const pair&
      operator=(const pair& __p) const
      requires (_S_const_assignable<const first_type&, const second_type&>())
      {
 first = __p.first;
 second = __p.second;
 return *this;
      }


      constexpr const pair&
      operator=(pair&& __p) const
      requires (_S_const_assignable<first_type, second_type>())
      {
 first = std::forward<first_type>(__p.first);
 second = std::forward<second_type>(__p.second);
 return *this;
      }


      template<typename _U1, typename _U2>
 constexpr const pair&
 operator=(const pair<_U1, _U2>& __p) const
 requires (_S_const_assignable<const _U1&, const _U2&>())
 {
   first = __p.first;
   second = __p.second;
   return *this;
 }


      template<typename _U1, typename _U2>
 constexpr const pair&
 operator=(pair<_U1, _U2>&& __p) const
 requires (_S_const_assignable<_U1, _U2>())
 {
   first = std::forward<_U1>(__p.first);
   second = std::forward<_U2>(__p.second);
   return *this;
 }



      template<__eligible_pair_like<pair> _UPair>
 requires (_S_assignable_from_tuple_like<_UPair>())
 constexpr pair&
 operator=(_UPair&& __p)
 {
   first = std::get<0>(std::forward<_UPair>(__p));
   second = std::get<1>(std::forward<_UPair>(__p));
   return *this;
 }

      template<__eligible_pair_like<pair> _UPair>
 requires (_S_const_assignable_from_tuple_like<_UPair>())
 constexpr const pair&
 operator=(_UPair&& __p) const
 {
   first = std::get<0>(std::forward<_UPair>(__p));
   second = std::get<1>(std::forward<_UPair>(__p));
   return *this;
 }
# 995 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_pair.h" 3
    };




  template<typename _T1, typename _T2> pair(_T1, _T2) -> pair<_T1, _T2>;







  template<typename _T1, typename _T2, typename _U1, typename _U2>
    inline constexpr bool
    operator==(const pair<_T1, _T2>& __x, const pair<_U1, _U2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }
# 1020 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_pair.h" 3
  template<typename _T1, typename _T2, typename _U1, typename _U2>
    constexpr common_comparison_category_t<__detail::__synth3way_t<_T1, _U1>,
        __detail::__synth3way_t<_T2, _U2>>
    operator<=>(const pair<_T1, _T2>& __x, const pair<_U1, _U2>& __y)
    {
      if (auto __c = __detail::__synth3way(__x.first, __y.first); __c != 0)
 return __c;
      return __detail::__synth3way(__x.second, __y.second);
    }
# 1080 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    constexpr inline


    typename enable_if<__and_<__is_swappable<_T1>,
                              __is_swappable<_T2>>::value>::type



    swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }


  template<typename _T1, typename _T2>
    requires is_swappable_v<const _T1> && is_swappable_v<const _T2>
    constexpr void
    swap(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }



  template<typename _T1, typename _T2>
    typename enable_if<!__and_<__is_swappable<_T1>,
          __is_swappable<_T2>>::value>::type
    swap(pair<_T1, _T2>&, pair<_T1, _T2>&) = delete;
# 1129 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    constexpr pair<typename __decay_and_strip<_T1>::__type,
                   typename __decay_and_strip<_T2>::__type>
    make_pair(_T1&& __x, _T2&& __y)
    {
      typedef typename __decay_and_strip<_T1>::__type __ds_type1;
      typedef typename __decay_and_strip<_T2>::__type __ds_type2;
      typedef pair<__ds_type1, __ds_type2> __pair_type;
      return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
    }
# 1152 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    struct __is_tuple_like_impl<pair<_T1, _T2>> : true_type
    { };



  template<class _Tp1, class _Tp2>
    struct tuple_size<pair<_Tp1, _Tp2>>
    : public integral_constant<size_t, 2> { };


  template<class _Tp1, class _Tp2>
    struct tuple_element<0, pair<_Tp1, _Tp2>>
    { typedef _Tp1 type; };


  template<class _Tp1, class _Tp2>
    struct tuple_element<1, pair<_Tp1, _Tp2>>
    { typedef _Tp2 type; };



  template<size_t __i, typename... _Types>
    struct tuple_element<__i, tuple<_Types...>>;


  template<typename _Tp1, typename _Tp2>
    inline constexpr size_t tuple_size_v<pair<_Tp1, _Tp2>> = 2;

  template<typename _Tp1, typename _Tp2>
    inline constexpr size_t tuple_size_v<const pair<_Tp1, _Tp2>> = 2;

  template<typename _Tp>
    inline constexpr bool __is_pair = false;

  template<typename _Tp, typename _Up>
    inline constexpr bool __is_pair<pair<_Tp, _Up>> = true;



  template<size_t _Int>
    struct __pair_get;

  template<>
    struct __pair_get<0>
    {
      template<typename _Tp1, typename _Tp2>
 static constexpr _Tp1&
 __get(pair<_Tp1, _Tp2>& __pair) noexcept
 { return __pair.first; }

      template<typename _Tp1, typename _Tp2>
 static constexpr _Tp1&&
 __move_get(pair<_Tp1, _Tp2>&& __pair) noexcept
 { return std::forward<_Tp1>(__pair.first); }

      template<typename _Tp1, typename _Tp2>
 static constexpr const _Tp1&
 __const_get(const pair<_Tp1, _Tp2>& __pair) noexcept
 { return __pair.first; }

      template<typename _Tp1, typename _Tp2>
 static constexpr const _Tp1&&
 __const_move_get(const pair<_Tp1, _Tp2>&& __pair) noexcept
 { return std::forward<const _Tp1>(__pair.first); }
    };

  template<>
    struct __pair_get<1>
    {
      template<typename _Tp1, typename _Tp2>
 static constexpr _Tp2&
 __get(pair<_Tp1, _Tp2>& __pair) noexcept
 { return __pair.second; }

      template<typename _Tp1, typename _Tp2>
 static constexpr _Tp2&&
 __move_get(pair<_Tp1, _Tp2>&& __pair) noexcept
 { return std::forward<_Tp2>(__pair.second); }

      template<typename _Tp1, typename _Tp2>
 static constexpr const _Tp2&
 __const_get(const pair<_Tp1, _Tp2>& __pair) noexcept
 { return __pair.second; }

      template<typename _Tp1, typename _Tp2>
 static constexpr const _Tp2&&
 __const_move_get(const pair<_Tp1, _Tp2>&& __pair) noexcept
 { return std::forward<const _Tp2>(__pair.second); }
    };






  template<size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&
    get(pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__get(__in); }

  template<size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&&
    get(pair<_Tp1, _Tp2>&& __in) noexcept
    { return __pair_get<_Int>::__move_get(std::move(__in)); }

  template<size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&
    get(const pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__const_get(__in); }

  template<size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&&
    get(const pair<_Tp1, _Tp2>&& __in) noexcept
    { return __pair_get<_Int>::__const_move_get(std::move(__in)); }



  template <typename _Tp, typename _Up>
    constexpr _Tp&
    get(pair<_Tp, _Up>& __p) noexcept
    { return __p.first; }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&
    get(const pair<_Tp, _Up>& __p) noexcept
    { return __p.first; }

  template <typename _Tp, typename _Up>
    constexpr _Tp&&
    get(pair<_Tp, _Up>&& __p) noexcept
    { return std::move(__p.first); }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&&
    get(const pair<_Tp, _Up>&& __p) noexcept
    { return std::move(__p.first); }

  template <typename _Tp, typename _Up>
    constexpr _Tp&
    get(pair<_Up, _Tp>& __p) noexcept
    { return __p.second; }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&
    get(const pair<_Up, _Tp>& __p) noexcept
    { return __p.second; }

  template <typename _Tp, typename _Up>
    constexpr _Tp&&
    get(pair<_Up, _Tp>&& __p) noexcept
    { return std::move(__p.second); }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&&
    get(const pair<_Up, _Tp>&& __p) noexcept
    { return std::move(__p.second); }




  template<typename _T1, typename _T2, typename _U1, typename _U2,
    template<typename> class _TQual, template<typename> class _UQual>
    requires requires { typename pair<common_reference_t<_TQual<_T1>, _UQual<_U1>>,
          common_reference_t<_TQual<_T2>, _UQual<_U2>>>; }
  struct basic_common_reference<pair<_T1, _T2>, pair<_U1, _U2>, _TQual, _UQual>
  {
    using type = pair<common_reference_t<_TQual<_T1>, _UQual<_U1>>,
        common_reference_t<_TQual<_T2>, _UQual<_U2>>>;
  };

  template<typename _T1, typename _T2, typename _U1, typename _U2>
    requires requires { typename pair<common_type_t<_T1, _U1>, common_type_t<_T2, _U2>>; }
  struct common_type<pair<_T1, _T2>, pair<_U1, _U2>>
  { using type = pair<common_type_t<_T1, _U1>, common_type_t<_T2, _U2>>; };






}
# 65 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_algobase.h" 2 3
# 1 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_iterator_base_types.h" 1 3
# 62 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_iterator_base_types.h" 3
       
# 63 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_iterator_base_types.h" 3
# 71 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_iterator_base_types.h" 3
# 1 "D:/Programs/MinGW/include/c++/14.2.0/bits/iterator_concepts.h" 1 3
# 33 "D:/Programs/MinGW/include/c++/14.2.0/bits/iterator_concepts.h" 3
       
# 34 "D:/Programs/MinGW/include/c++/14.2.0/bits/iterator_concepts.h" 3



# 1 "D:/Programs/MinGW/include/c++/14.2.0/bits/ptr_traits.h" 1 3
# 39 "D:/Programs/MinGW/include/c++/14.2.0/bits/ptr_traits.h" 3
namespace __gnu_debug { struct _Safe_iterator_base; }


namespace std
{




  class __undefined;



  template<typename _Tp>
    struct __get_first_arg
    { using type = __undefined; };

  template<template<typename, typename...> class _SomeTemplate, typename _Tp,
           typename... _Types>
    struct __get_first_arg<_SomeTemplate<_Tp, _Types...>>
    { using type = _Tp; };



  template<typename _Tp, typename _Up>
    struct __replace_first_arg
    { };

  template<template<typename, typename...> class _SomeTemplate, typename _Up,
           typename _Tp, typename... _Types>
    struct __replace_first_arg<_SomeTemplate<_Tp, _Types...>, _Up>
    { using type = _SomeTemplate<_Up, _Types...>; };


  template<typename _Ptr, typename = void>
    struct __ptr_traits_elem : __get_first_arg<_Ptr>
    { };



  template<typename _Ptr> requires requires { typename _Ptr::element_type; }
    struct __ptr_traits_elem<_Ptr, void>
    { using type = typename _Ptr::element_type; };






  template<typename _Ptr>
    using __ptr_traits_elem_t = typename __ptr_traits_elem<_Ptr>::type;




  template<typename _Ptr, typename _Elt, bool = is_void<_Elt>::value>
    struct __ptr_traits_ptr_to
    {
      using pointer = _Ptr;
      using element_type = _Elt;







      static pointer
      pointer_to(element_type& __r)

      requires requires {
 { pointer::pointer_to(__r) } -> convertible_to<pointer>;
      }

      { return pointer::pointer_to(__r); }
    };


  template<typename _Ptr, typename _Elt>
    struct __ptr_traits_ptr_to<_Ptr, _Elt, true>
    { };


  template<typename _Tp>
    struct __ptr_traits_ptr_to<_Tp*, _Tp, false>
    {
      using pointer = _Tp*;
      using element_type = _Tp;






      static constexpr pointer
      pointer_to(element_type& __r) noexcept
      { return std::addressof(__r); }
    };

  template<typename _Ptr, typename _Elt>
    struct __ptr_traits_impl : __ptr_traits_ptr_to<_Ptr, _Elt>
    {
    private:
      template<typename _Tp>
 using __diff_t = typename _Tp::difference_type;

      template<typename _Tp, typename _Up>
 using __rebind = __type_identity<typename _Tp::template rebind<_Up>>;

    public:

      using pointer = _Ptr;


      using element_type = _Elt;


      using difference_type = __detected_or_t<ptrdiff_t, __diff_t, _Ptr>;


      template<typename _Up>
 using rebind = typename __detected_or_t<__replace_first_arg<_Ptr, _Up>,
      __rebind, _Ptr, _Up>::type;
    };



  template<typename _Ptr>
    struct __ptr_traits_impl<_Ptr, __undefined>
    { };







  template<typename _Ptr>
    struct pointer_traits : __ptr_traits_impl<_Ptr, __ptr_traits_elem_t<_Ptr>>
    { };







  template<typename _Tp>
    struct pointer_traits<_Tp*> : __ptr_traits_ptr_to<_Tp*, _Tp>
    {

      typedef _Tp* pointer;

      typedef _Tp element_type;

      typedef ptrdiff_t difference_type;

      template<typename _Up> using rebind = _Up*;
    };


  template<typename _Ptr, typename _Tp>
    using __ptr_rebind = typename pointer_traits<_Ptr>::template rebind<_Tp>;

  template<typename _Tp>
    constexpr _Tp*
    __to_address(_Tp* __ptr) noexcept
    {
      static_assert(!std::is_function<_Tp>::value, "not a function pointer");
      return __ptr;
    }







  template<typename _Ptr>
    constexpr auto
    __to_address(const _Ptr& __ptr) noexcept
    -> decltype(std::pointer_traits<_Ptr>::to_address(__ptr))
    { return std::pointer_traits<_Ptr>::to_address(__ptr); }

  template<typename _Ptr, typename... _None>
    constexpr auto
    __to_address(const _Ptr& __ptr, _None...) noexcept
    {
      if constexpr (is_base_of_v<__gnu_debug::_Safe_iterator_base, _Ptr>)
 return std::__to_address(__ptr.base().operator->());
      else
 return std::__to_address(__ptr.operator->());
    }







  template<typename _Tp>
    constexpr _Tp*
    to_address(_Tp* __ptr) noexcept
    { return std::__to_address(__ptr); }
# 251 "D:/Programs/MinGW/include/c++/14.2.0/bits/ptr_traits.h" 3
  template<typename _Ptr>
    constexpr auto
    to_address(const _Ptr& __ptr) noexcept
    { return std::__to_address(__ptr); }



}
# 38 "D:/Programs/MinGW/include/c++/14.2.0/bits/iterator_concepts.h" 2 3
# 1 "D:/Programs/MinGW/include/c++/14.2.0/bits/ranges_cmp.h" 1 3
# 37 "D:/Programs/MinGW/include/c++/14.2.0/bits/ranges_cmp.h" 3
namespace std
{


  struct __is_transparent;





  struct identity
  {
    template<typename _Tp>
      [[nodiscard]]
      constexpr _Tp&&
      operator()(_Tp&& __t) const noexcept
      { return std::forward<_Tp>(__t); }

    using is_transparent = __is_transparent;
  };


namespace ranges
{
  namespace __detail
  {



    template<typename _Tp, typename _Up>
      concept __less_builtin_ptr_cmp
 = requires (_Tp&& __t, _Up&& __u) { { __t < __u } -> same_as<bool>; }
   && convertible_to<_Tp, const volatile void*>
   && convertible_to<_Up, const volatile void*>
   && (! requires(_Tp&& __t, _Up&& __u)
       { operator<(std::forward<_Tp>(__t), std::forward<_Up>(__u)); }
       && ! requires(_Tp&& __t, _Up&& __u)
       { std::forward<_Tp>(__t).operator<(std::forward<_Up>(__u)); });
  }







  struct equal_to
  {
    template<typename _Tp, typename _Up>
      requires equality_comparable_with<_Tp, _Up>
      constexpr bool
      operator()(_Tp&& __t, _Up&& __u) const
      noexcept(noexcept(std::declval<_Tp>() == std::declval<_Up>()))
      { return std::forward<_Tp>(__t) == std::forward<_Up>(__u); }

    using is_transparent = __is_transparent;
  };


  struct not_equal_to
  {
    template<typename _Tp, typename _Up>
      requires equality_comparable_with<_Tp, _Up>
      constexpr bool
      operator()(_Tp&& __t, _Up&& __u) const
      noexcept(noexcept(std::declval<_Up>() == std::declval<_Tp>()))
      { return !equal_to{}(std::forward<_Tp>(__t), std::forward<_Up>(__u)); }

    using is_transparent = __is_transparent;
  };


  struct less
  {
    template<typename _Tp, typename _Up>
      requires totally_ordered_with<_Tp, _Up>
      constexpr bool
      operator()(_Tp&& __t, _Up&& __u) const
      noexcept(noexcept(std::declval<_Tp>() < std::declval<_Up>()))
      {
 if constexpr (__detail::__less_builtin_ptr_cmp<_Tp, _Up>)
   {
     if (std::__is_constant_evaluated())
       return __t < __u;

     auto __x = reinterpret_cast<long long unsigned int>(
       static_cast<const volatile void*>(std::forward<_Tp>(__t)));
     auto __y = reinterpret_cast<long long unsigned int>(
       static_cast<const volatile void*>(std::forward<_Up>(__u)));
     return __x < __y;
   }
 else
   return std::forward<_Tp>(__t) < std::forward<_Up>(__u);
      }

    using is_transparent = __is_transparent;
  };


  struct greater
  {
    template<typename _Tp, typename _Up>
      requires totally_ordered_with<_Tp, _Up>
      constexpr bool
      operator()(_Tp&& __t, _Up&& __u) const
      noexcept(noexcept(std::declval<_Up>() < std::declval<_Tp>()))
      { return less{}(std::forward<_Up>(__u), std::forward<_Tp>(__t)); }

    using is_transparent = __is_transparent;
  };


  struct greater_equal
  {
    template<typename _Tp, typename _Up>
      requires totally_ordered_with<_Tp, _Up>
      constexpr bool
      operator()(_Tp&& __t, _Up&& __u) const
      noexcept(noexcept(std::declval<_Tp>() < std::declval<_Up>()))
      { return !less{}(std::forward<_Tp>(__t), std::forward<_Up>(__u)); }

    using is_transparent = __is_transparent;
  };


  struct less_equal
  {
    template<typename _Tp, typename _Up>
      requires totally_ordered_with<_Tp, _Up>
      constexpr bool
      operator()(_Tp&& __t, _Up&& __u) const
      noexcept(noexcept(std::declval<_Up>() < std::declval<_Tp>()))
      { return !less{}(std::forward<_Up>(__u), std::forward<_Tp>(__t)); }

    using is_transparent = __is_transparent;
  };

}


}
# 39 "D:/Programs/MinGW/include/c++/14.2.0/bits/iterator_concepts.h" 2 3

namespace std
{

# 58 "D:/Programs/MinGW/include/c++/14.2.0/bits/iterator_concepts.h" 3
  struct default_sentinel_t { };


  inline constexpr default_sentinel_t default_sentinel{};


  struct input_iterator_tag;
  struct output_iterator_tag;
  struct forward_iterator_tag;
  struct bidirectional_iterator_tag;
  struct random_access_iterator_tag;
  struct contiguous_iterator_tag;

  template<typename _Iterator>
    struct iterator_traits;

  template<typename _Tp> requires is_object_v<_Tp>
    struct iterator_traits<_Tp*>;

  template<typename _Iterator, typename>
    struct __iterator_traits;

  namespace __detail
  {
    template<typename _Tp>
      using __with_ref = _Tp&;

    template<typename _Tp>
      concept __can_reference = requires { typename __with_ref<_Tp>; };

    template<typename _Tp>
      concept __dereferenceable = requires(_Tp& __t)
 {
   { *__t } -> __can_reference;
 };
  }

  template<__detail::__dereferenceable _Tp>
    using iter_reference_t = decltype(*std::declval<_Tp&>());

  namespace ranges
  {

    namespace __imove
    {
      void iter_move() = delete;

      template<typename _Tp>
 concept __adl_imove
   = (std::__detail::__class_or_enum<remove_reference_t<_Tp>>)
   && requires(_Tp&& __t) { iter_move(static_cast<_Tp&&>(__t)); };

      struct _IterMove
      {
      private:
 template<typename _Tp>
   struct __result
   { using type = iter_reference_t<_Tp>; };

 template<typename _Tp>
   requires __adl_imove<_Tp>
   struct __result<_Tp>
   { using type = decltype(iter_move(std::declval<_Tp>())); };

 template<typename _Tp>
   requires (!__adl_imove<_Tp>)
   && is_lvalue_reference_v<iter_reference_t<_Tp>>
   struct __result<_Tp>
   { using type = remove_reference_t<iter_reference_t<_Tp>>&&; };

 template<typename _Tp>
   static constexpr bool
   _S_noexcept()
   {
     if constexpr (__adl_imove<_Tp>)
       return noexcept(iter_move(std::declval<_Tp>()));
     else
       return noexcept(*std::declval<_Tp>());
   }

      public:

 template<std::__detail::__dereferenceable _Tp>
   using __type = typename __result<_Tp>::type;

 template<std::__detail::__dereferenceable _Tp>
   [[nodiscard]]
   constexpr __type<_Tp>
   operator()(_Tp&& __e) const
   noexcept(_S_noexcept<_Tp>())
   {
     if constexpr (__adl_imove<_Tp>)
       return iter_move(static_cast<_Tp&&>(__e));
     else if constexpr (is_lvalue_reference_v<iter_reference_t<_Tp>>)
       return static_cast<__type<_Tp>>(*__e);
     else
       return *__e;
   }
      };
    }


    inline namespace _Cpo {
      inline constexpr __imove::_IterMove iter_move{};
    }
  }

  template<__detail::__dereferenceable _Tp>
    requires __detail::__can_reference<ranges::__imove::_IterMove::__type<_Tp&>>
    using iter_rvalue_reference_t = ranges::__imove::_IterMove::__type<_Tp&>;

  template<typename> struct incrementable_traits { };

  template<typename _Tp> requires is_object_v<_Tp>
    struct incrementable_traits<_Tp*>
    { using difference_type = ptrdiff_t; };

  template<typename _Iter>
    struct incrementable_traits<const _Iter>
    : incrementable_traits<_Iter> { };

  template<typename _Tp> requires requires { typename _Tp::difference_type; }
    struct incrementable_traits<_Tp>
    { using difference_type = typename _Tp::difference_type; };

  template<typename _Tp>
    requires (!requires { typename _Tp::difference_type; }
       && requires(const _Tp& __a, const _Tp& __b)
       { { __a - __b } -> integral; })
    struct incrementable_traits<_Tp>
    {
      using difference_type
 = make_signed_t<decltype(std::declval<_Tp>() - std::declval<_Tp>())>;
    };
# 204 "D:/Programs/MinGW/include/c++/14.2.0/bits/iterator_concepts.h" 3
  namespace __detail
  {


    template<typename _Iter>
      concept __primary_traits_iter
 = __is_base_of(__iterator_traits<_Iter, void>, iterator_traits<_Iter>);

    template<typename _Iter, typename _Tp>
      struct __iter_traits_impl
      { using type = iterator_traits<_Iter>; };

    template<typename _Iter, typename _Tp>
      requires __primary_traits_iter<_Iter>
      struct __iter_traits_impl<_Iter, _Tp>
      { using type = _Tp; };


    template<typename _Iter, typename _Tp = _Iter>
      using __iter_traits = typename __iter_traits_impl<_Iter, _Tp>::type;

    template<typename _Tp>
      using __iter_diff_t = typename
 __iter_traits<_Tp, incrementable_traits<_Tp>>::difference_type;
  }

  template<typename _Tp>
    using iter_difference_t = __detail::__iter_diff_t<remove_cvref_t<_Tp>>;

  namespace __detail
  {
    template<typename> struct __cond_value_type { };

    template<typename _Tp> requires is_object_v<_Tp>
      struct __cond_value_type<_Tp>
      { using value_type = remove_cv_t<_Tp>; };

    template<typename _Tp>
      concept __has_member_value_type
 = requires { typename _Tp::value_type; };

    template<typename _Tp>
      concept __has_member_element_type
 = requires { typename _Tp::element_type; };

  }

  template<typename> struct indirectly_readable_traits { };

  template<typename _Tp>
    struct indirectly_readable_traits<_Tp*>
    : __detail::__cond_value_type<_Tp>
    { };

  template<typename _Iter> requires is_array_v<_Iter>
    struct indirectly_readable_traits<_Iter>
    { using value_type = remove_cv_t<remove_extent_t<_Iter>>; };

  template<typename _Iter>
    struct indirectly_readable_traits<const _Iter>
    : indirectly_readable_traits<_Iter>
    { };

  template<__detail::__has_member_value_type _Tp>
    struct indirectly_readable_traits<_Tp>
    : __detail::__cond_value_type<typename _Tp::value_type>
    { };

  template<__detail::__has_member_element_type _Tp>
    struct indirectly_readable_traits<_Tp>
    : __detail::__cond_value_type<typename _Tp::element_type>
    { };



  template<__detail::__has_member_value_type _Tp>
    requires __detail::__has_member_element_type<_Tp>
    && same_as<remove_cv_t<typename _Tp::element_type>,
        remove_cv_t<typename _Tp::value_type>>
    struct indirectly_readable_traits<_Tp>
    : __detail::__cond_value_type<typename _Tp::value_type>
    { };



  template<__detail::__has_member_value_type _Tp>
    requires __detail::__has_member_element_type<_Tp>
    struct indirectly_readable_traits<_Tp>
    { };

  namespace __detail
  {
    template<typename _Tp>
      using __iter_value_t = typename
 __iter_traits<_Tp, indirectly_readable_traits<_Tp>>::value_type;
  }

  template<typename _Tp>
    using iter_value_t = __detail::__iter_value_t<remove_cvref_t<_Tp>>;

  namespace __detail
  {


    template<typename _Iter>
      concept __cpp17_iterator = requires(_Iter __it)
 {
   { *__it } -> __can_reference;
   { ++__it } -> same_as<_Iter&>;
   { *__it++ } -> __can_reference;
 } && copyable<_Iter>;

    template<typename _Iter>
      concept __cpp17_input_iterator = __cpp17_iterator<_Iter>
 && equality_comparable<_Iter>
 && requires(_Iter __it)
 {
   typename incrementable_traits<_Iter>::difference_type;
   typename indirectly_readable_traits<_Iter>::value_type;
   typename common_reference_t<iter_reference_t<_Iter>&&,
     typename indirectly_readable_traits<_Iter>::value_type&>;
   typename common_reference_t<decltype(*__it++)&&,
     typename indirectly_readable_traits<_Iter>::value_type&>;
   requires signed_integral<
     typename incrementable_traits<_Iter>::difference_type>;
 };

    template<typename _Iter>
      concept __cpp17_fwd_iterator = __cpp17_input_iterator<_Iter>
 && constructible_from<_Iter>
 && is_lvalue_reference_v<iter_reference_t<_Iter>>
 && same_as<remove_cvref_t<iter_reference_t<_Iter>>,
     typename indirectly_readable_traits<_Iter>::value_type>
 && requires(_Iter __it)
 {
   { __it++ } -> convertible_to<const _Iter&>;
   { *__it++ } -> same_as<iter_reference_t<_Iter>>;
 };

    template<typename _Iter>
      concept __cpp17_bidi_iterator = __cpp17_fwd_iterator<_Iter>
 && requires(_Iter __it)
 {
   { --__it } -> same_as<_Iter&>;
   { __it-- } -> convertible_to<const _Iter&>;
   { *__it-- } -> same_as<iter_reference_t<_Iter>>;
 };

    template<typename _Iter>
      concept __cpp17_randacc_iterator = __cpp17_bidi_iterator<_Iter>
 && totally_ordered<_Iter>
 && requires(_Iter __it,
      typename incrementable_traits<_Iter>::difference_type __n)
 {
   { __it += __n } -> same_as<_Iter&>;
   { __it -= __n } -> same_as<_Iter&>;
   { __it + __n } -> same_as<_Iter>;
   { __n + __it } -> same_as<_Iter>;
   { __it - __n } -> same_as<_Iter>;
   { __it - __it } -> same_as<decltype(__n)>;
   { __it[__n] } -> convertible_to<iter_reference_t<_Iter>>;
 };

    template<typename _Iter>
      concept __iter_with_nested_types = requires {
 typename _Iter::iterator_category;
 typename _Iter::value_type;
 typename _Iter::difference_type;
 typename _Iter::reference;
      };

    template<typename _Iter>
      concept __iter_without_nested_types = !__iter_with_nested_types<_Iter>;

    template<typename _Iter>
      concept __iter_without_category
 = !requires { typename _Iter::iterator_category; };

  }

  template<typename _Iterator>
    requires __detail::__iter_with_nested_types<_Iterator>
    struct __iterator_traits<_Iterator, void>
    {
    private:
      template<typename _Iter>
 struct __ptr
 { using type = void; };

      template<typename _Iter> requires requires { typename _Iter::pointer; }
 struct __ptr<_Iter>
 { using type = typename _Iter::pointer; };

    public:
      using iterator_category = typename _Iterator::iterator_category;
      using value_type = typename _Iterator::value_type;
      using difference_type = typename _Iterator::difference_type;
      using pointer = typename __ptr<_Iterator>::type;
      using reference = typename _Iterator::reference;
    };

  template<typename _Iterator>
    requires __detail::__iter_without_nested_types<_Iterator>
       && __detail::__cpp17_input_iterator<_Iterator>
    struct __iterator_traits<_Iterator, void>
    {
    private:
      template<typename _Iter>
 struct __cat
 { using type = input_iterator_tag; };

      template<typename _Iter>
 requires requires { typename _Iter::iterator_category; }
 struct __cat<_Iter>
 { using type = typename _Iter::iterator_category; };

      template<typename _Iter>
 requires __detail::__iter_without_category<_Iter>
    && __detail::__cpp17_randacc_iterator<_Iter>
 struct __cat<_Iter>
 { using type = random_access_iterator_tag; };

      template<typename _Iter>
 requires __detail::__iter_without_category<_Iter>
    && __detail::__cpp17_bidi_iterator<_Iter>
 struct __cat<_Iter>
 { using type = bidirectional_iterator_tag; };

      template<typename _Iter>
 requires __detail::__iter_without_category<_Iter>
    && __detail::__cpp17_fwd_iterator<_Iter>
 struct __cat<_Iter>
 { using type = forward_iterator_tag; };

      template<typename _Iter>
 struct __ptr
 { using type = void; };

      template<typename _Iter> requires requires { typename _Iter::pointer; }
 struct __ptr<_Iter>
 { using type = typename _Iter::pointer; };

      template<typename _Iter>
 requires (!requires { typename _Iter::pointer; }
     && requires(_Iter& __it) { __it.operator->(); })
 struct __ptr<_Iter>
 { using type = decltype(std::declval<_Iter&>().operator->()); };

      template<typename _Iter>
 struct __ref
 { using type = iter_reference_t<_Iter>; };

      template<typename _Iter> requires requires { typename _Iter::reference; }
 struct __ref<_Iter>
 { using type = typename _Iter::reference; };

    public:
      using iterator_category = typename __cat<_Iterator>::type;
      using value_type
 = typename indirectly_readable_traits<_Iterator>::value_type;
      using difference_type
 = typename incrementable_traits<_Iterator>::difference_type;
      using pointer = typename __ptr<_Iterator>::type;
      using reference = typename __ref<_Iterator>::type;
    };

  template<typename _Iterator>
    requires __detail::__iter_without_nested_types<_Iterator>
       && __detail::__cpp17_iterator<_Iterator>
    struct __iterator_traits<_Iterator, void>
    {
    private:
      template<typename _Iter>
 struct __diff
 { using type = void; };

      template<typename _Iter>
 requires requires
 { typename incrementable_traits<_Iter>::difference_type; }
 struct __diff<_Iter>
 {
   using type = typename incrementable_traits<_Iter>::difference_type;
 };

    public:
      using iterator_category = output_iterator_tag;
      using value_type = void;
      using difference_type = typename __diff<_Iterator>::type;
      using pointer = void;
      using reference = void;
    };

  namespace __detail
  {
    template<typename _Iter>
      struct __iter_concept_impl;


    template<typename _Iter>
      requires requires { typename __iter_traits<_Iter>::iterator_concept; }
      struct __iter_concept_impl<_Iter>
      { using type = typename __iter_traits<_Iter>::iterator_concept; };


    template<typename _Iter>
      requires (!requires { typename __iter_traits<_Iter>::iterator_concept; }
   && requires { typename __iter_traits<_Iter>::iterator_category; })
      struct __iter_concept_impl<_Iter>
      { using type = typename __iter_traits<_Iter>::iterator_category; };


    template<typename _Iter>
      requires (!requires { typename __iter_traits<_Iter>::iterator_concept; }
   && !requires { typename __iter_traits<_Iter>::iterator_category; }
   && __primary_traits_iter<_Iter>)
      struct __iter_concept_impl<_Iter>
      { using type = random_access_iterator_tag; };


    template<typename _Iter>
      struct __iter_concept_impl
      { };


    template<typename _Iter>
      using __iter_concept = typename __iter_concept_impl<_Iter>::type;

  template<typename _In>
    concept __indirectly_readable_impl = requires
      {
 typename iter_value_t<_In>;
 typename iter_reference_t<_In>;
 typename iter_rvalue_reference_t<_In>;
 requires same_as<iter_reference_t<const _In>,
    iter_reference_t<_In>>;
 requires same_as<iter_rvalue_reference_t<const _In>,
    iter_rvalue_reference_t<_In>>;
      }
      && common_reference_with<iter_reference_t<_In>&&, iter_value_t<_In>&>
      && common_reference_with<iter_reference_t<_In>&&,
         iter_rvalue_reference_t<_In>&&>
      && common_reference_with<iter_rvalue_reference_t<_In>&&,
          const iter_value_t<_In>&>;

  }


  template<typename _In>
    concept indirectly_readable
      = __detail::__indirectly_readable_impl<remove_cvref_t<_In>>;

  template<indirectly_readable _Tp>
    using iter_common_reference_t
      = common_reference_t<iter_reference_t<_Tp>, iter_value_t<_Tp>&>;


  template<typename _Out, typename _Tp>
    concept indirectly_writable = requires(_Out&& __o, _Tp&& __t)
      {
 *__o = std::forward<_Tp>(__t);
 *std::forward<_Out>(__o) = std::forward<_Tp>(__t);
 const_cast<const iter_reference_t<_Out>&&>(*__o)
   = std::forward<_Tp>(__t);
 const_cast<const iter_reference_t<_Out>&&>(*std::forward<_Out>(__o))
   = std::forward<_Tp>(__t);
      };

  namespace ranges::__detail
  {
    class __max_diff_type;
    class __max_size_type;

    __extension__
    template<typename _Tp>
      concept __is_signed_int128

 = same_as<_Tp, __int128>;




    __extension__
    template<typename _Tp>
      concept __is_unsigned_int128

 = same_as<_Tp, unsigned __int128>;




    template<typename _Tp>
      concept __cv_bool = same_as<const volatile _Tp, const volatile bool>;

    template<typename _Tp>
      concept __integral_nonbool = integral<_Tp> && !__cv_bool<_Tp>;

    template<typename _Tp>
      concept __is_int128 = __is_signed_int128<_Tp> || __is_unsigned_int128<_Tp>;

    template<typename _Tp>
      concept __is_integer_like = __integral_nonbool<_Tp>
 || __is_int128<_Tp>
 || same_as<_Tp, __max_diff_type> || same_as<_Tp, __max_size_type>;

    template<typename _Tp>
      concept __is_signed_integer_like = signed_integral<_Tp>
 || __is_signed_int128<_Tp>
 || same_as<_Tp, __max_diff_type>;

  }

  namespace __detail { using ranges::__detail::__is_signed_integer_like; }


  template<typename _Iter>
    concept weakly_incrementable = movable<_Iter>
      && requires(_Iter __i)
      {
 typename iter_difference_t<_Iter>;
 requires __detail::__is_signed_integer_like<iter_difference_t<_Iter>>;
 { ++__i } -> same_as<_Iter&>;
 __i++;
      };

  template<typename _Iter>
    concept incrementable = regular<_Iter> && weakly_incrementable<_Iter>
      && requires(_Iter __i) { { __i++ } -> same_as<_Iter>; };

  template<typename _Iter>
    concept input_or_output_iterator
      = requires(_Iter __i) { { *__i } -> __detail::__can_reference; }
 && weakly_incrementable<_Iter>;

  template<typename _Sent, typename _Iter>
    concept sentinel_for = semiregular<_Sent>
      && input_or_output_iterator<_Iter>
      && __detail::__weakly_eq_cmp_with<_Sent, _Iter>;

  template<typename _Sent, typename _Iter>
    inline constexpr bool disable_sized_sentinel_for = false;

  template<typename _Sent, typename _Iter>
    concept sized_sentinel_for = sentinel_for<_Sent, _Iter>
    && !disable_sized_sentinel_for<remove_cv_t<_Sent>, remove_cv_t<_Iter>>
    && requires(const _Iter& __i, const _Sent& __s)
    {
      { __s - __i } -> same_as<iter_difference_t<_Iter>>;
      { __i - __s } -> same_as<iter_difference_t<_Iter>>;
    };

  template<typename _Iter>
    concept input_iterator = input_or_output_iterator<_Iter>
      && indirectly_readable<_Iter>
      && requires { typename __detail::__iter_concept<_Iter>; }
      && derived_from<__detail::__iter_concept<_Iter>, input_iterator_tag>;

  template<typename _Iter, typename _Tp>
    concept output_iterator = input_or_output_iterator<_Iter>
      && indirectly_writable<_Iter, _Tp>
      && requires(_Iter __i, _Tp&& __t) { *__i++ = std::forward<_Tp>(__t); };

  template<typename _Iter>
    concept forward_iterator = input_iterator<_Iter>
      && derived_from<__detail::__iter_concept<_Iter>, forward_iterator_tag>
      && incrementable<_Iter> && sentinel_for<_Iter, _Iter>;

  template<typename _Iter>
    concept bidirectional_iterator = forward_iterator<_Iter>
      && derived_from<__detail::__iter_concept<_Iter>,
        bidirectional_iterator_tag>
      && requires(_Iter __i)
      {
 { --__i } -> same_as<_Iter&>;
 { __i-- } -> same_as<_Iter>;
      };

  template<typename _Iter>
    concept random_access_iterator = bidirectional_iterator<_Iter>
      && derived_from<__detail::__iter_concept<_Iter>,
        random_access_iterator_tag>
      && totally_ordered<_Iter> && sized_sentinel_for<_Iter, _Iter>
      && requires(_Iter __i, const _Iter __j,
    const iter_difference_t<_Iter> __n)
      {
 { __i += __n } -> same_as<_Iter&>;
 { __j + __n } -> same_as<_Iter>;
 { __n + __j } -> same_as<_Iter>;
 { __i -= __n } -> same_as<_Iter&>;
 { __j - __n } -> same_as<_Iter>;
 { __j[__n] } -> same_as<iter_reference_t<_Iter>>;
      };

  template<typename _Iter>
    concept contiguous_iterator = random_access_iterator<_Iter>
      && derived_from<__detail::__iter_concept<_Iter>, contiguous_iterator_tag>
      && is_lvalue_reference_v<iter_reference_t<_Iter>>
      && same_as<iter_value_t<_Iter>, remove_cvref_t<iter_reference_t<_Iter>>>
      && requires(const _Iter& __i)
      {
 { std::to_address(__i) }
   -> same_as<add_pointer_t<iter_reference_t<_Iter>>>;
      };





  template<typename _Fn, typename _Iter>
    concept indirectly_unary_invocable = indirectly_readable<_Iter>
      && copy_constructible<_Fn> && invocable<_Fn&, iter_value_t<_Iter>&>
      && invocable<_Fn&, iter_reference_t<_Iter>>
      && invocable<_Fn&, iter_common_reference_t<_Iter>>
      && common_reference_with<invoke_result_t<_Fn&, iter_value_t<_Iter>&>,
          invoke_result_t<_Fn&, iter_reference_t<_Iter>>>;

  template<typename _Fn, typename _Iter>
    concept indirectly_regular_unary_invocable = indirectly_readable<_Iter>
      && copy_constructible<_Fn>
      && regular_invocable<_Fn&, iter_value_t<_Iter>&>
      && regular_invocable<_Fn&, iter_reference_t<_Iter>>
      && regular_invocable<_Fn&, iter_common_reference_t<_Iter>>
      && common_reference_with<invoke_result_t<_Fn&, iter_value_t<_Iter>&>,
          invoke_result_t<_Fn&, iter_reference_t<_Iter>>>;

  template<typename _Fn, typename _Iter>
    concept indirect_unary_predicate = indirectly_readable<_Iter>
      && copy_constructible<_Fn> && predicate<_Fn&, iter_value_t<_Iter>&>
      && predicate<_Fn&, iter_reference_t<_Iter>>
      && predicate<_Fn&, iter_common_reference_t<_Iter>>;

  template<typename _Fn, typename _I1, typename _I2>
    concept indirect_binary_predicate
      = indirectly_readable<_I1> && indirectly_readable<_I2>
      && copy_constructible<_Fn>
      && predicate<_Fn&, iter_value_t<_I1>&, iter_value_t<_I2>&>
      && predicate<_Fn&, iter_value_t<_I1>&, iter_reference_t<_I2>>
      && predicate<_Fn&, iter_reference_t<_I1>, iter_value_t<_I2>&>
      && predicate<_Fn&, iter_reference_t<_I1>, iter_reference_t<_I2>>
      && predicate<_Fn&, iter_common_reference_t<_I1>,
     iter_common_reference_t<_I2>>;

  template<typename _Fn, typename _I1, typename _I2 = _I1>
    concept indirect_equivalence_relation
      = indirectly_readable<_I1> && indirectly_readable<_I2>
      && copy_constructible<_Fn>
      && equivalence_relation<_Fn&, iter_value_t<_I1>&, iter_value_t<_I2>&>
      && equivalence_relation<_Fn&, iter_value_t<_I1>&, iter_reference_t<_I2>>
      && equivalence_relation<_Fn&, iter_reference_t<_I1>, iter_value_t<_I2>&>
      && equivalence_relation<_Fn&, iter_reference_t<_I1>,
         iter_reference_t<_I2>>
      && equivalence_relation<_Fn&, iter_common_reference_t<_I1>,
         iter_common_reference_t<_I2>>;

  template<typename _Fn, typename _I1, typename _I2 = _I1>
    concept indirect_strict_weak_order
      = indirectly_readable<_I1> && indirectly_readable<_I2>
      && copy_constructible<_Fn>
      && strict_weak_order<_Fn&, iter_value_t<_I1>&, iter_value_t<_I2>&>
      && strict_weak_order<_Fn&, iter_value_t<_I1>&, iter_reference_t<_I2>>
      && strict_weak_order<_Fn&, iter_reference_t<_I1>, iter_value_t<_I2>&>
      && strict_weak_order<_Fn&, iter_reference_t<_I1>, iter_reference_t<_I2>>
      && strict_weak_order<_Fn&, iter_common_reference_t<_I1>,
      iter_common_reference_t<_I2>>;

  template<typename _Fn, typename... _Is>
    requires (indirectly_readable<_Is> && ...)
      && invocable<_Fn, iter_reference_t<_Is>...>
    using indirect_result_t = invoke_result_t<_Fn, iter_reference_t<_Is>...>;

  namespace __detail
  {
    template<typename _Iter, typename _Proj>
      struct __projected
      {
 struct __type
 {
   using value_type = remove_cvref_t<indirect_result_t<_Proj&, _Iter>>;
   indirect_result_t<_Proj&, _Iter> operator*() const;
 };
      };

    template<weakly_incrementable _Iter, typename _Proj>
      struct __projected<_Iter, _Proj>
      {
 struct __type
 {
   using value_type = remove_cvref_t<indirect_result_t<_Proj&, _Iter>>;
   using difference_type = iter_difference_t<_Iter>;
   indirect_result_t<_Proj&, _Iter> operator*() const;
 };
      };
  }


  template<indirectly_readable _Iter,
    indirectly_regular_unary_invocable<_Iter> _Proj>
    using projected = typename __detail::__projected<_Iter, _Proj>::__type;





  template<typename _In, typename _Out>
    concept indirectly_movable = indirectly_readable<_In>
      && indirectly_writable<_Out, iter_rvalue_reference_t<_In>>;

  template<typename _In, typename _Out>
    concept indirectly_movable_storable = indirectly_movable<_In, _Out>
      && indirectly_writable<_Out, iter_value_t<_In>>
      && movable<iter_value_t<_In>>
      && constructible_from<iter_value_t<_In>, iter_rvalue_reference_t<_In>>
      && assignable_from<iter_value_t<_In>&, iter_rvalue_reference_t<_In>>;


  template<typename _In, typename _Out>
    concept indirectly_copyable = indirectly_readable<_In>
      && indirectly_writable<_Out, iter_reference_t<_In>>;

  template<typename _In, typename _Out>
    concept indirectly_copyable_storable = indirectly_copyable<_In, _Out>
      && indirectly_writable<_Out, iter_value_t<_In>&>
      && indirectly_writable<_Out, const iter_value_t<_In>&>
      && indirectly_writable<_Out, iter_value_t<_In>&&>
      && indirectly_writable<_Out, const iter_value_t<_In>&&>
      && copyable<iter_value_t<_In>>
      && constructible_from<iter_value_t<_In>, iter_reference_t<_In>>
      && assignable_from<iter_value_t<_In>&, iter_reference_t<_In>>;

namespace ranges
{

  namespace __iswap
  {
    template<typename _It1, typename _It2>
      void iter_swap(_It1, _It2) = delete;

    template<typename _Tp, typename _Up>
      concept __adl_iswap
 = (std::__detail::__class_or_enum<remove_reference_t<_Tp>>
   || std::__detail::__class_or_enum<remove_reference_t<_Up>>)
 && requires(_Tp&& __t, _Up&& __u) {
   iter_swap(static_cast<_Tp&&>(__t), static_cast<_Up&&>(__u));
 };

    template<typename _Xp, typename _Yp>
      constexpr iter_value_t<_Xp>
      __iter_exchange_move(_Xp&& __x, _Yp&& __y)
      noexcept(noexcept(iter_value_t<_Xp>(iter_move(__x)))
        && noexcept(*__x = iter_move(__y)))
      {
 iter_value_t<_Xp> __old_value(iter_move(__x));
 *__x = iter_move(__y);
 return __old_value;
      }

    struct _IterSwap
    {
    private:
      template<typename _Tp, typename _Up>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (__adl_iswap<_Tp, _Up>)
     return noexcept(iter_swap(std::declval<_Tp>(),
          std::declval<_Up>()));
   else if constexpr (indirectly_readable<_Tp>
       && indirectly_readable<_Up>
       && swappable_with<iter_reference_t<_Tp>, iter_reference_t<_Up>>)
     return noexcept(ranges::swap(*std::declval<_Tp>(),
      *std::declval<_Up>()));
   else
     return noexcept(*std::declval<_Tp>()
  = __iswap::__iter_exchange_move(std::declval<_Up>(),
          std::declval<_Tp>()));
 }

    public:
      template<typename _Tp, typename _Up>
 requires __adl_iswap<_Tp, _Up>
 || (indirectly_readable<remove_reference_t<_Tp>>
     && indirectly_readable<remove_reference_t<_Up>>
     && swappable_with<iter_reference_t<_Tp>, iter_reference_t<_Up>>)
 || (indirectly_movable_storable<_Tp, _Up>
     && indirectly_movable_storable<_Up, _Tp>)
 constexpr void
 operator()(_Tp&& __e1, _Up&& __e2) const
 noexcept(_S_noexcept<_Tp, _Up>())
 {
   if constexpr (__adl_iswap<_Tp, _Up>)
     iter_swap(static_cast<_Tp&&>(__e1), static_cast<_Up&&>(__e2));
   else if constexpr (indirectly_readable<_Tp>
       && indirectly_readable<_Up>
       && swappable_with<iter_reference_t<_Tp>, iter_reference_t<_Up>>)
     ranges::swap(*__e1, *__e2);
   else
     *__e1 = __iswap::__iter_exchange_move(__e2, __e1);
 }
    };
  }


  inline namespace _Cpo {
    inline constexpr __iswap::_IterSwap iter_swap{};
  }

}


  template<typename _I1, typename _I2 = _I1>
    concept indirectly_swappable
      = indirectly_readable<_I1> && indirectly_readable<_I2>
      && requires(const _I1 __i1, const _I2 __i2)
      {
 ranges::iter_swap(__i1, __i1);
 ranges::iter_swap(__i2, __i2);
 ranges::iter_swap(__i1, __i2);
 ranges::iter_swap(__i2, __i1);
      };


  template<typename _I1, typename _I2, typename _Rel, typename _P1 = identity,
    typename _P2 = identity>
    concept indirectly_comparable
      = indirect_binary_predicate<_Rel, projected<_I1, _P1>,
      projected<_I2, _P2>>;


  template<typename _Iter>
    concept permutable = forward_iterator<_Iter>
      && indirectly_movable_storable<_Iter, _Iter>
      && indirectly_swappable<_Iter, _Iter>;


  template<typename _I1, typename _I2, typename _Out,
    typename _Rel = ranges::less, typename _P1 = identity,
    typename _P2 = identity>
    concept mergeable = input_iterator<_I1> && input_iterator<_I2>
      && weakly_incrementable<_Out> && indirectly_copyable<_I1, _Out>
      && indirectly_copyable<_I2, _Out>
      && indirect_strict_weak_order<_Rel, projected<_I1, _P1>,
        projected<_I2, _P2>>;


  template<typename _Iter, typename _Rel = ranges::less,
    typename _Proj = identity>
    concept sortable = permutable<_Iter>
      && indirect_strict_weak_order<_Rel, projected<_Iter, _Proj>>;

  struct unreachable_sentinel_t
  {
    template<weakly_incrementable _It>
      friend constexpr bool
      operator==(unreachable_sentinel_t, const _It&) noexcept
      { return false; }
  };

  inline constexpr unreachable_sentinel_t unreachable_sentinel{};


  namespace ranges::__access
  {
    using std::__detail::__class_or_enum;

    struct _Decay_copy final
    {
      template<typename _Tp>
 constexpr decay_t<_Tp>
 operator()(_Tp&& __t) const
 noexcept(is_nothrow_convertible_v<_Tp, decay_t<_Tp>>)
 { return std::forward<_Tp>(__t); }
    } inline constexpr __decay_copy{};

    template<typename _Tp>
      concept __member_begin = requires(_Tp& __t)
 {
   { __decay_copy(__t.begin()) } -> input_or_output_iterator;
 };


    void begin() = delete;

    template<typename _Tp>
      concept __adl_begin = __class_or_enum<remove_reference_t<_Tp>>
 && requires(_Tp& __t)
 {
   { __decay_copy(begin(__t)) } -> input_or_output_iterator;
 };



    template<typename _Tp>
      requires is_array_v<_Tp> || __member_begin<_Tp&> || __adl_begin<_Tp&>
      auto
      __begin(_Tp& __t)
      {
 if constexpr (is_array_v<_Tp>)
   return __t + 0;
 else if constexpr (__member_begin<_Tp&>)
   return __t.begin();
 else
   return begin(__t);
      }
  }

  namespace __detail
  {

    template<typename _Tp>
      using __range_iter_t
 = decltype(ranges::__access::__begin(std::declval<_Tp&>()));

  }



}
# 72 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_iterator_base_types.h" 2 3


namespace std
{

# 93 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_iterator_base_types.h" 3
  struct input_iterator_tag { };


  struct output_iterator_tag { };


  struct forward_iterator_tag : public input_iterator_tag { };



  struct bidirectional_iterator_tag : public forward_iterator_tag { };



  struct random_access_iterator_tag : public bidirectional_iterator_tag { };



  struct contiguous_iterator_tag : public random_access_iterator_tag { };
# 125 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_iterator_base_types.h" 3
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct [[__deprecated__]] iterator
    {

      typedef _Category iterator_category;

      typedef _Tp value_type;

      typedef _Distance difference_type;

      typedef _Pointer pointer;

      typedef _Reference reference;
    };
# 149 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_iterator_base_types.h" 3
  template<typename _Iterator>
    struct iterator_traits;




  template<typename _Iterator, typename = __void_t<>>
    struct __iterator_traits { };
# 176 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_iterator_base_types.h" 3
  template<typename _Iterator>
    struct iterator_traits
    : public __iterator_traits<_Iterator> { };
# 194 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_iterator_base_types.h" 3
  template<typename _Tp>

    requires is_object_v<_Tp>

    struct iterator_traits<_Tp*>
    {
      using iterator_concept = contiguous_iterator_tag;
      using iterator_category = random_access_iterator_tag;
      using value_type = remove_cv_t<_Tp>;
      using difference_type = ptrdiff_t;
      using pointer = _Tp*;
      using reference = _Tp&;
    };
# 235 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_iterator_base_types.h" 3
  template<typename _Iter>
    __attribute__((__always_inline__))
    inline constexpr
    typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }




  template<typename _Iter>
    using __iter_category_t
      = typename iterator_traits<_Iter>::iterator_category;

  template<typename _InIter>
    using _RequireInputIter =
      __enable_if_t<is_convertible<__iter_category_t<_InIter>,
       input_iterator_tag>::value>;

  template<typename _It,
    typename _Cat = __iter_category_t<_It>>
    struct __is_random_access_iter
      : is_base_of<random_access_iterator_tag, _Cat>
    {
      typedef is_base_of<random_access_iterator_tag, _Cat> _Base;
      enum { __value = _Base::value };
    };








}
# 66 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_algobase.h" 2 3
# 1 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_iterator_base_funcs.h" 1 3
# 62 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_iterator_base_funcs.h" 3
       
# 63 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_iterator_base_funcs.h" 3

# 1 "D:/Programs/MinGW/include/c++/14.2.0/bits/concept_check.h" 1 3
# 33 "D:/Programs/MinGW/include/c++/14.2.0/bits/concept_check.h" 3
       
# 34 "D:/Programs/MinGW/include/c++/14.2.0/bits/concept_check.h" 3
# 65 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_iterator_base_funcs.h" 2 3
# 1 "D:/Programs/MinGW/include/c++/14.2.0/debug/assertions.h" 1 3
# 66 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_iterator_base_funcs.h" 2 3


namespace std
{




  template <typename> struct _List_iterator;
  template <typename> struct _List_const_iterator;


  template<typename _InputIterator>
    inline constexpr
    typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {

     

      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }

  template<typename _RandomAccessIterator>
    __attribute__((__always_inline__))
    inline constexpr
    typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {

     

      return __last - __first;
    }



  template<typename _Tp>
    ptrdiff_t
    __distance(std::_List_iterator<_Tp>,
        std::_List_iterator<_Tp>,
        input_iterator_tag);

  template<typename _Tp>
    ptrdiff_t
    __distance(std::_List_const_iterator<_Tp>,
        std::_List_const_iterator<_Tp>,
        input_iterator_tag);




  template<typename _OutputIterator>
    void
    __distance(_OutputIterator, _OutputIterator, output_iterator_tag) = delete;
# 144 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator>
    [[__nodiscard__]] __attribute__((__always_inline__))
    inline constexpr
    typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {

      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Distance>
    inline constexpr void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {

     
      do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__n >= 0), false)) std::__glibcxx_assert_fail(); } while (false);
      while (__n--)
 ++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline constexpr void
    __advance(_BidirectionalIterator& __i, _Distance __n,
       bidirectional_iterator_tag)
    {

     

      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline constexpr void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {

     

      if (__builtin_constant_p(__n) && __n == 1)
 ++__i;
      else if (__builtin_constant_p(__n) && __n == -1)
 --__i;
      else
 __i += __n;
    }



  template<typename _OutputIterator, typename _Distance>
    void
    __advance(_OutputIterator&, _Distance, output_iterator_tag) = delete;
# 217 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator, typename _Distance>
    __attribute__((__always_inline__))
    inline constexpr void
    advance(_InputIterator& __i, _Distance __n)
    {

      typename iterator_traits<_InputIterator>::difference_type __d = __n;
      std::__advance(__i, __d, std::__iterator_category(__i));
    }



  template<typename _InputIterator>
    [[__nodiscard__]] [[__gnu__::__always_inline__]]
    inline constexpr _InputIterator
    next(_InputIterator __x, typename
  iterator_traits<_InputIterator>::difference_type __n = 1)
    {

     
      std::advance(__x, __n);
      return __x;
    }

  template<typename _BidirectionalIterator>
    [[__nodiscard__]] [[__gnu__::__always_inline__]]
    inline constexpr _BidirectionalIterator
    prev(_BidirectionalIterator __x, typename
  iterator_traits<_BidirectionalIterator>::difference_type __n = 1)
    {

     

      std::advance(__x, -__n);
      return __x;
    }




}
# 67 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_algobase.h" 2 3
# 1 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_iterator.h" 1 3
# 75 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_iterator.h" 3
# 1 "D:/Programs/MinGW/include/c++/14.2.0/new" 1 3
# 38 "D:/Programs/MinGW/include/c++/14.2.0/new" 3
       
# 39 "D:/Programs/MinGW/include/c++/14.2.0/new" 3


# 1 "D:/Programs/MinGW/include/c++/14.2.0/bits/exception.h" 1 3
# 34 "D:/Programs/MinGW/include/c++/14.2.0/bits/exception.h" 3
       
# 35 "D:/Programs/MinGW/include/c++/14.2.0/bits/exception.h" 3



extern "C++" {

namespace std
{
# 59 "D:/Programs/MinGW/include/c++/14.2.0/bits/exception.h" 3
  class exception
  {
  public:
    exception() noexcept { }
    virtual ~exception() noexcept;

    exception(const exception&) = default;
    exception& operator=(const exception&) = default;
    exception(exception&&) = default;
    exception& operator=(exception&&) = default;




    virtual const char*
    what() const noexcept;
  };



}

}
# 42 "D:/Programs/MinGW/include/c++/14.2.0/new" 2 3




# 1 "D:/Programs/MinGW/include/c++/14.2.0/bits/version.h" 1 3
# 47 "D:/Programs/MinGW/include/c++/14.2.0/bits/version.h" 3
       
# 48 "D:/Programs/MinGW/include/c++/14.2.0/bits/version.h" 3
# 47 "D:/Programs/MinGW/include/c++/14.2.0/new" 2 3

#pragma GCC visibility push(default)

extern "C++" {

namespace std
{






  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }


    bad_alloc(const bad_alloc&) = default;
    bad_alloc& operator=(const bad_alloc&) = default;




    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };


  class bad_array_new_length : public bad_alloc
  {
  public:
    bad_array_new_length() throw() { }



    virtual ~bad_array_new_length() throw();


    virtual const char* what() const throw();
  };



  enum class align_val_t: size_t {};


  struct nothrow_t
  {

    explicit nothrow_t() = default;

  };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();



  new_handler get_new_handler() noexcept;

}
# 131 "D:/Programs/MinGW/include/c++/14.2.0/new" 3
[[__nodiscard__]] void* operator new(std::size_t)
  __attribute__((__externally_visible__));
[[__nodiscard__]] void* operator new[](std::size_t)
  __attribute__((__externally_visible__));
void operator delete(void*) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*) noexcept
  __attribute__((__externally_visible__));

void operator delete(void*, std::size_t) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, std::size_t) noexcept
  __attribute__((__externally_visible__));

[[__nodiscard__]] void* operator new(std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
[[__nodiscard__]] void* operator new[](std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
void operator delete(void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));

[[__nodiscard__]] void* operator new(std::size_t, std::align_val_t)
  __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
[[__nodiscard__]] void* operator new(std::size_t, std::align_val_t, const std::nothrow_t&)
  noexcept __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
void operator delete(void*, std::align_val_t)
  noexcept __attribute__((__externally_visible__));
void operator delete(void*, std::align_val_t, const std::nothrow_t&)
  noexcept __attribute__((__externally_visible__));
[[__nodiscard__]] void* operator new[](std::size_t, std::align_val_t)
  __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
[[__nodiscard__]] void* operator new[](std::size_t, std::align_val_t, const std::nothrow_t&)
  noexcept __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
void operator delete[](void*, std::align_val_t)
  noexcept __attribute__((__externally_visible__));
void operator delete[](void*, std::align_val_t, const std::nothrow_t&)
  noexcept __attribute__((__externally_visible__));

void operator delete(void*, std::size_t, std::align_val_t)
  noexcept __attribute__((__externally_visible__));
void operator delete[](void*, std::size_t, std::align_val_t)
  noexcept __attribute__((__externally_visible__));




[[__nodiscard__]] inline void* operator new(std::size_t, void* __p) noexcept
{ return __p; }
[[__nodiscard__]] inline void* operator new[](std::size_t, void* __p) noexcept
{ return __p; }


inline void operator delete (void*, void*) noexcept { }
inline void operator delete[](void*, void*) noexcept { }

}


namespace std
{


  template<typename _Tp>
    [[nodiscard]] constexpr _Tp*
    launder(_Tp* __p) noexcept
    { return __builtin_launder(__p); }




  template<typename _Ret, typename... _Args , bool _NE>
    void launder(_Ret (*)(_Args...) noexcept (_NE)) = delete;
  template<typename _Ret, typename... _Args , bool _NE>
    void launder(_Ret (*)(_Args......) noexcept (_NE)) = delete;

  void launder(void*) = delete;
  void launder(const void*) = delete;
  void launder(volatile void*) = delete;
  void launder(const volatile void*) = delete;



  inline constexpr size_t hardware_destructive_interference_size = 64;
  inline constexpr size_t hardware_constructive_interference_size = 64;

}




namespace std
{


  struct destroying_delete_t
  {
    explicit destroying_delete_t() = default;
  };

  inline constexpr destroying_delete_t destroying_delete{};
}


#pragma GCC visibility pop
# 76 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_iterator.h" 2 3


# 1 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_construct.h" 1 3
# 73 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_construct.h" 3
namespace std
{



  template <typename _Tp>
    constexpr inline void
    destroy_at(_Tp* __location)
    {
      if constexpr (202302L > 201703L && is_array_v<_Tp>)
 {
   for (auto& __x : *__location)
     std::destroy_at(std::__addressof(__x));
 }
      else
 __location->~_Tp();
    }


  template<typename _Tp, typename... _Args>
    constexpr auto
    construct_at(_Tp* __location, _Args&&... __args)
    noexcept(noexcept(::new((void*)0) _Tp(std::declval<_Args>()...)))
    -> decltype(::new((void*)0) _Tp(std::declval<_Args>()...))
    { return ::new((void*)__location) _Tp(std::forward<_Args>(__args)...); }
# 106 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_construct.h" 3
  template<typename _Tp, typename... _Args>
    constexpr
    inline void
    _Construct(_Tp* __p, _Args&&... __args)
    {

      if (std::__is_constant_evaluated())
 {

   std::construct_at(__p, std::forward<_Args>(__args)...);
   return;
 }

      ::new((void*)__p) _Tp(std::forward<_Args>(__args)...);
    }
# 132 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_construct.h" 3
  template<typename _T1>
    inline void
    _Construct_novalue(_T1* __p)
    { ::new((void*)__p) _T1; }

  template<typename _ForwardIterator>
    constexpr void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last);




  template<typename _Tp>
    constexpr inline void
    _Destroy(_Tp* __pointer)
    {

      std::destroy_at(__pointer);



    }

  template<bool>
    struct _Destroy_aux
    {
      template<typename _ForwardIterator>
 static constexpr void
 __destroy(_ForwardIterator __first, _ForwardIterator __last)
 {
   for (; __first != __last; ++__first)
     std::_Destroy(std::__addressof(*__first));
 }
    };

  template<>
    struct _Destroy_aux<true>
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator, _ForwardIterator) { }
    };






  template<typename _ForwardIterator>
    constexpr inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;


      static_assert(is_destructible<_Value_type>::value,
      "value type is destructible");


      if (std::__is_constant_evaluated())
 return std::_Destroy_aux<false>::__destroy(__first, __last);

      std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::
 __destroy(__first, __last);
    }

  template<bool>
    struct _Destroy_n_aux
    {
      template<typename _ForwardIterator, typename _Size>
 static constexpr _ForwardIterator
 __destroy_n(_ForwardIterator __first, _Size __count)
 {
   for (; __count > 0; (void)++__first, --__count)
     std::_Destroy(std::__addressof(*__first));
   return __first;
 }
    };

  template<>
    struct _Destroy_n_aux<true>
    {
      template<typename _ForwardIterator, typename _Size>
        static _ForwardIterator
        __destroy_n(_ForwardIterator __first, _Size __count)
 {
   std::advance(__first, __count);
   return __first;
 }
    };






  template<typename _ForwardIterator, typename _Size>
    constexpr inline _ForwardIterator
    _Destroy_n(_ForwardIterator __first, _Size __count)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;


      static_assert(is_destructible<_Value_type>::value,
      "value type is destructible");


      if (std::__is_constant_evaluated())
 return std::_Destroy_n_aux<false>::__destroy_n(__first, __count);

      return std::_Destroy_n_aux<__has_trivial_destructor(_Value_type)>::
 __destroy_n(__first, __count);
    }


  template <typename _ForwardIterator>
    constexpr inline void
    destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      std::_Destroy(__first, __last);
    }

  template <typename _ForwardIterator, typename _Size>
    constexpr inline _ForwardIterator
    destroy_n(_ForwardIterator __first, _Size __count)
    {
      return std::_Destroy_n(__first, __count);
    }



}
# 79 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_iterator.h" 2 3






namespace std
{








  namespace __detail
  {


    template<typename _Cat, typename _Limit, typename _Otherwise = _Cat>
      using __clamp_iter_cat
 = __conditional_t<derived_from<_Cat, _Limit>, _Limit, _Otherwise>;
  }



#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
# 128 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
      template<typename _Iter>
 friend class reverse_iterator;




      template<typename _Iter>
 static constexpr bool __convertible = !is_same_v<_Iter, _Iterator>
     && convertible_to<const _Iter&, _Iterator>;


    protected:
      _Iterator current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::pointer pointer;




      using iterator_concept
 = __conditional_t<random_access_iterator<_Iterator>,
     random_access_iterator_tag,
     bidirectional_iterator_tag>;
      using iterator_category
 = __detail::__clamp_iter_cat<typename __traits_type::iterator_category,
         random_access_iterator_tag>;
      using value_type = iter_value_t<_Iterator>;
      using difference_type = iter_difference_t<_Iterator>;
      using reference = iter_reference_t<_Iterator>;
# 178 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_iterator.h" 3
      constexpr
      reverse_iterator()
      noexcept(noexcept(_Iterator()))
      : current()
      { }




      explicit constexpr
      reverse_iterator(iterator_type __x)
      noexcept(noexcept(_Iterator(__x)))
      : current(__x)
      { }




      constexpr
      reverse_iterator(const reverse_iterator& __x)
      noexcept(noexcept(_Iterator(__x.current)))
      : current(__x.current)
      { }


      reverse_iterator& operator=(const reverse_iterator&) = default;






      template<typename _Iter>

 requires __convertible<_Iter>

 constexpr
        reverse_iterator(const reverse_iterator<_Iter>& __x)
 noexcept(noexcept(_Iterator(__x.current)))
 : current(__x.current)
 { }


      template<typename _Iter>

 requires __convertible<_Iter>
   && assignable_from<_Iterator&, const _Iter&>

 constexpr
 reverse_iterator&
 operator=(const reverse_iterator<_Iter>& __x)
 noexcept(noexcept(current = __x.current))
 {
   current = __x.current;
   return *this;
 }





      [[__nodiscard__]]
      constexpr iterator_type
      base() const
      noexcept(noexcept(_Iterator(current)))
      { return current; }
# 255 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_iterator.h" 3
      [[__nodiscard__]]
      constexpr reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }






      [[__nodiscard__]]
      constexpr pointer
      operator->() const

      requires is_pointer_v<_Iterator>
 || requires(const _Iterator __i) { __i.operator->(); }

      {


 _Iterator __tmp = current;
 --__tmp;
 return _S_to_pointer(__tmp);
      }






      constexpr reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }






      constexpr reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }






      constexpr reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }






      constexpr reverse_iterator
      operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }






      [[__nodiscard__]]
      constexpr reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }







      constexpr reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }






      [[__nodiscard__]]
      constexpr reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }







      constexpr reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }






      [[__nodiscard__]]
      constexpr reference
      operator[](difference_type __n) const
      { return *(*this + __n); }


      [[nodiscard]]
      friend constexpr iter_rvalue_reference_t<_Iterator>
      iter_move(const reverse_iterator& __i)
      noexcept(is_nothrow_copy_constructible_v<_Iterator>
        && noexcept(ranges::iter_move(--std::declval<_Iterator&>())))
      {
 auto __tmp = __i.base();
 return ranges::iter_move(--__tmp);
      }

      template<indirectly_swappable<_Iterator> _Iter2>
 friend constexpr void
 iter_swap(const reverse_iterator& __x,
    const reverse_iterator<_Iter2>& __y)
 noexcept(is_nothrow_copy_constructible_v<_Iterator>
   && is_nothrow_copy_constructible_v<_Iter2>
   && noexcept(ranges::iter_swap(--std::declval<_Iterator&>(),
            --std::declval<_Iter2&>())))
 {
   auto __xtmp = __x.base();
   auto __ytmp = __y.base();
   ranges::iter_swap(--__xtmp, --__ytmp);
 }


    private:
      template<typename _Tp>
 static constexpr _Tp*
 _S_to_pointer(_Tp* __p)
        { return __p; }

      template<typename _Tp>
 static constexpr pointer
 _S_to_pointer(_Tp __t)
        { return __t.operator->(); }
    };
# 524 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR>
    [[nodiscard]]
    constexpr bool
    operator==(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    requires requires { { __x.base() == __y.base() } -> convertible_to<bool>; }
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    [[nodiscard]]
    constexpr bool
    operator!=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    requires requires { { __x.base() != __y.base() } -> convertible_to<bool>; }
    { return __x.base() != __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    [[nodiscard]]
    constexpr bool
    operator<(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    requires requires { { __x.base() > __y.base() } -> convertible_to<bool>; }
    { return __x.base() > __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    [[nodiscard]]
    constexpr bool
    operator>(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    requires requires { { __x.base() < __y.base() } -> convertible_to<bool>; }
    { return __x.base() < __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    [[nodiscard]]
    constexpr bool
    operator<=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    requires requires { { __x.base() >= __y.base() } -> convertible_to<bool>; }
    { return __x.base() >= __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    [[nodiscard]]
    constexpr bool
    operator>=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    requires requires { { __x.base() <= __y.base() } -> convertible_to<bool>; }
    { return __x.base() <= __y.base(); }

  template<typename _IteratorL,
    three_way_comparable_with<_IteratorL> _IteratorR>
    [[nodiscard]]
    constexpr compare_three_way_result_t<_IteratorL, _IteratorR>
    operator<=>(const reverse_iterator<_IteratorL>& __x,
  const reverse_iterator<_IteratorR>& __y)
    { return __y.base() <=> __x.base(); }




  template<typename _Iterator>
    [[nodiscard]]
    constexpr bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    requires requires { { __x.base() == __y.base() } -> convertible_to<bool>; }
    { return __x.base() == __y.base(); }

  template<three_way_comparable _Iterator>
    [[nodiscard]]
    constexpr compare_three_way_result_t<_Iterator, _Iterator>
    operator<=>(const reverse_iterator<_Iterator>& __x,
  const reverse_iterator<_Iterator>& __y)
    { return __y.base() <=> __x.base(); }
# 615 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR>
    [[__nodiscard__]]
    inline constexpr auto
    operator-(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    -> decltype(__y.base() - __x.base())
    { return __y.base() - __x.base(); }


  template<typename _Iterator>
    [[__nodiscard__]]
    inline constexpr reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }



  template<typename _Iterator>
    inline constexpr reverse_iterator<_Iterator>
    __make_reverse_iterator(_Iterator __i)
    { return reverse_iterator<_Iterator>(__i); }





  template<typename _Iterator>
    [[__nodiscard__]]
    inline constexpr reverse_iterator<_Iterator>
    make_reverse_iterator(_Iterator __i)
    { return reverse_iterator<_Iterator>(__i); }


  template<typename _Iterator1, typename _Iterator2>
    requires (!sized_sentinel_for<_Iterator1, _Iterator2>)
    inline constexpr bool
    disable_sized_sentinel_for<reverse_iterator<_Iterator1>,
          reverse_iterator<_Iterator2>> = true;



  template<typename _Iterator>
    constexpr
    auto
    __niter_base(reverse_iterator<_Iterator> __it)
    -> decltype(__make_reverse_iterator(__niter_base(__it.base())))
    { return __make_reverse_iterator(__niter_base(__it.base())); }

  template<typename _Iterator>
    struct __is_move_iterator<reverse_iterator<_Iterator> >
      : __is_move_iterator<_Iterator>
    { };

  template<typename _Iterator>
    constexpr
    auto
    __miter_base(reverse_iterator<_Iterator> __it)
    -> decltype(__make_reverse_iterator(__miter_base(__it.base())))
    { return __make_reverse_iterator(__miter_base(__it.base())); }
# 688 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_iterator.h" 3
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;

      using difference_type = ptrdiff_t;



      explicit constexpr
      back_insert_iterator(_Container& __x)
      : container(std::__addressof(__x)) { }
# 726 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_iterator.h" 3
      constexpr
      back_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_back(__value);
 return *this;
      }

      constexpr
      back_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_back(std::move(__value));
 return *this;
      }



      [[__nodiscard__]] constexpr
      back_insert_iterator&
      operator*()
      { return *this; }


      constexpr
      back_insert_iterator&
      operator++()
      { return *this; }


      constexpr
      back_insert_iterator
      operator++(int)
      { return *this; }
    };
# 773 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_iterator.h" 3
  template<typename _Container>
    [[__nodiscard__]] constexpr
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
# 789 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_iterator.h" 3
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;

      using difference_type = ptrdiff_t;



      explicit constexpr
      front_insert_iterator(_Container& __x)
      : container(std::__addressof(__x)) { }
# 827 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_iterator.h" 3
      constexpr
      front_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_front(__value);
 return *this;
      }

      constexpr
      front_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_front(std::move(__value));
 return *this;
      }



      [[__nodiscard__]] constexpr
      front_insert_iterator&
      operator*()
      { return *this; }


      constexpr
      front_insert_iterator&
      operator++()
      { return *this; }


      constexpr
      front_insert_iterator
      operator++(int)
      { return *this; }
    };
# 874 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_iterator.h" 3
  template<typename _Container>
    [[__nodiscard__]] constexpr
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
# 894 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_iterator.h" 3
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {

      using _Iter = std::__detail::__range_iter_t<_Container>;



    protected:
      _Container* container;
      _Iter iter;

    public:

      typedef _Container container_type;


      using difference_type = ptrdiff_t;






      constexpr
      insert_iterator(_Container& __x, _Iter __i)
      : container(std::__addressof(__x)), iter(__i) {}
# 955 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_iterator.h" 3
      constexpr
      insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }

      constexpr
      insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 iter = container->insert(iter, std::move(__value));
 ++iter;
 return *this;
      }



      [[__nodiscard__]] constexpr
      insert_iterator&
      operator*()
      { return *this; }


      constexpr
      insert_iterator&
      operator++()
      { return *this; }


      constexpr
      insert_iterator&
      operator++(int)
      { return *this; }
    };

#pragma GCC diagnostic pop
# 1008 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_iterator.h" 3
  template<typename _Container>
    [[nodiscard]]
    constexpr insert_iterator<_Container>
    inserter(_Container& __x, std::__detail::__range_iter_t<_Container> __i)
    { return insert_iterator<_Container>(__x, __i); }
# 1023 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_iterator.h" 3

}

namespace __gnu_cxx
{

# 1037 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_iterator.h" 3
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;

      typedef std::iterator_traits<_Iterator> __traits_type;


      template<typename _Iter>
 using __convertible_from
   = std::__enable_if_t<std::is_convertible<_Iter, _Iterator>::value>;


    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::reference reference;
      typedef typename __traits_type::pointer pointer;


      using iterator_concept = std::__detail::__iter_concept<_Iterator>;


      constexpr __normal_iterator() noexcept
      : _M_current(_Iterator()) { }

      explicit constexpr
      __normal_iterator(const _Iterator& __i) noexcept
      : _M_current(__i) { }



      template<typename _Iter, typename = __convertible_from<_Iter>>
 constexpr
 __normal_iterator(const __normal_iterator<_Iter, _Container>& __i)
 noexcept
# 1085 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_iterator.h" 3
        : _M_current(__i.base()) { }


      constexpr
      reference
      operator*() const noexcept
      { return *_M_current; }

      constexpr
      pointer
      operator->() const noexcept
      { return _M_current; }

      constexpr
      __normal_iterator&
      operator++() noexcept
      {
 ++_M_current;
 return *this;
      }

      constexpr
      __normal_iterator
      operator++(int) noexcept
      { return __normal_iterator(_M_current++); }


      constexpr
      __normal_iterator&
      operator--() noexcept
      {
 --_M_current;
 return *this;
      }

      constexpr
      __normal_iterator
      operator--(int) noexcept
      { return __normal_iterator(_M_current--); }


      constexpr
      reference
      operator[](difference_type __n) const noexcept
      { return _M_current[__n]; }

      constexpr
      __normal_iterator&
      operator+=(difference_type __n) noexcept
      { _M_current += __n; return *this; }

      constexpr
      __normal_iterator
      operator+(difference_type __n) const noexcept
      { return __normal_iterator(_M_current + __n); }

      constexpr
      __normal_iterator&
      operator-=(difference_type __n) noexcept
      { _M_current -= __n; return *this; }

      constexpr
      __normal_iterator
      operator-(difference_type __n) const noexcept
      { return __normal_iterator(_M_current - __n); }

      constexpr
      const _Iterator&
      base() const noexcept
      { return _M_current; }
    };
# 1166 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    [[nodiscard]]
    constexpr bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept(noexcept(__lhs.base() == __rhs.base()))
    requires requires {
      { __lhs.base() == __rhs.base() } -> std::convertible_to<bool>;
    }
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    [[nodiscard]]
    constexpr std::__detail::__synth3way_t<_IteratorR, _IteratorL>
    operator<=>(const __normal_iterator<_IteratorL, _Container>& __lhs,
  const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept(noexcept(std::__detail::__synth3way(__lhs.base(), __rhs.base())))
    { return std::__detail::__synth3way(__lhs.base(), __rhs.base()); }

  template<typename _Iterator, typename _Container>
    [[nodiscard]]
    constexpr bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept(noexcept(__lhs.base() == __rhs.base()))
    requires requires {
      { __lhs.base() == __rhs.base() } -> std::convertible_to<bool>;
    }
    { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
    [[nodiscard]]
    constexpr std::__detail::__synth3way_t<_Iterator>
    operator<=>(const __normal_iterator<_Iterator, _Container>& __lhs,
  const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept(noexcept(std::__detail::__synth3way(__lhs.base(), __rhs.base())))
    { return std::__detail::__synth3way(__lhs.base(), __rhs.base()); }
# 1307 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>


    [[__nodiscard__]] constexpr
    inline auto
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs) noexcept
    -> decltype(__lhs.base() - __rhs.base())





    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    [[__nodiscard__]] constexpr
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    [[__nodiscard__]] constexpr
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    noexcept
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }


}

namespace std
{


  template<typename _Iterator, typename _Container>
    constexpr
    _Iterator
    __niter_base(__gnu_cxx::__normal_iterator<_Iterator, _Container> __it)
    noexcept(std::is_nothrow_copy_constructible<_Iterator>::value)
    { return __it.base(); }
# 1371 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_iterator.h" 3
  template<semiregular _Sent>
    class move_sentinel
    {
    public:
      constexpr
      move_sentinel()
      noexcept(is_nothrow_default_constructible_v<_Sent>)
      : _M_last() { }

      constexpr explicit
      move_sentinel(_Sent __s)
      noexcept(is_nothrow_move_constructible_v<_Sent>)
      : _M_last(std::move(__s)) { }

      template<typename _S2> requires convertible_to<const _S2&, _Sent>
 constexpr
 move_sentinel(const move_sentinel<_S2>& __s)
 noexcept(is_nothrow_constructible_v<_Sent, const _S2&>)
 : _M_last(__s.base())
 { }

      template<typename _S2> requires assignable_from<_Sent&, const _S2&>
 constexpr move_sentinel&
 operator=(const move_sentinel<_S2>& __s)
 noexcept(is_nothrow_assignable_v<_Sent, const _S2&>)
 {
   _M_last = __s.base();
   return *this;
 }

      [[nodiscard]]
      constexpr _Sent
      base() const
      noexcept(is_nothrow_copy_constructible_v<_Sent>)
      { return _M_last; }

    private:
      _Sent _M_last;
    };


  namespace __detail
  {

    template<typename _Iterator>
      struct __move_iter_cat
      { };

    template<typename _Iterator>
      requires requires { typename __iter_category_t<_Iterator>; }
      struct __move_iter_cat<_Iterator>
      {
 using iterator_category
   = __clamp_iter_cat<__iter_category_t<_Iterator>,
        random_access_iterator_tag>;
      };

  }
# 1439 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class move_iterator

      : public __detail::__move_iter_cat<_Iterator>

    {
      _Iterator _M_current;

      using __traits_type = iterator_traits<_Iterator>;




      template<typename _Iter2>
 friend class move_iterator;




      template<typename _Iter2>
 static constexpr bool __convertible = !is_same_v<_Iter2, _Iterator>
     && convertible_to<const _Iter2&, _Iterator>;



      static auto
      _S_iter_concept()
      {
 if constexpr (random_access_iterator<_Iterator>)
   return random_access_iterator_tag{};
 else if constexpr (bidirectional_iterator<_Iterator>)
   return bidirectional_iterator_tag{};
 else if constexpr (forward_iterator<_Iterator>)
   return forward_iterator_tag{};
 else
   return input_iterator_tag{};
      }


    public:
      using iterator_type = _Iterator;


      using iterator_concept = decltype(_S_iter_concept());


      using value_type = iter_value_t<_Iterator>;
      using difference_type = iter_difference_t<_Iterator>;
      using pointer = _Iterator;
      using reference = iter_rvalue_reference_t<_Iterator>;
# 1503 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_iterator.h" 3
      constexpr
      move_iterator()
      : _M_current() { }

      explicit constexpr
      move_iterator(iterator_type __i)
      : _M_current(std::move(__i)) { }

      template<typename _Iter>

 requires __convertible<_Iter>

 constexpr
 move_iterator(const move_iterator<_Iter>& __i)
 : _M_current(__i._M_current) { }

      template<typename _Iter>

 requires __convertible<_Iter>
   && assignable_from<_Iterator&, const _Iter&>

 constexpr
 move_iterator& operator=(const move_iterator<_Iter>& __i)
 {
   _M_current = __i._M_current;
   return *this;
 }







      [[nodiscard]]
      constexpr const iterator_type&
      base() const & noexcept
      { return _M_current; }

      [[nodiscard]]
      constexpr iterator_type
      base() &&
      { return std::move(_M_current); }


      [[__nodiscard__]]
      constexpr reference
      operator*() const

      { return ranges::iter_move(_M_current); }




      [[__nodiscard__]]
      constexpr pointer
      operator->() const
      { return _M_current; }

      constexpr move_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      constexpr move_iterator
      operator++(int)
      {
 move_iterator __tmp = *this;
 ++_M_current;
 return __tmp;
      }


      constexpr void
      operator++(int) requires (!forward_iterator<_Iterator>)
      { ++_M_current; }


      constexpr move_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      constexpr move_iterator
      operator--(int)
      {
 move_iterator __tmp = *this;
 --_M_current;
 return __tmp;
      }

      [[__nodiscard__]]
      constexpr move_iterator
      operator+(difference_type __n) const
      { return move_iterator(_M_current + __n); }

      constexpr move_iterator&
      operator+=(difference_type __n)
      {
 _M_current += __n;
 return *this;
      }

      [[__nodiscard__]]
      constexpr move_iterator
      operator-(difference_type __n) const
      { return move_iterator(_M_current - __n); }

      constexpr move_iterator&
      operator-=(difference_type __n)
      {
 _M_current -= __n;
 return *this;
      }

      [[__nodiscard__]]
      constexpr reference
      operator[](difference_type __n) const

      { return ranges::iter_move(_M_current + __n); }





      template<sentinel_for<_Iterator> _Sent>
 [[nodiscard]]
 friend constexpr bool
 operator==(const move_iterator& __x, const move_sentinel<_Sent>& __y)
 { return __x.base() == __y.base(); }

      template<sized_sentinel_for<_Iterator> _Sent>
 [[nodiscard]]
 friend constexpr iter_difference_t<_Iterator>
 operator-(const move_sentinel<_Sent>& __x, const move_iterator& __y)
 { return __x.base() - __y.base(); }

      template<sized_sentinel_for<_Iterator> _Sent>
 [[nodiscard]]
 friend constexpr iter_difference_t<_Iterator>
 operator-(const move_iterator& __x, const move_sentinel<_Sent>& __y)
 { return __x.base() - __y.base(); }

      [[nodiscard]]
      friend constexpr iter_rvalue_reference_t<_Iterator>
      iter_move(const move_iterator& __i)
      noexcept(noexcept(ranges::iter_move(__i._M_current)))
      { return ranges::iter_move(__i._M_current); }

      template<indirectly_swappable<_Iterator> _Iter2>
 friend constexpr void
 iter_swap(const move_iterator& __x, const move_iterator<_Iter2>& __y)
 noexcept(noexcept(ranges::iter_swap(__x._M_current, __y._M_current)))
 { return ranges::iter_swap(__x._M_current, __y._M_current); }

    };

  template<typename _IteratorL, typename _IteratorR>
    [[__nodiscard__]]
    inline constexpr bool
    operator==(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)

    requires requires { { __x.base() == __y.base() } -> convertible_to<bool>; }

    { return __x.base() == __y.base(); }


  template<typename _IteratorL,
    three_way_comparable_with<_IteratorL> _IteratorR>
    [[__nodiscard__]]
    constexpr compare_three_way_result_t<_IteratorL, _IteratorR>
    operator<=>(const move_iterator<_IteratorL>& __x,
  const move_iterator<_IteratorR>& __y)
    { return __x.base() <=> __y.base(); }
# 1691 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR>
    [[__nodiscard__]]
    inline constexpr bool
    operator<(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)

    requires requires { { __x.base() < __y.base() } -> convertible_to<bool>; }

    { return __x.base() < __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    [[__nodiscard__]]
    inline constexpr bool
    operator<=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)

    requires requires { { __y.base() < __x.base() } -> convertible_to<bool>; }

    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    [[__nodiscard__]]
    inline constexpr bool
    operator>(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)

    requires requires { { __y.base() < __x.base() } -> convertible_to<bool>; }

    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    [[__nodiscard__]]
    inline constexpr bool
    operator>=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)

    requires requires { { __x.base() < __y.base() } -> convertible_to<bool>; }

    { return !(__x < __y); }




  template<typename _Iterator>
    [[__nodiscard__]]
    inline constexpr bool
    operator==(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }


  template<three_way_comparable _Iterator>
    [[__nodiscard__]]
    constexpr compare_three_way_result_t<_Iterator>
    operator<=>(const move_iterator<_Iterator>& __x,
  const move_iterator<_Iterator>& __y)
    { return __x.base() <=> __y.base(); }
# 1786 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR>
    [[__nodiscard__]]
    inline constexpr auto
    operator-(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    -> decltype(__x.base() - __y.base())
    { return __x.base() - __y.base(); }

  template<typename _Iterator>
    [[__nodiscard__]]
    inline constexpr move_iterator<_Iterator>
    operator+(typename move_iterator<_Iterator>::difference_type __n,
       const move_iterator<_Iterator>& __x)
    { return __x + __n; }

  template<typename _Iterator>
    [[__nodiscard__]]
    inline constexpr move_iterator<_Iterator>
    make_move_iterator(_Iterator __i)
    { return move_iterator<_Iterator>(std::move(__i)); }

  template<typename _Iterator, typename _ReturnType
    = __conditional_t<__move_if_noexcept_cond
      <typename iterator_traits<_Iterator>::value_type>::value,
  _Iterator, move_iterator<_Iterator>>>
    inline constexpr _ReturnType
    __make_move_if_noexcept_iterator(_Iterator __i)
    { return _ReturnType(__i); }



  template<typename _Tp, typename _ReturnType
    = __conditional_t<__move_if_noexcept_cond<_Tp>::value,
        const _Tp*, move_iterator<_Tp*>>>
    inline constexpr _ReturnType
    __make_move_if_noexcept_iterator(_Tp* __i)
    { return _ReturnType(__i); }




  namespace __detail
  {
    template<typename _It>
      concept __common_iter_has_arrow = indirectly_readable<const _It>
 && (requires(const _It& __it) { __it.operator->(); }
     || is_reference_v<iter_reference_t<_It>>
     || constructible_from<iter_value_t<_It>, iter_reference_t<_It>>);

    template<typename _It>
      concept __common_iter_use_postfix_proxy
 = (!requires (_It& __i) { { *__i++ } -> __can_reference; })
   && constructible_from<iter_value_t<_It>, iter_reference_t<_It>>
   && move_constructible<iter_value_t<_It>>;
  }


  template<input_or_output_iterator _It, sentinel_for<_It> _Sent>
    requires (!same_as<_It, _Sent>) && copyable<_It>
  class common_iterator
  {
    template<typename _Tp, typename _Up>
      static constexpr bool
      _S_noexcept1()
      {
 if constexpr (is_trivially_default_constructible_v<_Tp>)
   return is_nothrow_assignable_v<_Tp&, _Up>;
 else
   return is_nothrow_constructible_v<_Tp, _Up>;
      }

    template<typename _It2, typename _Sent2>
      static constexpr bool
      _S_noexcept()
      { return _S_noexcept1<_It, _It2>() && _S_noexcept1<_Sent, _Sent2>(); }

    class __arrow_proxy
    {
      iter_value_t<_It> _M_keep;

      constexpr
      __arrow_proxy(iter_reference_t<_It>&& __x)
      : _M_keep(std::move(__x)) { }

      friend class common_iterator;

    public:
      constexpr const iter_value_t<_It>*
      operator->() const noexcept
      { return std::__addressof(_M_keep); }
    };

    class __postfix_proxy
    {
      iter_value_t<_It> _M_keep;

      constexpr
      __postfix_proxy(iter_reference_t<_It>&& __x)
      : _M_keep(std::forward<iter_reference_t<_It>>(__x)) { }

      friend class common_iterator;

    public:
      constexpr const iter_value_t<_It>&
      operator*() const noexcept
      { return _M_keep; }
    };

  public:
    constexpr
    common_iterator()
    noexcept(is_nothrow_default_constructible_v<_It>)
    requires default_initializable<_It>
    : _M_it(), _M_index(0)
    { }

    constexpr
    common_iterator(_It __i)
    noexcept(is_nothrow_move_constructible_v<_It>)
    : _M_it(std::move(__i)), _M_index(0)
    { }

    constexpr
    common_iterator(_Sent __s)
    noexcept(is_nothrow_move_constructible_v<_Sent>)
    : _M_sent(std::move(__s)), _M_index(1)
    { }

    template<typename _It2, typename _Sent2>
      requires convertible_to<const _It2&, _It>
 && convertible_to<const _Sent2&, _Sent>
      constexpr
      common_iterator(const common_iterator<_It2, _Sent2>& __x)
      noexcept(_S_noexcept<const _It2&, const _Sent2&>())
      : _M_valueless(), _M_index(__x._M_index)
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__x._M_has_value()), false)) std::__glibcxx_assert_fail(); } while (false);
 if (_M_index == 0)
   {
     if constexpr (is_trivially_default_constructible_v<_It>)
       _M_it = std::move(__x._M_it);
     else
       std::construct_at(std::__addressof(_M_it), __x._M_it);
   }
 else if (_M_index == 1)
   {
     if constexpr (is_trivially_default_constructible_v<_Sent>)
       _M_sent = std::move(__x._M_sent);
     else
       std::construct_at(std::__addressof(_M_sent), __x._M_sent);
   }
      }

    common_iterator(const common_iterator&) = default;

    constexpr
    common_iterator(const common_iterator& __x)
    noexcept(_S_noexcept<const _It&, const _Sent&>())
    requires (!is_trivially_copyable_v<_It> || !is_trivially_copyable_v<_Sent>)
    : _M_valueless(), _M_index(__x._M_index)
    {
      if (_M_index == 0)
 {
   if constexpr (is_trivially_default_constructible_v<_It>)
     _M_it = __x._M_it;
   else
     std::construct_at(std::__addressof(_M_it), __x._M_it);
 }
      else if (_M_index == 1)
 {
   if constexpr (is_trivially_default_constructible_v<_Sent>)
     _M_sent = __x._M_sent;
   else
     std::construct_at(std::__addressof(_M_sent), __x._M_sent);
 }
    }

    common_iterator(common_iterator&&) = default;

    constexpr
    common_iterator(common_iterator&& __x)
    noexcept(_S_noexcept<_It, _Sent>())
    requires (!is_trivially_copyable_v<_It> || !is_trivially_copyable_v<_Sent>)
    : _M_valueless(), _M_index(__x._M_index)
    {
      if (_M_index == 0)
 {
   if constexpr (is_trivially_default_constructible_v<_It>)
     _M_it = std::move(__x._M_it);
   else
     std::construct_at(std::__addressof(_M_it), std::move(__x._M_it));
 }
      else if (_M_index == 1)
 {
   if constexpr (is_trivially_default_constructible_v<_Sent>)
     _M_sent = std::move(__x._M_sent);
   else
     std::construct_at(std::__addressof(_M_sent),
         std::move(__x._M_sent));
 }
    }

    constexpr common_iterator&
    operator=(const common_iterator&) = default;

    constexpr common_iterator&
    operator=(const common_iterator& __x)
    noexcept(is_nothrow_copy_assignable_v<_It>
      && is_nothrow_copy_assignable_v<_Sent>
      && is_nothrow_copy_constructible_v<_It>
      && is_nothrow_copy_constructible_v<_Sent>)
    requires (!is_trivially_copy_assignable_v<_It>
  || !is_trivially_copy_assignable_v<_Sent>)
    {
      _M_assign(__x);
      return *this;
    }

    constexpr common_iterator&
    operator=(common_iterator&&) = default;

    constexpr common_iterator&
    operator=(common_iterator&& __x)
    noexcept(is_nothrow_move_assignable_v<_It>
      && is_nothrow_move_assignable_v<_Sent>
      && is_nothrow_move_constructible_v<_It>
      && is_nothrow_move_constructible_v<_Sent>)
    requires (!is_trivially_move_assignable_v<_It>
  || !is_trivially_move_assignable_v<_Sent>)
    {
      _M_assign(std::move(__x));
      return *this;
    }

    template<typename _It2, typename _Sent2>
      requires convertible_to<const _It2&, _It>
 && convertible_to<const _Sent2&, _Sent>
 && assignable_from<_It&, const _It2&>
 && assignable_from<_Sent&, const _Sent2&>
      constexpr common_iterator&
      operator=(const common_iterator<_It2, _Sent2>& __x)
      noexcept(is_nothrow_constructible_v<_It, const _It2&>
        && is_nothrow_constructible_v<_Sent, const _Sent2&>
        && is_nothrow_assignable_v<_It&, const _It2&>
        && is_nothrow_assignable_v<_Sent&, const _Sent2&>)
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__x._M_has_value()), false)) std::__glibcxx_assert_fail(); } while (false);
 _M_assign(__x);
 return *this;
      }


    ~common_iterator() = default;

    constexpr
    ~common_iterator()
      requires (!is_trivially_destructible_v<_It>
    || !is_trivially_destructible_v<_Sent>)




    {
      if (_M_index == 0)
 _M_it.~_It();
      else if (_M_index == 1)
 _M_sent.~_Sent();
    }

    [[nodiscard]]
    constexpr decltype(auto)
    operator*()
    {
      do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(_M_index == 0), false)) std::__glibcxx_assert_fail(); } while (false);
      return *_M_it;
    }

    [[nodiscard]]
    constexpr decltype(auto)
    operator*() const requires __detail::__dereferenceable<const _It>
    {
      do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(_M_index == 0), false)) std::__glibcxx_assert_fail(); } while (false);
      return *_M_it;
    }

    [[nodiscard]]
    constexpr auto
    operator->() const requires __detail::__common_iter_has_arrow<_It>
    {
      do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(_M_index == 0), false)) std::__glibcxx_assert_fail(); } while (false);
      if constexpr (is_pointer_v<_It> || requires { _M_it.operator->(); })
 return _M_it;
      else if constexpr (is_reference_v<iter_reference_t<_It>>)
 {
   auto&& __tmp = *_M_it;
   return std::__addressof(__tmp);
 }
      else
 return __arrow_proxy{*_M_it};
    }

    constexpr common_iterator&
    operator++()
    {
      do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(_M_index == 0), false)) std::__glibcxx_assert_fail(); } while (false);
      ++_M_it;
      return *this;
    }

    constexpr decltype(auto)
    operator++(int)
    {
      do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(_M_index == 0), false)) std::__glibcxx_assert_fail(); } while (false);
      if constexpr (forward_iterator<_It>)
 {
   common_iterator __tmp = *this;
   ++*this;
   return __tmp;
 }
      else if constexpr (!__detail::__common_iter_use_postfix_proxy<_It>)
 return _M_it++;
      else
 {
   __postfix_proxy __p(**this);
   ++*this;
   return __p;
 }
    }

    template<typename _It2, sentinel_for<_It> _Sent2>
      requires sentinel_for<_Sent, _It2>
      friend constexpr bool
      operator== [[nodiscard]] (const common_iterator& __x,
    const common_iterator<_It2, _Sent2>& __y)
      {
 switch(__x._M_index << 2 | __y._M_index)
   {
   case 0b0000:
   case 0b0101:
     return true;
   case 0b0001:
     return __x._M_it == __y._M_sent;
   case 0b0100:
     return __x._M_sent == __y._M_it;
   default:
     do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__x._M_has_value()), false)) std::__glibcxx_assert_fail(); } while (false);
     do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__y._M_has_value()), false)) std::__glibcxx_assert_fail(); } while (false);
     __builtin_unreachable();
   }
      }

    template<typename _It2, sentinel_for<_It> _Sent2>
      requires sentinel_for<_Sent, _It2> && equality_comparable_with<_It, _It2>
      friend constexpr bool
      operator== [[nodiscard]] (const common_iterator& __x,
    const common_iterator<_It2, _Sent2>& __y)
      {
 switch(__x._M_index << 2 | __y._M_index)
   {
   case 0b0101:
     return true;
   case 0b0000:
     return __x._M_it == __y._M_it;
   case 0b0001:
     return __x._M_it == __y._M_sent;
   case 0b0100:
     return __x._M_sent == __y._M_it;
   default:
     do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__x._M_has_value()), false)) std::__glibcxx_assert_fail(); } while (false);
     do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__y._M_has_value()), false)) std::__glibcxx_assert_fail(); } while (false);
     __builtin_unreachable();
   }
      }

    template<sized_sentinel_for<_It> _It2, sized_sentinel_for<_It> _Sent2>
      requires sized_sentinel_for<_Sent, _It2>
      friend constexpr iter_difference_t<_It2>
      operator- [[nodiscard]] (const common_iterator& __x,
          const common_iterator<_It2, _Sent2>& __y)
      {
 switch(__x._M_index << 2 | __y._M_index)
   {
   case 0b0101:
     return 0;
   case 0b0000:
     return __x._M_it - __y._M_it;
   case 0b0001:
     return __x._M_it - __y._M_sent;
   case 0b0100:
     return __x._M_sent - __y._M_it;
   default:
     do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__x._M_has_value()), false)) std::__glibcxx_assert_fail(); } while (false);
     do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__y._M_has_value()), false)) std::__glibcxx_assert_fail(); } while (false);
     __builtin_unreachable();
   }
      }

    [[nodiscard]]
    friend constexpr iter_rvalue_reference_t<_It>
    iter_move(const common_iterator& __i)
    noexcept(noexcept(ranges::iter_move(std::declval<const _It&>())))
    requires input_iterator<_It>
    {
      do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__i._M_index == 0), false)) std::__glibcxx_assert_fail(); } while (false);
      return ranges::iter_move(__i._M_it);
    }

    template<indirectly_swappable<_It> _It2, typename _Sent2>
      friend constexpr void
      iter_swap(const common_iterator& __x,
  const common_iterator<_It2, _Sent2>& __y)
      noexcept(noexcept(ranges::iter_swap(std::declval<const _It&>(),
       std::declval<const _It2&>())))
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__x._M_index == 0), false)) std::__glibcxx_assert_fail(); } while (false);
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__y._M_index == 0), false)) std::__glibcxx_assert_fail(); } while (false);
 return ranges::iter_swap(__x._M_it, __y._M_it);
      }

  private:
    template<input_or_output_iterator _It2, sentinel_for<_It2> _Sent2>
      requires (!same_as<_It2, _Sent2>) && copyable<_It2>
      friend class common_iterator;

    constexpr bool
    _M_has_value() const noexcept { return _M_index != _S_valueless; }

    template<typename _CIt>
      constexpr void
      _M_assign(_CIt&& __x)
      {
 if (_M_index == __x._M_index)
   {
     if (_M_index == 0)
       _M_it = std::forward<_CIt>(__x)._M_it;
     else if (_M_index == 1)
       _M_sent = std::forward<_CIt>(__x)._M_sent;
   }
 else
   {
     if (_M_index == 0)
       _M_it.~_It();
     else if (_M_index == 1)
       _M_sent.~_Sent();
     _M_index = _S_valueless;

     if (__x._M_index == 0)
       std::construct_at(std::__addressof(_M_it),
    std::forward<_CIt>(__x)._M_it);
     else if (__x._M_index == 1)
       std::construct_at(std::__addressof(_M_sent),
    std::forward<_CIt>(__x)._M_sent);
     _M_index = __x._M_index;
   }
      }

    union
    {
      _It _M_it;
      _Sent _M_sent;
      unsigned char _M_valueless;
    };
    unsigned char _M_index;

    static constexpr unsigned char _S_valueless{2};
  };

  template<typename _It, typename _Sent>
    struct incrementable_traits<common_iterator<_It, _Sent>>
    {
      using difference_type = iter_difference_t<_It>;
    };

  template<input_iterator _It, typename _Sent>
    struct iterator_traits<common_iterator<_It, _Sent>>
    {
    private:
      template<typename _Iter>
 struct __ptr
 {
   using type = void;
 };

      template<typename _Iter>
 requires __detail::__common_iter_has_arrow<_Iter>
 struct __ptr<_Iter>
 {
   using _CIter = common_iterator<_Iter, _Sent>;
   using type = decltype(std::declval<const _CIter&>().operator->());
 };

      static auto
      _S_iter_cat()
      {
 if constexpr (requires { requires derived_from<__iter_category_t<_It>,
             forward_iterator_tag>; })
   return forward_iterator_tag{};
 else
   return input_iterator_tag{};
      }

    public:
      using iterator_concept = __conditional_t<forward_iterator<_It>,
            forward_iterator_tag,
            input_iterator_tag>;
      using iterator_category = decltype(_S_iter_cat());
      using value_type = iter_value_t<_It>;
      using difference_type = iter_difference_t<_It>;
      using pointer = typename __ptr<_It>::type;
      using reference = iter_reference_t<_It>;
    };



  namespace __detail
  {
    template<typename _It>
      struct __counted_iter_value_type
      { };

    template<indirectly_readable _It>
      struct __counted_iter_value_type<_It>
      { using value_type = iter_value_t<_It>; };

    template<typename _It>
      struct __counted_iter_concept
      { };

    template<typename _It>
      requires requires { typename _It::iterator_concept; }
      struct __counted_iter_concept<_It>
      { using iterator_concept = typename _It::iterator_concept; };

    template<typename _It>
      struct __counted_iter_cat
      { };

    template<typename _It>
      requires requires { typename _It::iterator_category; }
      struct __counted_iter_cat<_It>
      { using iterator_category = typename _It::iterator_category; };
  }


  template<input_or_output_iterator _It>
    class counted_iterator
      : public __detail::__counted_iter_value_type<_It>,
 public __detail::__counted_iter_concept<_It>,
 public __detail::__counted_iter_cat<_It>
    {
    public:
      using iterator_type = _It;

      using difference_type = iter_difference_t<_It>;



      constexpr counted_iterator() requires default_initializable<_It> = default;

      constexpr
      counted_iterator(_It __i, iter_difference_t<_It> __n)
      : _M_current(std::move(__i)), _M_length(__n)
      { do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__n >= 0), false)) std::__glibcxx_assert_fail(); } while (false); }

      template<typename _It2>
 requires convertible_to<const _It2&, _It>
 constexpr
 counted_iterator(const counted_iterator<_It2>& __x)
 : _M_current(__x._M_current), _M_length(__x._M_length)
 { }

      template<typename _It2>
 requires assignable_from<_It&, const _It2&>
 constexpr counted_iterator&
 operator=(const counted_iterator<_It2>& __x)
 {
   _M_current = __x._M_current;
   _M_length = __x._M_length;
   return *this;
 }

      [[nodiscard]]
      constexpr const _It&
      base() const & noexcept
      { return _M_current; }

      [[nodiscard]]
      constexpr _It
      base() &&
      noexcept(is_nothrow_move_constructible_v<_It>)
      { return std::move(_M_current); }

      [[nodiscard]]
      constexpr iter_difference_t<_It>
      count() const noexcept { return _M_length; }

      [[nodiscard]]
      constexpr decltype(auto)
      operator*()
      noexcept(noexcept(*_M_current))
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(_M_length > 0), false)) std::__glibcxx_assert_fail(); } while (false);
 return *_M_current;
      }

      [[nodiscard]]
      constexpr decltype(auto)
      operator*() const
      noexcept(noexcept(*_M_current))
      requires __detail::__dereferenceable<const _It>
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(_M_length > 0), false)) std::__glibcxx_assert_fail(); } while (false);
 return *_M_current;
      }

      [[nodiscard]]
      constexpr auto
      operator->() const noexcept
      requires contiguous_iterator<_It>
      { return std::to_address(_M_current); }

      constexpr counted_iterator&
      operator++()
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(_M_length > 0), false)) std::__glibcxx_assert_fail(); } while (false);
 ++_M_current;
 --_M_length;
 return *this;
      }

      constexpr decltype(auto)
      operator++(int)
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(_M_length > 0), false)) std::__glibcxx_assert_fail(); } while (false);
 --_M_length;
 try
   {
     return _M_current++;
   } catch(...) {
     ++_M_length;
     throw;
   }
      }

      constexpr counted_iterator
      operator++(int) requires forward_iterator<_It>
      {
 auto __tmp = *this;
 ++*this;
 return __tmp;
      }

      constexpr counted_iterator&
      operator--() requires bidirectional_iterator<_It>
      {
 --_M_current;
 ++_M_length;
 return *this;
      }

      constexpr counted_iterator
      operator--(int) requires bidirectional_iterator<_It>
      {
 auto __tmp = *this;
 --*this;
 return __tmp;
      }

      [[nodiscard]]
      constexpr counted_iterator
      operator+(iter_difference_t<_It> __n) const
 requires random_access_iterator<_It>
      { return counted_iterator(_M_current + __n, _M_length - __n); }

      [[nodiscard]]
      friend constexpr counted_iterator
      operator+(iter_difference_t<_It> __n, const counted_iterator& __x)
      requires random_access_iterator<_It>
      { return __x + __n; }

      constexpr counted_iterator&
      operator+=(iter_difference_t<_It> __n)
      requires random_access_iterator<_It>
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__n <= _M_length), false)) std::__glibcxx_assert_fail(); } while (false);
 _M_current += __n;
 _M_length -= __n;
 return *this;
      }

      [[nodiscard]]
      constexpr counted_iterator
      operator-(iter_difference_t<_It> __n) const
      requires random_access_iterator<_It>
      { return counted_iterator(_M_current - __n, _M_length + __n); }

      template<common_with<_It> _It2>
 [[nodiscard]]
 friend constexpr iter_difference_t<_It2>
 operator-(const counted_iterator& __x,
    const counted_iterator<_It2>& __y)
 { return __y._M_length - __x._M_length; }

      [[nodiscard]]
      friend constexpr iter_difference_t<_It>
      operator-(const counted_iterator& __x, default_sentinel_t)
      { return -__x._M_length; }

      [[nodiscard]]
      friend constexpr iter_difference_t<_It>
      operator-(default_sentinel_t, const counted_iterator& __y)
      { return __y._M_length; }

      constexpr counted_iterator&
      operator-=(iter_difference_t<_It> __n)
      requires random_access_iterator<_It>
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(-__n <= _M_length), false)) std::__glibcxx_assert_fail(); } while (false);
 _M_current -= __n;
 _M_length += __n;
 return *this;
      }

      [[nodiscard]]
      constexpr decltype(auto)
      operator[](iter_difference_t<_It> __n) const
      noexcept(noexcept(_M_current[__n]))
      requires random_access_iterator<_It>
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__n < _M_length), false)) std::__glibcxx_assert_fail(); } while (false);
 return _M_current[__n];
      }

      template<common_with<_It> _It2>
 [[nodiscard]]
 friend constexpr bool
 operator==(const counted_iterator& __x,
     const counted_iterator<_It2>& __y)
 { return __x._M_length == __y._M_length; }

      [[nodiscard]]
      friend constexpr bool
      operator==(const counted_iterator& __x, default_sentinel_t)
      { return __x._M_length == 0; }

      template<common_with<_It> _It2>
 [[nodiscard]]
 friend constexpr strong_ordering
 operator<=>(const counted_iterator& __x,
      const counted_iterator<_It2>& __y)
 { return __y._M_length <=> __x._M_length; }

      [[nodiscard]]
      friend constexpr iter_rvalue_reference_t<_It>
      iter_move(const counted_iterator& __i)
      noexcept(noexcept(ranges::iter_move(__i._M_current)))
      requires input_iterator<_It>
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__i._M_length > 0), false)) std::__glibcxx_assert_fail(); } while (false);
 return ranges::iter_move(__i._M_current);
      }

      template<indirectly_swappable<_It> _It2>
 friend constexpr void
 iter_swap(const counted_iterator& __x,
    const counted_iterator<_It2>& __y)
 noexcept(noexcept(ranges::iter_swap(__x._M_current, __y._M_current)))
 {
   do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__x._M_length > 0 && __y._M_length > 0), false)) std::__glibcxx_assert_fail(); } while (false);
   ranges::iter_swap(__x._M_current, __y._M_current);
 }

    private:
      template<input_or_output_iterator _It2> friend class counted_iterator;

      _It _M_current = _It();
      iter_difference_t<_It> _M_length = 0;
    };

  template<input_iterator _It>
    requires same_as<__detail::__iter_traits<_It>, iterator_traits<_It>>
    struct iterator_traits<counted_iterator<_It>> : iterator_traits<_It>
    {
      using pointer = __conditional_t<contiguous_iterator<_It>,
          add_pointer_t<iter_reference_t<_It>>,
          void>;
    };


  template<indirectly_readable _It>
    using iter_const_reference_t
      = common_reference_t<const iter_value_t<_It>&&, iter_reference_t<_It>>;

  template<input_iterator _It> class basic_const_iterator;

  namespace __detail
  {
    template<typename _It>
      concept __constant_iterator = input_iterator<_It>
 && same_as<iter_const_reference_t<_It>, iter_reference_t<_It>>;

    template<typename _Tp>
      inline constexpr bool __is_const_iterator = false;

    template<typename _It>
      inline constexpr bool __is_const_iterator<basic_const_iterator<_It>> = true;

    template<typename _Tp>
      concept __not_a_const_iterator = !__is_const_iterator<_Tp>;

    template<indirectly_readable _It>
      using __iter_const_rvalue_reference_t
 = common_reference_t<const iter_value_t<_It>&&, iter_rvalue_reference_t<_It>>;

    template<typename _It>
      struct __basic_const_iterator_iter_cat
      { };

    template<forward_iterator _It>
      struct __basic_const_iterator_iter_cat<_It>
      { using iterator_category = __iter_category_t<_It>; };
  }

  template<input_iterator _It>
    using const_iterator
      = __conditional_t<__detail::__constant_iterator<_It>, _It, basic_const_iterator<_It>>;

  namespace __detail
  {
    template<typename _Sent>
      struct __const_sentinel
      { using type = _Sent; };

    template<input_iterator _Sent>
      struct __const_sentinel<_Sent>
      { using type = const_iterator<_Sent>; };
  }

  template<semiregular _Sent>
    using const_sentinel = typename __detail::__const_sentinel<_Sent>::type;

  template<input_iterator _It>
  class basic_const_iterator
  : public __detail::__basic_const_iterator_iter_cat<_It>
  {
    _It _M_current = _It();
    using __reference = iter_const_reference_t<_It>;
    using __rvalue_reference = __detail::__iter_const_rvalue_reference_t<_It>;

    static auto
    _S_iter_concept()
    {
      if constexpr (contiguous_iterator<_It>)
 return contiguous_iterator_tag{};
      else if constexpr (random_access_iterator<_It>)
 return random_access_iterator_tag{};
      else if constexpr (bidirectional_iterator<_It>)
 return bidirectional_iterator_tag{};
      else if constexpr (forward_iterator<_It>)
 return forward_iterator_tag{};
      else
 return input_iterator_tag{};
    }

    template<input_iterator _It2> friend class basic_const_iterator;

  public:
    using iterator_concept = decltype(_S_iter_concept());
    using value_type = iter_value_t<_It>;
    using difference_type = iter_difference_t<_It>;

    basic_const_iterator() requires default_initializable<_It> = default;

    constexpr
    basic_const_iterator(_It __current)
    noexcept(is_nothrow_move_constructible_v<_It>)
    : _M_current(std::move(__current))
    { }

    template<convertible_to<_It> _It2>
      constexpr
      basic_const_iterator(basic_const_iterator<_It2> __current)
      noexcept(is_nothrow_constructible_v<_It, _It2>)
      : _M_current(std::move(__current._M_current))
      { }

    template<__detail::__different_from<basic_const_iterator> _Tp>
      requires convertible_to<_Tp, _It>
      constexpr
      basic_const_iterator(_Tp&& __current)
      noexcept(is_nothrow_constructible_v<_It, _Tp>)
      : _M_current(std::forward<_Tp>(__current))
      { }

    constexpr const _It&
    base() const & noexcept
    { return _M_current; }

    constexpr _It
    base() &&
    noexcept(is_nothrow_move_constructible_v<_It>)
    { return std::move(_M_current); }

    constexpr __reference
    operator*() const
    noexcept(noexcept(static_cast<__reference>(*_M_current)))
    { return static_cast<__reference>(*_M_current); }

    constexpr const auto*
    operator->() const
    noexcept(contiguous_iterator<_It> || noexcept(*_M_current))
    requires is_lvalue_reference_v<iter_reference_t<_It>>
      && same_as<remove_cvref_t<iter_reference_t<_It>>, value_type>
    {
      if constexpr (contiguous_iterator<_It>)
 return std::to_address(_M_current);
      else
 return std::__addressof(*_M_current);
    }

    constexpr basic_const_iterator&
    operator++()
    noexcept(noexcept(++_M_current))
    {
      ++_M_current;
      return *this;
    }

    constexpr void
    operator++(int)
    noexcept(noexcept(++_M_current))
    { ++_M_current; }

    constexpr basic_const_iterator
    operator++(int)
    noexcept(noexcept(++*this) && is_nothrow_copy_constructible_v<basic_const_iterator>)
    requires forward_iterator<_It>
    {
      auto __tmp = *this;
      ++*this;
      return __tmp;
    }

    constexpr basic_const_iterator&
    operator--()
    noexcept(noexcept(--_M_current))
    requires bidirectional_iterator<_It>
    {
      --_M_current;
      return *this;
    }

    constexpr basic_const_iterator
    operator--(int)
    noexcept(noexcept(--*this) && is_nothrow_copy_constructible_v<basic_const_iterator>)
    requires bidirectional_iterator<_It>
    {
      auto __tmp = *this;
      --*this;
      return __tmp;
    }

    constexpr basic_const_iterator&
    operator+=(difference_type __n)
    noexcept(noexcept(_M_current += __n))
    requires random_access_iterator<_It>
    {
      _M_current += __n;
      return *this;
    }

    constexpr basic_const_iterator&
    operator-=(difference_type __n)
    noexcept(noexcept(_M_current -= __n))
    requires random_access_iterator<_It>
    {
      _M_current -= __n;
      return *this;
    }

    constexpr __reference
    operator[](difference_type __n) const
    noexcept(noexcept(static_cast<__reference>(_M_current[__n])))
    requires random_access_iterator<_It>
    { return static_cast<__reference>(_M_current[__n]); }

    template<sentinel_for<_It> _Sent>
      constexpr bool
      operator==(const _Sent& __s) const
      noexcept(noexcept(_M_current == __s))
      { return _M_current == __s; }

    template<__detail::__not_a_const_iterator _CIt>
      requires __detail::__constant_iterator<_CIt> && convertible_to<_It, _CIt>
    constexpr
    operator _CIt() const&
    { return _M_current; }

    template<__detail::__not_a_const_iterator _CIt>
      requires __detail::__constant_iterator<_CIt> && convertible_to<_It, _CIt>
    constexpr
    operator _CIt() &&
    { return std::move(_M_current); }

    constexpr bool
    operator<(const basic_const_iterator& __y) const
    noexcept(noexcept(_M_current < __y._M_current))
    requires random_access_iterator<_It>
    { return _M_current < __y._M_current; }

    constexpr bool
    operator>(const basic_const_iterator& __y) const
    noexcept(noexcept(_M_current > __y._M_current))
    requires random_access_iterator<_It>
    { return _M_current > __y._M_current; }

    constexpr bool
    operator<=(const basic_const_iterator& __y) const
    noexcept(noexcept(_M_current <= __y._M_current))
    requires random_access_iterator<_It>
    { return _M_current <= __y._M_current; }

    constexpr bool
    operator>=(const basic_const_iterator& __y) const
    noexcept(noexcept(_M_current >= __y._M_current))
    requires random_access_iterator<_It>
    { return _M_current >= __y._M_current; }

    constexpr auto
    operator<=>(const basic_const_iterator& __y) const
    noexcept(noexcept(_M_current <=> __y._M_current))
    requires random_access_iterator<_It> && three_way_comparable<_It>
    { return _M_current <=> __y._M_current; }

    template<__detail::__different_from<basic_const_iterator> _It2>
      constexpr bool
      operator<(const _It2& __y) const
      noexcept(noexcept(_M_current < __y))
      requires random_access_iterator<_It> && totally_ordered_with<_It, _It2>
      { return _M_current < __y; }

    template<__detail::__different_from<basic_const_iterator> _It2>
      constexpr bool
      operator>(const _It2& __y) const
      noexcept(noexcept(_M_current > __y))
      requires random_access_iterator<_It> && totally_ordered_with<_It, _It2>
      { return _M_current > __y; }

    template<__detail::__different_from<basic_const_iterator> _It2>
      constexpr bool
      operator<=(const _It2& __y) const
      noexcept(noexcept(_M_current <= __y))
      requires random_access_iterator<_It> && totally_ordered_with<_It, _It2>
      { return _M_current <= __y; }

    template<__detail::__different_from<basic_const_iterator> _It2>
      constexpr bool
      operator>=(const _It2& __y) const
      noexcept(noexcept(_M_current >= __y))
      requires random_access_iterator<_It> && totally_ordered_with<_It, _It2>
      { return _M_current >= __y; }

    template<__detail::__different_from<basic_const_iterator> _It2>
      constexpr auto
      operator<=>(const _It2& __y) const
      noexcept(noexcept(_M_current <=> __y))
      requires random_access_iterator<_It> && totally_ordered_with<_It, _It2>
 && three_way_comparable_with<_It, _It2>
      { return _M_current <=> __y; }

    template<__detail::__not_a_const_iterator _It2>
      friend constexpr bool
      operator<(const _It2& __x, const basic_const_iterator& __y)
      noexcept(noexcept(__x < __y._M_current))
      requires random_access_iterator<_It> && totally_ordered_with<_It, _It2>
      { return __x < __y._M_current; }

    template<__detail::__not_a_const_iterator _It2>
      friend constexpr bool
      operator>(const _It2& __x, const basic_const_iterator& __y)
      noexcept(noexcept(__x > __y._M_current))
      requires random_access_iterator<_It> && totally_ordered_with<_It, _It2>
      { return __x > __y._M_current; }

    template<__detail::__not_a_const_iterator _It2>
      friend constexpr bool
      operator<=(const _It2& __x, const basic_const_iterator& __y)
      noexcept(noexcept(__x <= __y._M_current))
      requires random_access_iterator<_It> && totally_ordered_with<_It, _It2>
      { return __x <= __y._M_current; }

    template<__detail::__not_a_const_iterator _It2>
      friend constexpr bool
      operator>=(const _It2& __x, const basic_const_iterator& __y)
      noexcept(noexcept(__x >= __y._M_current))
      requires random_access_iterator<_It> && totally_ordered_with<_It, _It2>
      { return __x >= __y._M_current; }

    friend constexpr basic_const_iterator
    operator+(const basic_const_iterator& __i, difference_type __n)
    noexcept(noexcept(basic_const_iterator(__i._M_current + __n)))
    requires random_access_iterator<_It>
    { return basic_const_iterator(__i._M_current + __n); }

    friend constexpr basic_const_iterator
    operator+(difference_type __n, const basic_const_iterator& __i)
    noexcept(noexcept(basic_const_iterator(__i._M_current + __n)))
    requires random_access_iterator<_It>
    { return basic_const_iterator(__i._M_current + __n); }

    friend constexpr basic_const_iterator
    operator-(const basic_const_iterator& __i, difference_type __n)
    noexcept(noexcept(basic_const_iterator(__i._M_current - __n)))
    requires random_access_iterator<_It>
    { return basic_const_iterator(__i._M_current - __n); }

    template<sized_sentinel_for<_It> _Sent>
      constexpr difference_type
      operator-(const _Sent& __y) const
      noexcept(noexcept(_M_current - __y))
      { return _M_current - __y; }

    template<__detail::__not_a_const_iterator _Sent>
      requires sized_sentinel_for<_Sent, _It>
      friend constexpr difference_type
      operator-(const _Sent& __x, const basic_const_iterator& __y)
      noexcept(noexcept(__x - __y._M_current))
      { return __x - __y._M_current; }

    friend constexpr __rvalue_reference
    iter_move(const basic_const_iterator& __i)
    noexcept(noexcept(static_cast<__rvalue_reference>(ranges::iter_move(__i._M_current))))
    { return static_cast<__rvalue_reference>(ranges::iter_move(__i._M_current)); }
  };

  template<typename _Tp, common_with<_Tp> _Up>
    requires input_iterator<common_type_t<_Tp, _Up>>
    struct common_type<basic_const_iterator<_Tp>, _Up>
    { using type = basic_const_iterator<common_type_t<_Tp, _Up>>; };

  template<typename _Tp, common_with<_Tp> _Up>
    requires input_iterator<common_type_t<_Tp, _Up>>
    struct common_type<_Up, basic_const_iterator<_Tp>>
    { using type = basic_const_iterator<common_type_t<_Tp, _Up>>; };

  template<typename _Tp, common_with<_Tp> _Up>
    requires input_iterator<common_type_t<_Tp, _Up>>
    struct common_type<basic_const_iterator<_Tp>, basic_const_iterator<_Up>>
    { using type = basic_const_iterator<common_type_t<_Tp, _Up>>; };

  template<input_iterator _It>
    constexpr const_iterator<_It>
    make_const_iterator(_It __it)
    noexcept(is_nothrow_convertible_v<_It, const_iterator<_It>>)
    { return __it; }

  template<semiregular _Sent>
    constexpr const_sentinel<_Sent>
    make_const_sentinel(_Sent __s)
    noexcept(is_nothrow_convertible_v<_Sent, const_sentinel<_Sent>>)
    { return __s; }





  template<typename _Iterator>
    constexpr
    auto
    __niter_base(move_iterator<_Iterator> __it)
    -> decltype(make_move_iterator(__niter_base(__it.base())))
    { return make_move_iterator(__niter_base(__it.base())); }

  template<typename _Iterator>
    struct __is_move_iterator<move_iterator<_Iterator> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<typename _Iterator>
    constexpr
    auto
    __miter_base(move_iterator<_Iterator> __it)
    -> decltype(__miter_base(__it.base()))
    { return __miter_base(__it.base()); }
# 2984 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_iterator.h" 3
  template<typename _InputIterator>
    using __iter_key_t = remove_const_t<

      tuple_element_t<0, typename iterator_traits<_InputIterator>::value_type>>;




  template<typename _InputIterator>
    using __iter_val_t

      = tuple_element_t<1, typename iterator_traits<_InputIterator>::value_type>;




  template<typename _T1, typename _T2>
    struct pair;

  template<typename _InputIterator>
    using __iter_to_alloc_t
      = pair<const __iter_key_t<_InputIterator>, __iter_val_t<_InputIterator>>;



}
# 68 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_algobase.h" 2 3

# 1 "D:/Programs/MinGW/include/c++/14.2.0/debug/debug.h" 1 3
# 48 "D:/Programs/MinGW/include/c++/14.2.0/debug/debug.h" 3
namespace std
{
  namespace __debug { }
}




namespace __gnu_debug
{
  using namespace std::__debug;

  template<typename _Ite, typename _Seq, typename _Cat>
    struct _Safe_iterator;
}
# 70 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_algobase.h" 2 3

# 1 "D:/Programs/MinGW/include/c++/14.2.0/bits/predefined_ops.h" 1 3
# 35 "D:/Programs/MinGW/include/c++/14.2.0/bits/predefined_ops.h" 3
namespace __gnu_cxx
{
namespace __ops
{
  struct _Iter_less_iter
  {
    template<typename _Iterator1, typename _Iterator2>
      constexpr
      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      { return *__it1 < *__it2; }
  };

  constexpr
  inline _Iter_less_iter
  __iter_less_iter()
  { return _Iter_less_iter(); }

  struct _Iter_less_val
  {

    constexpr _Iter_less_val() = default;




    constexpr
    explicit
    _Iter_less_val(_Iter_less_iter) { }

    template<typename _Iterator, typename _Value>
      constexpr
      bool
      operator()(_Iterator __it, _Value& __val) const
      { return *__it < __val; }
  };

  constexpr
  inline _Iter_less_val
  __iter_less_val()
  { return _Iter_less_val(); }

  constexpr
  inline _Iter_less_val
  __iter_comp_val(_Iter_less_iter)
  { return _Iter_less_val(); }

  struct _Val_less_iter
  {

    constexpr _Val_less_iter() = default;




    constexpr
    explicit
    _Val_less_iter(_Iter_less_iter) { }

    template<typename _Value, typename _Iterator>
      constexpr
      bool
      operator()(_Value& __val, _Iterator __it) const
      { return __val < *__it; }
  };

  constexpr
  inline _Val_less_iter
  __val_less_iter()
  { return _Val_less_iter(); }

  constexpr
  inline _Val_less_iter
  __val_comp_iter(_Iter_less_iter)
  { return _Val_less_iter(); }

  struct _Iter_equal_to_iter
  {
    template<typename _Iterator1, typename _Iterator2>
      constexpr
      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      { return *__it1 == *__it2; }
  };

  constexpr
  inline _Iter_equal_to_iter
  __iter_equal_to_iter()
  { return _Iter_equal_to_iter(); }

  struct _Iter_equal_to_val
  {
    template<typename _Iterator, typename _Value>
      constexpr
      bool
      operator()(_Iterator __it, _Value& __val) const
      { return *__it == __val; }
  };

  constexpr
  inline _Iter_equal_to_val
  __iter_equal_to_val()
  { return _Iter_equal_to_val(); }

  constexpr
  inline _Iter_equal_to_val
  __iter_comp_val(_Iter_equal_to_iter)
  { return _Iter_equal_to_val(); }

  template<typename _Compare>
    struct _Iter_comp_iter
    {
      _Compare _M_comp;

      explicit constexpr
      _Iter_comp_iter(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

      template<typename _Iterator1, typename _Iterator2>
        constexpr
        bool
        operator()(_Iterator1 __it1, _Iterator2 __it2)
        { return bool(_M_comp(*__it1, *__it2)); }
    };

  template<typename _Compare>
    constexpr
    inline _Iter_comp_iter<_Compare>
    __iter_comp_iter(_Compare __comp)
    { return _Iter_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    struct _Iter_comp_val
    {
      _Compare _M_comp;

      constexpr
      explicit
      _Iter_comp_val(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

      constexpr
      explicit
      _Iter_comp_val(const _Iter_comp_iter<_Compare>& __comp)
 : _M_comp(__comp._M_comp)
      { }


      constexpr
      explicit
      _Iter_comp_val(_Iter_comp_iter<_Compare>&& __comp)
 : _M_comp(std::move(__comp._M_comp))
      { }


      template<typename _Iterator, typename _Value>
 constexpr
 bool
 operator()(_Iterator __it, _Value& __val)
 { return bool(_M_comp(*__it, __val)); }
    };

  template<typename _Compare>
    constexpr
    inline _Iter_comp_val<_Compare>
    __iter_comp_val(_Compare __comp)
    { return _Iter_comp_val<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    constexpr
    inline _Iter_comp_val<_Compare>
    __iter_comp_val(_Iter_comp_iter<_Compare> __comp)
    { return _Iter_comp_val<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    struct _Val_comp_iter
    {
      _Compare _M_comp;

      constexpr
      explicit
      _Val_comp_iter(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

      constexpr
      explicit
      _Val_comp_iter(const _Iter_comp_iter<_Compare>& __comp)
 : _M_comp(__comp._M_comp)
      { }


      constexpr
      explicit
      _Val_comp_iter(_Iter_comp_iter<_Compare>&& __comp)
 : _M_comp(std::move(__comp._M_comp))
      { }


      template<typename _Value, typename _Iterator>
 constexpr
 bool
 operator()(_Value& __val, _Iterator __it)
 { return bool(_M_comp(__val, *__it)); }
    };

  template<typename _Compare>
    constexpr
    inline _Val_comp_iter<_Compare>
    __val_comp_iter(_Compare __comp)
    { return _Val_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    constexpr
    inline _Val_comp_iter<_Compare>
    __val_comp_iter(_Iter_comp_iter<_Compare> __comp)
    { return _Val_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Value>
    struct _Iter_equals_val
    {
      _Value& _M_value;

      constexpr
      explicit
      _Iter_equals_val(_Value& __value)
 : _M_value(__value)
      { }

      template<typename _Iterator>
 constexpr
 bool
 operator()(_Iterator __it)
 { return *__it == _M_value; }
    };

  template<typename _Value>
    constexpr
    inline _Iter_equals_val<_Value>
    __iter_equals_val(_Value& __val)
    { return _Iter_equals_val<_Value>(__val); }

  template<typename _Iterator1>
    struct _Iter_equals_iter
    {
      _Iterator1 _M_it1;

      constexpr
      explicit
      _Iter_equals_iter(_Iterator1 __it1)
 : _M_it1(__it1)
      { }

      template<typename _Iterator2>
 constexpr
 bool
 operator()(_Iterator2 __it2)
 { return *__it2 == *_M_it1; }
    };

  template<typename _Iterator>
    constexpr
    inline _Iter_equals_iter<_Iterator>
    __iter_comp_iter(_Iter_equal_to_iter, _Iterator __it)
    { return _Iter_equals_iter<_Iterator>(__it); }

  template<typename _Predicate>
    struct _Iter_pred
    {
      _Predicate _M_pred;

      constexpr
      explicit
      _Iter_pred(_Predicate __pred)
 : _M_pred(std::move(__pred))
      { }

      template<typename _Iterator>
 constexpr
 bool
 operator()(_Iterator __it)
 { return bool(_M_pred(*__it)); }
    };

  template<typename _Predicate>
    constexpr
    inline _Iter_pred<_Predicate>
    __pred_iter(_Predicate __pred)
    { return _Iter_pred<_Predicate>(std::move(__pred)); }

  template<typename _Compare, typename _Value>
    struct _Iter_comp_to_val
    {
      _Compare _M_comp;
      _Value& _M_value;

      constexpr
      _Iter_comp_to_val(_Compare __comp, _Value& __value)
 : _M_comp(std::move(__comp)), _M_value(__value)
      { }

      template<typename _Iterator>
 constexpr
 bool
 operator()(_Iterator __it)
 { return bool(_M_comp(*__it, _M_value)); }
    };

  template<typename _Compare, typename _Value>
    _Iter_comp_to_val<_Compare, _Value>
    constexpr
    __iter_comp_val(_Compare __comp, _Value &__val)
    {
      return _Iter_comp_to_val<_Compare, _Value>(std::move(__comp), __val);
    }

  template<typename _Compare, typename _Iterator1>
    struct _Iter_comp_to_iter
    {
      _Compare _M_comp;
      _Iterator1 _M_it1;

      constexpr
      _Iter_comp_to_iter(_Compare __comp, _Iterator1 __it1)
 : _M_comp(std::move(__comp)), _M_it1(__it1)
      { }

      template<typename _Iterator2>
 constexpr
 bool
 operator()(_Iterator2 __it2)
 { return bool(_M_comp(*__it2, *_M_it1)); }
    };

  template<typename _Compare, typename _Iterator>
    constexpr
    inline _Iter_comp_to_iter<_Compare, _Iterator>
    __iter_comp_iter(_Iter_comp_iter<_Compare> __comp, _Iterator __it)
    {
      return _Iter_comp_to_iter<_Compare, _Iterator>(
   std::move(__comp._M_comp), __it);
    }

  template<typename _Predicate>
    struct _Iter_negate
    {
      _Predicate _M_pred;

      constexpr
      explicit
      _Iter_negate(_Predicate __pred)
 : _M_pred(std::move(__pred))
      { }

      template<typename _Iterator>
 constexpr
 bool
 operator()(_Iterator __it)
 { return !bool(_M_pred(*__it)); }
    };

  template<typename _Predicate>
    constexpr
    inline _Iter_negate<_Predicate>
    __negate(_Iter_pred<_Predicate> __pred)
    { return _Iter_negate<_Predicate>(std::move(__pred._M_pred)); }

}
}
# 72 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_algobase.h" 2 3




# 1 "D:/Programs/MinGW/include/c++/14.2.0/bit" 1 3
# 32 "D:/Programs/MinGW/include/c++/14.2.0/bit" 3
       
# 33 "D:/Programs/MinGW/include/c++/14.2.0/bit" 3
# 61 "D:/Programs/MinGW/include/c++/14.2.0/bit" 3
# 1 "D:/Programs/MinGW/include/c++/14.2.0/bits/version.h" 1 3
# 47 "D:/Programs/MinGW/include/c++/14.2.0/bits/version.h" 3
       
# 48 "D:/Programs/MinGW/include/c++/14.2.0/bits/version.h" 3
# 62 "D:/Programs/MinGW/include/c++/14.2.0/bit" 2 3

namespace std
{

# 85 "D:/Programs/MinGW/include/c++/14.2.0/bit" 3
  template<typename _To, typename _From>
    [[nodiscard]]
    constexpr _To
    bit_cast(const _From& __from) noexcept

    requires (sizeof(_To) == sizeof(_From))
      && is_trivially_copyable_v<_To> && is_trivially_copyable_v<_From>

    {
      return __builtin_bit_cast(_To, __from);
    }
# 107 "D:/Programs/MinGW/include/c++/14.2.0/bit" 3
  template<integral _Tp>
    [[nodiscard]]
    constexpr _Tp
    byteswap(_Tp __value) noexcept
    {
      if constexpr (sizeof(_Tp) == 1)
 return __value;

      if !consteval
 {
   if constexpr (sizeof(_Tp) == 2)
     return __builtin_bswap16(__value);
   if constexpr (sizeof(_Tp) == 4)
     return __builtin_bswap32(__value);
   if constexpr (sizeof(_Tp) == 8)
     return __builtin_bswap64(__value);
   if constexpr (sizeof(_Tp) == 16)

     return __builtin_bswap128(__value);




 }



      using _Up = typename __make_unsigned<__remove_cv_t<_Tp>>::__type;
      size_t __diff = 8 * (sizeof(_Tp) - 1);
      _Up __mask1 = static_cast<unsigned char>(~0);
      _Up __mask2 = __mask1 << __diff;
      _Up __val = __value;
      for (size_t __i = 0; __i < sizeof(_Tp) / 2; ++__i)
 {
   _Up __byte1 = __val & __mask1;
   _Up __byte2 = __val & __mask2;
   __val = (__val ^ __byte1 ^ __byte2
     ^ (__byte1 << __diff) ^ (__byte2 >> __diff));
   __mask1 <<= 8;
   __mask2 >>= 8;
   __diff -= 2 * 8;
 }
      return __val;
    }




  template<typename _Tp>
    constexpr _Tp
    __rotl(_Tp __x, int __s) noexcept
    {
      constexpr auto _Nd = __gnu_cxx::__int_traits<_Tp>::__digits;
      if constexpr ((_Nd & (_Nd - 1)) == 0)
 {


   constexpr unsigned __uNd = _Nd;
   const unsigned __r = __s;
   return (__x << (__r % __uNd)) | (__x >> ((-__r) % __uNd));
 }
      const int __r = __s % _Nd;
      if (__r == 0)
 return __x;
      else if (__r > 0)
 return (__x << __r) | (__x >> ((_Nd - __r) % _Nd));
      else
 return (__x >> -__r) | (__x << ((_Nd + __r) % _Nd));
    }

  template<typename _Tp>
    constexpr _Tp
    __rotr(_Tp __x, int __s) noexcept
    {
      constexpr auto _Nd = __gnu_cxx::__int_traits<_Tp>::__digits;
      if constexpr ((_Nd & (_Nd - 1)) == 0)
 {


   constexpr unsigned __uNd = _Nd;
   const unsigned __r = __s;
   return (__x >> (__r % __uNd)) | (__x << ((-__r) % __uNd));
 }
      const int __r = __s % _Nd;
      if (__r == 0)
 return __x;
      else if (__r > 0)
 return (__x >> __r) | (__x << ((_Nd - __r) % _Nd));
      else
 return (__x << -__r) | (__x >> ((_Nd + __r) % _Nd));
    }

  template<typename _Tp>
    constexpr int
    __countl_zero(_Tp __x) noexcept
    {
      using __gnu_cxx::__int_traits;
      constexpr auto _Nd = __int_traits<_Tp>::__digits;

      if (__x == 0)
        return _Nd;

      constexpr auto _Nd_ull = __int_traits<unsigned long long>::__digits;
      constexpr auto _Nd_ul = __int_traits<unsigned long>::__digits;
      constexpr auto _Nd_u = __int_traits<unsigned>::__digits;

      if constexpr (_Nd <= _Nd_u)
 {
   constexpr int __diff = _Nd_u - _Nd;
   return __builtin_clz(__x) - __diff;
 }
      else if constexpr (_Nd <= _Nd_ul)
 {
   constexpr int __diff = _Nd_ul - _Nd;
   return __builtin_clzl(__x) - __diff;
 }
      else if constexpr (_Nd <= _Nd_ull)
 {
   constexpr int __diff = _Nd_ull - _Nd;
   return __builtin_clzll(__x) - __diff;
 }
      else
 {
   static_assert(_Nd <= (2 * _Nd_ull),
   "Maximum supported integer size is 128-bit");

   unsigned long long __high = __x >> _Nd_ull;
   if (__high != 0)
     {
       constexpr int __diff = (2 * _Nd_ull) - _Nd;
       return __builtin_clzll(__high) - __diff;
     }
   constexpr auto __max_ull = __int_traits<unsigned long long>::__max;
   unsigned long long __low = __x & __max_ull;
   return (_Nd - _Nd_ull) + __builtin_clzll(__low);
 }
    }

  template<typename _Tp>
    constexpr int
    __countl_one(_Tp __x) noexcept
    {
      return std::__countl_zero<_Tp>((_Tp)~__x);
    }

  template<typename _Tp>
    constexpr int
    __countr_zero(_Tp __x) noexcept
    {
      using __gnu_cxx::__int_traits;
      constexpr auto _Nd = __int_traits<_Tp>::__digits;

      if (__x == 0)
        return _Nd;

      constexpr auto _Nd_ull = __int_traits<unsigned long long>::__digits;
      constexpr auto _Nd_ul = __int_traits<unsigned long>::__digits;
      constexpr auto _Nd_u = __int_traits<unsigned>::__digits;

      if constexpr (_Nd <= _Nd_u)
 return __builtin_ctz(__x);
      else if constexpr (_Nd <= _Nd_ul)
 return __builtin_ctzl(__x);
      else if constexpr (_Nd <= _Nd_ull)
 return __builtin_ctzll(__x);
      else
 {
   static_assert(_Nd <= (2 * _Nd_ull),
   "Maximum supported integer size is 128-bit");

   constexpr auto __max_ull = __int_traits<unsigned long long>::__max;
   unsigned long long __low = __x & __max_ull;
   if (__low != 0)
     return __builtin_ctzll(__low);
   unsigned long long __high = __x >> _Nd_ull;
   return __builtin_ctzll(__high) + _Nd_ull;
 }
    }

  template<typename _Tp>
    constexpr int
    __countr_one(_Tp __x) noexcept
    {
      return std::__countr_zero((_Tp)~__x);
    }

  template<typename _Tp>
    constexpr int
    __popcount(_Tp __x) noexcept
    {
      using __gnu_cxx::__int_traits;
      constexpr auto _Nd = __int_traits<_Tp>::__digits;

      constexpr auto _Nd_ull = __int_traits<unsigned long long>::__digits;
      constexpr auto _Nd_ul = __int_traits<unsigned long>::__digits;
      constexpr auto _Nd_u = __int_traits<unsigned>::__digits;

      if constexpr (_Nd <= _Nd_u)
 return __builtin_popcount(__x);
      else if constexpr (_Nd <= _Nd_ul)
 return __builtin_popcountl(__x);
      else if constexpr (_Nd <= _Nd_ull)
 return __builtin_popcountll(__x);
      else
 {
   static_assert(_Nd <= (2 * _Nd_ull),
   "Maximum supported integer size is 128-bit");

   constexpr auto __max_ull = __int_traits<unsigned long long>::__max;
   unsigned long long __low = __x & __max_ull;
   unsigned long long __high = __x >> _Nd_ull;
   return __builtin_popcountll(__low) + __builtin_popcountll(__high);
 }
    }

  template<typename _Tp>
    constexpr bool
    __has_single_bit(_Tp __x) noexcept
    { return std::__popcount(__x) == 1; }

  template<typename _Tp>
    constexpr _Tp
    __bit_ceil(_Tp __x) noexcept
    {
      using __gnu_cxx::__int_traits;
      constexpr auto _Nd = __int_traits<_Tp>::__digits;
      if (__x == 0 || __x == 1)
        return 1;
      auto __shift_exponent = _Nd - std::__countl_zero((_Tp)(__x - 1u));




      if (!std::__is_constant_evaluated())
 {
   do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__shift_exponent != __int_traits<_Tp>::__digits), false)) std::__glibcxx_assert_fail(); } while (false);
 }

      using __promoted_type = decltype(__x << 1);
      if constexpr (!is_same<__promoted_type, _Tp>::value)
 {





   const int __extra_exp = sizeof(__promoted_type) / sizeof(_Tp) / 2;
   __shift_exponent |= (__shift_exponent & _Nd) << __extra_exp;
 }
      return (_Tp)1u << __shift_exponent;
    }

  template<typename _Tp>
    constexpr _Tp
    __bit_floor(_Tp __x) noexcept
    {
      constexpr auto _Nd = __gnu_cxx::__int_traits<_Tp>::__digits;
      if (__x == 0)
        return 0;
      return (_Tp)1u << (_Nd - std::__countl_zero((_Tp)(__x >> 1)));
    }

  template<typename _Tp>
    constexpr int
    __bit_width(_Tp __x) noexcept
    {
      constexpr auto _Nd = __gnu_cxx::__int_traits<_Tp>::__digits;
      return _Nd - std::__countl_zero(__x);
    }






  template<typename _Tp>
    concept __unsigned_integer = __is_unsigned_integer<_Tp>::value;





  template<__unsigned_integer _Tp>
    [[nodiscard]] constexpr _Tp
    rotl(_Tp __x, int __s) noexcept
    { return std::__rotl(__x, __s); }


  template<__unsigned_integer _Tp>
    [[nodiscard]] constexpr _Tp
    rotr(_Tp __x, int __s) noexcept
    { return std::__rotr(__x, __s); }




  template<__unsigned_integer _Tp>
    constexpr int
    countl_zero(_Tp __x) noexcept
    { return std::__countl_zero(__x); }


  template<__unsigned_integer _Tp>
    constexpr int
    countl_one(_Tp __x) noexcept
    { return std::__countl_one(__x); }


  template<__unsigned_integer _Tp>
    constexpr int
    countr_zero(_Tp __x) noexcept
    { return std::__countr_zero(__x); }


  template<__unsigned_integer _Tp>
    constexpr int
    countr_one(_Tp __x) noexcept
    { return std::__countr_one(__x); }


  template<__unsigned_integer _Tp>
    constexpr int
    popcount(_Tp __x) noexcept
    { return std::__popcount(__x); }






  template<__unsigned_integer _Tp>
    constexpr bool
    has_single_bit(_Tp __x) noexcept
    { return std::__has_single_bit(__x); }


  template<__unsigned_integer _Tp>
    constexpr _Tp
    bit_ceil(_Tp __x) noexcept
    { return std::__bit_ceil(__x); }


  template<__unsigned_integer _Tp>
    constexpr _Tp
    bit_floor(_Tp __x) noexcept
    { return std::__bit_floor(__x); }




  template<__unsigned_integer _Tp>
    constexpr int
    bit_width(_Tp __x) noexcept
    { return std::__bit_width(__x); }
# 472 "D:/Programs/MinGW/include/c++/14.2.0/bit" 3
  enum class endian
  {
    little = 1234,
    big = 4321,
    native = 1234
  };





}
# 77 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_algobase.h" 2 3





namespace std
{






  template<typename _Tp, typename _Up>
    constexpr
    inline int
    __memcmp(const _Tp* __first1, const _Up* __first2, size_t __num)
    {

      static_assert(sizeof(_Tp) == sizeof(_Up), "can be compared with memcmp");


      if (std::is_constant_evaluated())
 {
   for(; __num > 0; ++__first1, ++__first2, --__num)
     if (*__first1 != *__first2)
       return *__first1 < *__first2 ? -1 : 1;
   return 0;
 }
      else

 return __builtin_memcmp(__first1, __first2, sizeof(_Tp) * __num);
    }
# 152 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    constexpr
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {

     

     
# 185 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_algobase.h" 3
      swap(*__a, *__b);

    }
# 201 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    constexpr
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {

     

     

      ;

      for (; __first1 != __last1; ++__first1, (void)++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }
# 230 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_algobase.h" 3
  template<typename _Tp>
    [[__nodiscard__]] constexpr
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {

     

      if (__b < __a)
 return __b;
      return __a;
    }
# 254 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_algobase.h" 3
  template<typename _Tp>
    [[__nodiscard__]] constexpr
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {

     

      if (__a < __b)
 return __b;
      return __a;
    }
# 278 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    [[__nodiscard__]] constexpr
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__b, __a))
 return __b;
      return __a;
    }
# 300 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    [[__nodiscard__]] constexpr
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__a, __b))
 return __b;
      return __a;
    }



  template<typename _Iterator>
    constexpr
    inline _Iterator
    __niter_base(_Iterator __it)
    noexcept(std::is_nothrow_copy_constructible<_Iterator>::value)
    { return __it; }
# 332 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_algobase.h" 3
  template<typename _Ite, typename _Seq>
    constexpr
    decltype(std::__niter_base(std::declval<_Ite>()))
    __niter_base(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq,
   std::random_access_iterator_tag>&)
    noexcept(std::is_nothrow_copy_constructible<_Ite>::value);





  template<typename _From, typename _To>
    constexpr
    inline _From
    __niter_wrap(_From __from, _To __res)
    { return __from + (std::__niter_base(__res) - std::__niter_base(__from)); }


  template<typename _Iterator>
    constexpr
    inline _Iterator
    __niter_wrap(const _Iterator&, _Iterator __res)
    { return __res; }







  template<bool _IsMove, bool _IsSimple, typename _Category>
    struct __copy_move
    {
      template<typename _II, typename _OI>
 constexpr
 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   for (; __first != __last; ++__result, (void)++__first)
     *__result = *__first;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move<true, false, _Category>
    {
      template<typename _II, typename _OI>
 constexpr
 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   for (; __first != __last; ++__result, (void)++__first)
     *__result = std::move(*__first);
   return __result;
 }
    };


  template<>
    struct __copy_move<false, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
 constexpr
 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = *__first;
       ++__first;
       ++__result;
     }
   return __result;
 }

      template<typename _Tp, typename _Up>
 static void
 __assign_one(_Tp* __to, _Up* __from)
 { *__to = *__from; }
    };


  template<>
    struct __copy_move<true, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
 constexpr
 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = std::move(*__first);
       ++__first;
       ++__result;
     }
   return __result;
 }

      template<typename _Tp, typename _Up>
 static void
 __assign_one(_Tp* __to, _Up* __from)
 { *__to = std::move(*__from); }
    };


  template<bool _IsMove>
    struct __copy_move<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp, typename _Up>
 constexpr
 static _Up*
 __copy_m(_Tp* __first, _Tp* __last, _Up* __result)
 {
   const ptrdiff_t _Num = __last - __first;
   if (__builtin_expect(_Num > 1, true))
     __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
   else if (_Num == 1)
     std::__copy_move<_IsMove, false, random_access_iterator_tag>::
       __assign_one(__result, __first);
   return __result + _Num;
 }
    };



  template<typename _Tp, typename _Ref, typename _Ptr>
    struct _Deque_iterator;

  struct _Bit_iterator;






  template<typename _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits>
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator;

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(_CharT*, _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(const _CharT*, const _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
     istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<
      __is_char<_CharT>::__value,
      std::_Deque_iterator<_CharT, _CharT&, _CharT*> >::__type
    __copy_move_a2(
 istreambuf_iterator<_CharT, char_traits<_CharT> >,
 istreambuf_iterator<_CharT, char_traits<_CharT> >,
 std::_Deque_iterator<_CharT, _CharT&, _CharT*>);


  template<bool _IsMove, typename _II, typename _OI>
    constexpr
    inline _OI
    __copy_move_a2(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::iterator_category _Category;

      if (std::is_constant_evaluated())
 return std::__copy_move<_IsMove, false, _Category>::
   __copy_m(__first, __last, __result);

      return std::__copy_move<_IsMove, __memcpyable<_OI, _II>::__value,
         _Category>::__copy_m(__first, __last, __result);
    }

  template<bool _IsMove,
    typename _Tp, typename _Ref, typename _Ptr, typename _OI>
    _OI
    __copy_move_a1(std::_Deque_iterator<_Tp, _Ref, _Ptr>,
     std::_Deque_iterator<_Tp, _Ref, _Ptr>,
     _OI);

  template<bool _IsMove,
    typename _ITp, typename _IRef, typename _IPtr, typename _OTp>
    std::_Deque_iterator<_OTp, _OTp&, _OTp*>
    __copy_move_a1(std::_Deque_iterator<_ITp, _IRef, _IPtr>,
     std::_Deque_iterator<_ITp, _IRef, _IPtr>,
     std::_Deque_iterator<_OTp, _OTp&, _OTp*>);

  template<bool _IsMove, typename _II, typename _Tp>
    typename __gnu_cxx::__enable_if<
      __is_random_access_iter<_II>::__value,
      std::_Deque_iterator<_Tp, _Tp&, _Tp*> >::__type
    __copy_move_a1(_II, _II, std::_Deque_iterator<_Tp, _Tp&, _Tp*>);

  template<bool _IsMove, typename _II, typename _OI>
    constexpr
    inline _OI
    __copy_move_a1(_II __first, _II __last, _OI __result)
    { return std::__copy_move_a2<_IsMove>(__first, __last, __result); }

  template<bool _IsMove, typename _II, typename _OI>
    constexpr
    inline _OI
    __copy_move_a(_II __first, _II __last, _OI __result)
    {
      return std::__niter_wrap(__result,
  std::__copy_move_a1<_IsMove>(std::__niter_base(__first),
          std::__niter_base(__last),
          std::__niter_base(__result)));
    }

  template<bool _IsMove,
    typename _Ite, typename _Seq, typename _Cat, typename _OI>
    constexpr
    _OI
    __copy_move_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
    const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
    _OI);

  template<bool _IsMove,
    typename _II, typename _Ite, typename _Seq, typename _Cat>
    constexpr
    __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>
    __copy_move_a(_II, _II,
    const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&);

  template<bool _IsMove,
    typename _IIte, typename _ISeq, typename _ICat,
    typename _OIte, typename _OSeq, typename _OCat>
    constexpr
    ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>
    __copy_move_a(const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
    const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
    const ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>&);

  template<typename _InputIterator, typename _Size, typename _OutputIterator>
    constexpr
    _OutputIterator
    __copy_n_a(_InputIterator __first, _Size __n, _OutputIterator __result,
        bool)
    {
      if (__n > 0)
 {
   while (true)
     {
       *__result = *__first;
       ++__result;
       if (--__n > 0)
  ++__first;
       else
  break;
     }
 }
      return __result;
    }


  template<typename _CharT, typename _Size>
    typename __gnu_cxx::__enable_if<
      __is_char<_CharT>::__value, _CharT*>::__type
    __copy_n_a(istreambuf_iterator<_CharT, char_traits<_CharT> >,
        _Size, _CharT*, bool);

  template<typename _CharT, typename _Size>
    typename __gnu_cxx::__enable_if<
      __is_char<_CharT>::__value,
      std::_Deque_iterator<_CharT, _CharT&, _CharT*> >::__type
    __copy_n_a(istreambuf_iterator<_CharT, char_traits<_CharT> >, _Size,
        std::_Deque_iterator<_CharT, _CharT&, _CharT*>,
        bool);
# 639 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    constexpr
    inline _OI
    copy(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return std::__copy_move_a<__is_move_iterator<_II>::__value>
      (std::__miter_base(__first), std::__miter_base(__last), __result);
    }
# 672 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    constexpr
    inline _OI
    move(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return std::__copy_move_a<true>(std::__miter_base(__first),
          std::__miter_base(__last), __result);
    }






  template<bool _IsMove, bool _IsSimple, typename _Category>
    struct __copy_move_backward
    {
      template<typename _BI1, typename _BI2>
 constexpr
 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   while (__first != __last)
     *--__result = *--__last;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move_backward<true, false, _Category>
    {
      template<typename _BI1, typename _BI2>
 constexpr
 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   while (__first != __last)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<false, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
 constexpr
 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   typename iterator_traits<_BI1>::difference_type
     __n = __last - __first;
   for (; __n > 0; --__n)
     *--__result = *--__last;
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<true, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
 constexpr
 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   typename iterator_traits<_BI1>::difference_type
     __n = __last - __first;
   for (; __n > 0; --__n)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp, typename _Up>
 constexpr
 static _Up*
 __copy_move_b(_Tp* __first, _Tp* __last, _Up* __result)
 {
   const ptrdiff_t _Num = __last - __first;
   if (__builtin_expect(_Num > 1, true))
     __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
   else if (_Num == 1)
     std::__copy_move<_IsMove, false, random_access_iterator_tag>::
       __assign_one(__result - 1, __first);
   return __result - _Num;
 }
    };

  template<bool _IsMove, typename _BI1, typename _BI2>
    constexpr
    inline _BI2
    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::iterator_category _Category;

      if (std::is_constant_evaluated())
 return std::__copy_move_backward<_IsMove, false, _Category>::
   __copy_move_b(__first, __last, __result);

      return std::__copy_move_backward<_IsMove,
           __memcpyable<_BI2, _BI1>::__value,
           _Category>::__copy_move_b(__first,
         __last,
         __result);
    }

  template<bool _IsMove, typename _BI1, typename _BI2>
    constexpr
    inline _BI2
    __copy_move_backward_a1(_BI1 __first, _BI1 __last, _BI2 __result)
    { return std::__copy_move_backward_a2<_IsMove>(__first, __last, __result); }

  template<bool _IsMove,
    typename _Tp, typename _Ref, typename _Ptr, typename _OI>
    _OI
    __copy_move_backward_a1(std::_Deque_iterator<_Tp, _Ref, _Ptr>,
       std::_Deque_iterator<_Tp, _Ref, _Ptr>,
       _OI);

  template<bool _IsMove,
    typename _ITp, typename _IRef, typename _IPtr, typename _OTp>
    std::_Deque_iterator<_OTp, _OTp&, _OTp*>
    __copy_move_backward_a1(
   std::_Deque_iterator<_ITp, _IRef, _IPtr>,
   std::_Deque_iterator<_ITp, _IRef, _IPtr>,
   std::_Deque_iterator<_OTp, _OTp&, _OTp*>);

  template<bool _IsMove, typename _II, typename _Tp>
    typename __gnu_cxx::__enable_if<
      __is_random_access_iter<_II>::__value,
      std::_Deque_iterator<_Tp, _Tp&, _Tp*> >::__type
    __copy_move_backward_a1(_II, _II,
       std::_Deque_iterator<_Tp, _Tp&, _Tp*>);

  template<bool _IsMove, typename _II, typename _OI>
    constexpr
    inline _OI
    __copy_move_backward_a(_II __first, _II __last, _OI __result)
    {
      return std::__niter_wrap(__result,
  std::__copy_move_backward_a1<_IsMove>
    (std::__niter_base(__first), std::__niter_base(__last),
     std::__niter_base(__result)));
    }

  template<bool _IsMove,
    typename _Ite, typename _Seq, typename _Cat, typename _OI>
    constexpr
    _OI
    __copy_move_backward_a(
  const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
  const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
  _OI);

  template<bool _IsMove,
    typename _II, typename _Ite, typename _Seq, typename _Cat>
    constexpr
    __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>
    __copy_move_backward_a(_II, _II,
  const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&);

  template<bool _IsMove,
    typename _IIte, typename _ISeq, typename _ICat,
    typename _OIte, typename _OSeq, typename _OCat>
    constexpr
    ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>
    __copy_move_backward_a(
  const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
  const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
  const ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>&);
# 875 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    constexpr
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     

      ;

      return std::__copy_move_backward_a<__is_move_iterator<_BI1>::__value>
      (std::__miter_base(__first), std::__miter_base(__last), __result);
    }
# 910 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    constexpr
    inline _BI2
    move_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     

      ;

      return std::__copy_move_backward_a<true>(std::__miter_base(__first),
            std::__miter_base(__last),
            __result);
    }






  template<typename _ForwardIterator, typename _Tp>
    constexpr
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
    __fill_a1(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      for (; __first != __last; ++__first)
 *__first = __value;
    }

  template<typename _ForwardIterator, typename _Tp>
    constexpr
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a1(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
 *__first = __tmp;
    }


  template<typename _Tp>
    constexpr
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
    __fill_a1(_Tp* __first, _Tp* __last, const _Tp& __c)
    {
      const _Tp __tmp = __c;

      if (std::is_constant_evaluated())
 {
   for (; __first != __last; ++__first)
     *__first = __tmp;
   return;
 }

      if (const size_t __len = __last - __first)
 __builtin_memset(__first, static_cast<unsigned char>(__tmp), __len);
    }

  template<typename _Ite, typename _Cont, typename _Tp>
    constexpr
    inline void
    __fill_a1(::__gnu_cxx::__normal_iterator<_Ite, _Cont> __first,
       ::__gnu_cxx::__normal_iterator<_Ite, _Cont> __last,
       const _Tp& __value)
    { std::__fill_a1(__first.base(), __last.base(), __value); }

  template<typename _Tp, typename _VTp>
    void
    __fill_a1(const std::_Deque_iterator<_Tp, _Tp&, _Tp*>&,
       const std::_Deque_iterator<_Tp, _Tp&, _Tp*>&,
       const _VTp&);

  constexpr
  void
  __fill_a1(std::_Bit_iterator, std::_Bit_iterator,
     const bool&);

  template<typename _FIte, typename _Tp>
    constexpr
    inline void
    __fill_a(_FIte __first, _FIte __last, const _Tp& __value)
    { std::__fill_a1(__first, __last, __value); }

  template<typename _Ite, typename _Seq, typename _Cat, typename _Tp>
    constexpr
    void
    __fill_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
      const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
      const _Tp&);
# 1019 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    constexpr
    inline void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {

     

      ;

      std::__fill_a(__first, __last, __value);
    }


  inline constexpr int
  __size_to_integer(int __n) { return __n; }
  inline constexpr unsigned
  __size_to_integer(unsigned __n) { return __n; }
  inline constexpr long
  __size_to_integer(long __n) { return __n; }
  inline constexpr unsigned long
  __size_to_integer(unsigned long __n) { return __n; }
  inline constexpr long long
  __size_to_integer(long long __n) { return __n; }
  inline constexpr unsigned long long
  __size_to_integer(unsigned long long __n) { return __n; }


  __extension__ inline constexpr __int128
  __size_to_integer(__int128 __n) { return __n; }
  __extension__ inline constexpr unsigned __int128
  __size_to_integer(unsigned __int128 __n) { return __n; }
# 1071 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_algobase.h" 3
  inline constexpr long long
  __size_to_integer(float __n) { return (long long)__n; }
  inline constexpr long long
  __size_to_integer(double __n) { return (long long)__n; }
  inline constexpr long long
  __size_to_integer(long double __n) { return (long long)__n; }

  __extension__ inline constexpr long long
  __size_to_integer(__float128 __n) { return (long long)__n; }


  template<typename _OutputIterator, typename _Size, typename _Tp>
    constexpr
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a1(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      for (; __n > 0; --__n, (void) ++__first)
 *__first = __value;
      return __first;
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    constexpr
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a1(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __n > 0; --__n, (void) ++__first)
 *__first = __tmp;
      return __first;
    }

  template<typename _Ite, typename _Seq, typename _Cat, typename _Size,
    typename _Tp>
    constexpr
    ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>
    __fill_n_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>& __first,
        _Size __n, const _Tp& __value,
        std::input_iterator_tag);

  template<typename _OutputIterator, typename _Size, typename _Tp>
    constexpr
    inline _OutputIterator
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,
        std::output_iterator_tag)
    {

      static_assert(is_integral<_Size>{}, "fill_n must pass integral size");

      return __fill_n_a1(__first, __n, __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    constexpr
    inline _OutputIterator
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,
        std::input_iterator_tag)
    {

      static_assert(is_integral<_Size>{}, "fill_n must pass integral size");

      return __fill_n_a1(__first, __n, __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    constexpr
    inline _OutputIterator
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,
        std::random_access_iterator_tag)
    {

      static_assert(is_integral<_Size>{}, "fill_n must pass integral size");

      if (__n <= 0)
 return __first;

      ;

      std::__fill_a(__first, __first + __n, __value);
      return __first + __n;
    }
# 1172 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_algobase.h" 3
  template<typename _OI, typename _Size, typename _Tp>
    constexpr
    inline _OI
    fill_n(_OI __first, _Size __n, const _Tp& __value)
    {

     

      return std::__fill_n_a(__first, std::__size_to_integer(__n), __value,
          std::__iterator_category(__first));
    }

  template<bool _BoolType>
    struct __equal
    {
      template<typename _II1, typename _II2>
 constexpr
 static bool
 equal(_II1 __first1, _II1 __last1, _II2 __first2)
 {
   for (; __first1 != __last1; ++__first1, (void) ++__first2)
     if (!(*__first1 == *__first2))
       return false;
   return true;
 }
    };

  template<>
    struct __equal<true>
    {
      template<typename _Tp>
 constexpr
 static bool
 equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
 {
   if (const size_t __len = (__last1 - __first1))
     return !std::__memcmp(__first1, __first2, __len);
   return true;
 }
    };

  template<typename _Tp, typename _Ref, typename _Ptr, typename _II>
    typename __gnu_cxx::__enable_if<
      __is_random_access_iter<_II>::__value, bool>::__type
    __equal_aux1(std::_Deque_iterator<_Tp, _Ref, _Ptr>,
   std::_Deque_iterator<_Tp, _Ref, _Ptr>,
   _II);

  template<typename _Tp1, typename _Ref1, typename _Ptr1,
    typename _Tp2, typename _Ref2, typename _Ptr2>
    bool
    __equal_aux1(std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
   std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
   std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);

  template<typename _II, typename _Tp, typename _Ref, typename _Ptr>
    typename __gnu_cxx::__enable_if<
      __is_random_access_iter<_II>::__value, bool>::__type
    __equal_aux1(_II, _II,
  std::_Deque_iterator<_Tp, _Ref, _Ptr>);

  template<typename _II1, typename _II2>
    constexpr
    inline bool
    __equal_aux1(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      const bool __simple = ((__is_integer<_ValueType1>::__value
         || __is_pointer<_ValueType1>::__value)
        && __memcmpable<_II1, _II2>::__value);
      return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }

  template<typename _II1, typename _II2>
    constexpr
    inline bool
    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      return std::__equal_aux1(std::__niter_base(__first1),
          std::__niter_base(__last1),
          std::__niter_base(__first2));
    }

  template<typename _II1, typename _Seq1, typename _Cat1, typename _II2>
    constexpr
    bool
    __equal_aux(const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,
  _II2);

  template<typename _II1, typename _II2, typename _Seq2, typename _Cat2>
    constexpr
    bool
    __equal_aux(_II1, _II1,
  const ::__gnu_debug::_Safe_iterator<_II2, _Seq2, _Cat2>&);

  template<typename _II1, typename _Seq1, typename _Cat1,
    typename _II2, typename _Seq2, typename _Cat2>
    constexpr
    bool
    __equal_aux(const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_II2, _Seq2, _Cat2>&);

  template<typename, typename>
    struct __lc_rai
    {
      template<typename _II1, typename _II2>
 constexpr
 static _II1
 __newlast1(_II1, _II1 __last1, _II2, _II2)
 { return __last1; }

      template<typename _II>
 constexpr
 static bool
 __cnd2(_II __first, _II __last)
 { return __first != __last; }
    };

  template<>
    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
    {
      template<typename _RAI1, typename _RAI2>
 constexpr
 static _RAI1
 __newlast1(_RAI1 __first1, _RAI1 __last1,
     _RAI2 __first2, _RAI2 __last2)
 {
   const typename iterator_traits<_RAI1>::difference_type
     __diff1 = __last1 - __first1;
   const typename iterator_traits<_RAI2>::difference_type
     __diff2 = __last2 - __first2;
   return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
 }

      template<typename _RAI>
 static constexpr bool
 __cnd2(_RAI, _RAI)
 { return true; }
    };

  template<typename _II1, typename _II2, typename _Compare>
    constexpr
    bool
    __lexicographical_compare_impl(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2,
       _Compare __comp)
    {
      typedef typename iterator_traits<_II1>::iterator_category _Category1;
      typedef typename iterator_traits<_II2>::iterator_category _Category2;
      typedef std::__lc_rai<_Category1, _Category2> __rai_type;

      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
    ++__first1, (void)++__first2)
 {
   if (__comp(__first1, __first2))
     return true;
   if (__comp(__first2, __first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }

  template<bool _BoolType>
    struct __lexicographical_compare
    {
      template<typename _II1, typename _II2>
 constexpr
 static bool
 __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
 {
   using __gnu_cxx::__ops::__iter_less_iter;
   return std::__lexicographical_compare_impl(__first1, __last1,
           __first2, __last2,
           __iter_less_iter());
 }

      template<typename _II1, typename _II2>
 constexpr
 static int
 __3way(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
 {
   while (__first1 != __last1)
     {
       if (__first2 == __last2)
  return +1;
       if (*__first1 < *__first2)
  return -1;
       if (*__first2 < *__first1)
  return +1;
       ++__first1;
       ++__first2;
     }
   return int(__first2 == __last2) - 1;
 }
    };

  template<>
    struct __lexicographical_compare<true>
    {
      template<typename _Tp, typename _Up>
 constexpr
 static bool
 __lc(const _Tp* __first1, const _Tp* __last1,
      const _Up* __first2, const _Up* __last2)
 { return __3way(__first1, __last1, __first2, __last2) < 0; }

      template<typename _Tp, typename _Up>
 constexpr
 static ptrdiff_t
 __3way(const _Tp* __first1, const _Tp* __last1,
        const _Up* __first2, const _Up* __last2)
 {
   const size_t __len1 = __last1 - __first1;
   const size_t __len2 = __last2 - __first2;
   if (const size_t __len = std::min(__len1, __len2))
     if (int __result = std::__memcmp(__first1, __first2, __len))
       return __result;
   return ptrdiff_t(__len1 - __len2);
 }
    };

  template<typename _II1, typename _II2>
    constexpr
    inline bool
    __lexicographical_compare_aux1(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple =
 (__is_memcmp_ordered_with<_ValueType1, _ValueType2>::__value
  && __is_pointer<_II1>::__value
  && __is_pointer<_II2>::__value




  && !is_volatile_v<remove_reference_t<iter_reference_t<_II1>>>
  && !is_volatile_v<remove_reference_t<iter_reference_t<_II2>>>

  );

      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
           __first2, __last2);
    }

  template<typename _Tp1, typename _Ref1, typename _Ptr1,
    typename _Tp2>
    bool
    __lexicographical_compare_aux1(
 std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
 std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
 _Tp2*, _Tp2*);

  template<typename _Tp1,
    typename _Tp2, typename _Ref2, typename _Ptr2>
    bool
    __lexicographical_compare_aux1(_Tp1*, _Tp1*,
 std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>,
 std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);

  template<typename _Tp1, typename _Ref1, typename _Ptr1,
    typename _Tp2, typename _Ref2, typename _Ptr2>
    bool
    __lexicographical_compare_aux1(
 std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
 std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
 std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>,
 std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);

  template<typename _II1, typename _II2>
    constexpr
    inline bool
    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
      _II2 __first2, _II2 __last2)
    {
      return std::__lexicographical_compare_aux1(std::__niter_base(__first1),
       std::__niter_base(__last1),
       std::__niter_base(__first2),
       std::__niter_base(__last2));
    }

  template<typename _Iter1, typename _Seq1, typename _Cat1,
    typename _II2>
    constexpr
    bool
    __lexicographical_compare_aux(
  const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1>&,
  _II2, _II2);

  template<typename _II1,
    typename _Iter2, typename _Seq2, typename _Cat2>
    constexpr
    bool
    __lexicographical_compare_aux(
  _II1, _II1,
  const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2>&,
  const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2>&);

  template<typename _Iter1, typename _Seq1, typename _Cat1,
    typename _Iter2, typename _Seq2, typename _Cat2>
    constexpr
    bool
    __lexicographical_compare_aux(
  const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2>&,
  const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2>&);

  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    constexpr
    _ForwardIterator
    __lower_bound(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
# 1524 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    [[__nodiscard__]] constexpr
    inline _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {

     
     

      ;

      return std::__lower_bound(__first, __last, __val,
    __gnu_cxx::__ops::__iter_less_val());
    }



  template<typename _Tp>
    inline constexpr _Tp
    __lg(_Tp __n)
    {

      return std::__bit_width(make_unsigned_t<_Tp>(__n)) - 1;
# 1557 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_algobase.h" 3
    }


# 1573 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    [[__nodiscard__]] constexpr
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2)
    {

     
     
     


      ;

      return std::__equal_aux(__first1, __last1, __first2);
    }
# 1604 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    [[__nodiscard__]] constexpr
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      for (; __first1 != __last1; ++__first1, (void)++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return true;
    }



  template<typename _II1, typename _II2>
    constexpr
    inline bool
    __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
    {
      using _RATag = random_access_iterator_tag;
      using _Cat1 = typename iterator_traits<_II1>::iterator_category;
      using _Cat2 = typename iterator_traits<_II2>::iterator_category;
      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
      if (_RAIters())
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
   return std::equal(__first1, __last1, __first2);
 }

      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
 if (!(*__first1 == *__first2))
   return false;
      return __first1 == __last1 && __first2 == __last2;
    }


  template<typename _II1, typename _II2, typename _BinaryPredicate>
    constexpr
    inline bool
    __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2,
      _BinaryPredicate __binary_pred)
    {
      using _RATag = random_access_iterator_tag;
      using _Cat1 = typename iterator_traits<_II1>::iterator_category;
      using _Cat2 = typename iterator_traits<_II2>::iterator_category;
      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
      if (_RAIters())
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
   return std::equal(__first1, __last1, __first2,
           __binary_pred);
 }

      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return __first1 == __last1 && __first2 == __last2;
    }
# 1691 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    [[__nodiscard__]] constexpr
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
    {

     
     
     


      ;
      ;

      return std::__equal4(__first1, __last1, __first2, __last2);
    }
# 1724 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    [[__nodiscard__]] constexpr
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _IIter2 __last2, _BinaryPredicate __binary_pred)
    {

     
     
      ;
      ;

      return std::__equal4(__first1, __last1, __first2, __last2,
          __binary_pred);
    }
# 1756 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    [[__nodiscard__]] constexpr
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {





     
     
     
     
      ;
      ;

      return std::__lexicographical_compare_aux(__first1, __last1,
      __first2, __last2);
    }
# 1791 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2, typename _Compare>
    [[__nodiscard__]] constexpr
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2, _Compare __comp)
    {

     
     
      ;
      ;

      return std::__lexicographical_compare_impl
 (__first1, __last1, __first2, __last2,
  __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }





  template<typename _Iter1, typename _Iter2>
    concept __memcmp_ordered_with
      = (__is_memcmp_ordered_with<iter_value_t<_Iter1>,
      iter_value_t<_Iter2>>::__value)
   && contiguous_iterator<_Iter1> && contiguous_iterator<_Iter2>;



  template<typename _Tp>
    constexpr auto
    __min_cmp(_Tp __x, _Tp __y)
    {
      struct _Res {
 _Tp _M_min;
 decltype(__x <=> __y) _M_cmp;
      };
      auto __c = __x <=> __y;
      if (__c > 0)
 return _Res{__y, __c};
      return _Res{__x, __c};
    }
# 1845 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_algobase.h" 3
  template<typename _InputIter1, typename _InputIter2, typename _Comp>
    [[nodiscard]] constexpr auto
    lexicographical_compare_three_way(_InputIter1 __first1,
          _InputIter1 __last1,
          _InputIter2 __first2,
          _InputIter2 __last2,
          _Comp __comp)
    -> decltype(__comp(*__first1, *__first2))
    {

     
     
      ;
      ;

      using _Cat = decltype(__comp(*__first1, *__first2));
      static_assert(same_as<common_comparison_category_t<_Cat>, _Cat>);

      if (!std::__is_constant_evaluated())
 if constexpr (same_as<_Comp, __detail::_Synth3way>
        || same_as<_Comp, compare_three_way>)
   if constexpr (__memcmp_ordered_with<_InputIter1, _InputIter2>)
     {
       const auto [__len, __lencmp] = std::
  __min_cmp(__last1 - __first1, __last2 - __first2);
       if (__len)
  {
    const auto __blen = __len * sizeof(*__first1);
    const auto __c
      = __builtin_memcmp(&*__first1, &*__first2, __blen) <=> 0;
    if (__c != 0)
      return __c;
  }
       return __lencmp;
     }

      while (__first1 != __last1)
 {
   if (__first2 == __last2)
     return strong_ordering::greater;
   if (auto __cmp = __comp(*__first1, *__first2); __cmp != 0)
     return __cmp;
   ++__first1;
   ++__first2;
 }
      return (__first2 == __last2) <=> true;
    }

  template<typename _InputIter1, typename _InputIter2>
    constexpr auto
    lexicographical_compare_three_way(_InputIter1 __first1,
          _InputIter1 __last1,
          _InputIter2 __first2,
          _InputIter2 __last2)
    {
      return std::
 lexicographical_compare_three_way(__first1, __last1, __first2, __last2,
       compare_three_way{});
    }


  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    constexpr
    pair<_InputIterator1, _InputIterator2>
    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {
      while (__first1 != __last1 && __binary_pred(__first1, __first2))
 {
   ++__first1;
   ++__first2;
 }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 1934 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    [[__nodiscard__]] constexpr
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {

     
     
     


      ;

      return std::__mismatch(__first1, __last1, __first2,
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 1968 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    [[__nodiscard__]] constexpr
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      return std::__mismatch(__first1, __last1, __first2,
 __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }


  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    constexpr
    pair<_InputIterator1, _InputIterator2>
    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _BinaryPredicate __binary_pred)
    {
      while (__first1 != __last1 && __first2 != __last2
      && __binary_pred(__first1, __first2))
 {
   ++__first1;
   ++__first2;
 }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 2016 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    [[__nodiscard__]] constexpr
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
    {

     
     
     


      ;
      ;

      return std::__mismatch(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 2052 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    [[__nodiscard__]] constexpr
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _BinaryPredicate __binary_pred)
    {

     
     
      ;
      ;

      return std::__mismatch(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }





  template<typename _InputIterator, typename _Predicate>
    constexpr
    inline _InputIterator
    __find_if(_InputIterator __first, _InputIterator __last,
       _Predicate __pred, input_iterator_tag)
    {
      while (__first != __last && !__pred(__first))
 ++__first;
      return __first;
    }


  template<typename _RandomAccessIterator, typename _Predicate>
    constexpr
    _RandomAccessIterator
    __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Predicate __pred, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for (; __trip_count > 0; --__trip_count)
 {
   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (__pred(__first))
     return __first;
   ++__first;

 case 2:
   if (__pred(__first))
     return __first;
   ++__first;

 case 1:
   if (__pred(__first))
     return __first;
   ++__first;

 case 0:
 default:
   return __last;
 }
    }

  template<typename _Iterator, typename _Predicate>
    constexpr
    inline _Iterator
    __find_if(_Iterator __first, _Iterator __last, _Predicate __pred)
    {
      return __find_if(__first, __last, __pred,
         std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Predicate>
    constexpr
    typename iterator_traits<_InputIterator>::difference_type
    __count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for (; __first != __last; ++__first)
 if (__pred(__first))
   ++__n;
      return __n;
    }

  template<typename _ForwardIterator, typename _Predicate>
    constexpr
    _ForwardIterator
    __remove_if(_ForwardIterator __first, _ForwardIterator __last,
  _Predicate __pred)
    {
      __first = std::__find_if(__first, __last, __pred);
      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      ++__first;
      for (; __first != __last; ++__first)
 if (!__pred(__first))
   {
     *__result = std::move(*__first);
     ++__result;
   }
      return __result;
    }

  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    constexpr
    _ForwardIterator1
    __search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __predicate)
    {

      if (__first1 == __last1 || __first2 == __last2)
 return __first1;


      _ForwardIterator2 __p1(__first2);
      if (++__p1 == __last2)
 return std::__find_if(__first1, __last1,
  __gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2));


      _ForwardIterator1 __current = __first1;

      for (;;)
 {
   __first1 =
     std::__find_if(__first1, __last1,
  __gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2));

   if (__first1 == __last1)
     return __last1;

   _ForwardIterator2 __p = __p1;
   __current = __first1;
   if (++__current == __last1)
     return __last1;

   while (__predicate(__current, __p))
     {
       if (++__p == __last2)
  return __first1;
       if (++__current == __last1)
  return __last1;
     }
   ++__first1;
 }
      return __first1;
    }


  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    constexpr
    bool
    __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _BinaryPredicate __pred)
    {


      for (; __first1 != __last1; ++__first1, (void)++__first2)
 if (!__pred(__first1, __first2))
   break;

      if (__first1 == __last1)
 return true;



      _ForwardIterator2 __last2 = __first2;
      std::advance(__last2, std::distance(__first1, __last1));
      for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)
 {
   if (__scan != std::__find_if(__first1, __scan,
     __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))
     continue;

   auto __matches
     = std::__count_if(__first2, __last2,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));
   if (0 == __matches ||
       std::__count_if(__scan, __last1,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan))
       != __matches)
     return false;
 }
      return true;
    }
# 2276 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    constexpr
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2)
    {

     
     
     


      ;

      return std::__is_permutation(__first1, __last1, __first2,
       __gnu_cxx::__ops::__iter_equal_to_iter());
    }



# 2318 "D:/Programs/MinGW/include/c++/14.2.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    constexpr
    inline _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2,
    _BinaryPredicate __predicate)
    {

     
     
     


      ;
      ;

      return std::__search(__first1, __last1, __first2, __last2,
      __gnu_cxx::__ops::__iter_comp_iter(__predicate));
    }



}
# 44 "D:/Programs/MinGW/include/c++/14.2.0/array" 2 3
# 1 "D:/Programs/MinGW/include/c++/14.2.0/bits/range_access.h" 1 3
# 33 "D:/Programs/MinGW/include/c++/14.2.0/bits/range_access.h" 3
       
# 34 "D:/Programs/MinGW/include/c++/14.2.0/bits/range_access.h" 3






namespace std
{







  template<typename _Container>
    [[__nodiscard__, __gnu__::__always_inline__]]
    inline constexpr auto
    begin(_Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }






  template<typename _Container>
    [[__nodiscard__, __gnu__::__always_inline__]]
    inline constexpr auto
    begin(const _Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }






  template<typename _Container>
    [[__nodiscard__, __gnu__::__always_inline__]]
    inline constexpr auto
    end(_Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }






  template<typename _Container>
    [[__nodiscard__, __gnu__::__always_inline__]]
    inline constexpr auto
    end(const _Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }





  template<typename _Tp, size_t _Nm>
    [[__nodiscard__, __gnu__::__always_inline__]]
    inline constexpr _Tp*
    begin(_Tp (&__arr)[_Nm]) noexcept
    { return __arr; }






  template<typename _Tp, size_t _Nm>
    [[__nodiscard__, __gnu__::__always_inline__]]
    inline constexpr _Tp*
    end(_Tp (&__arr)[_Nm]) noexcept
    { return __arr + _Nm; }



  template<typename _Tp> class valarray;

  template<typename _Tp> _Tp* begin(valarray<_Tp>&) noexcept;
  template<typename _Tp> const _Tp* begin(const valarray<_Tp>&) noexcept;
  template<typename _Tp> _Tp* end(valarray<_Tp>&) noexcept;
  template<typename _Tp> const _Tp* end(const valarray<_Tp>&) noexcept;






  template<typename _Container>
    [[__nodiscard__, __gnu__::__always_inline__]]
    constexpr auto
    cbegin(const _Container& __cont) noexcept(noexcept(std::begin(__cont)))
      -> decltype(std::begin(__cont))
    { return std::begin(__cont); }






  template<typename _Container>
    [[__nodiscard__, __gnu__::__always_inline__]]
    constexpr auto
    cend(const _Container& __cont) noexcept(noexcept(std::end(__cont)))
      -> decltype(std::end(__cont))
    { return std::end(__cont); }






  template<typename _Container>
    [[__nodiscard__, __gnu__::__always_inline__]]
    inline constexpr auto
    rbegin(_Container& __cont) -> decltype(__cont.rbegin())
    { return __cont.rbegin(); }






  template<typename _Container>
    [[__nodiscard__, __gnu__::__always_inline__]]
    inline constexpr auto
    rbegin(const _Container& __cont) -> decltype(__cont.rbegin())
    { return __cont.rbegin(); }






  template<typename _Container>
    [[__nodiscard__, __gnu__::__always_inline__]]
    inline constexpr auto
    rend(_Container& __cont) -> decltype(__cont.rend())
    { return __cont.rend(); }






  template<typename _Container>
    [[__nodiscard__, __gnu__::__always_inline__]]
    inline constexpr auto
    rend(const _Container& __cont) -> decltype(__cont.rend())
    { return __cont.rend(); }






  template<typename _Tp, size_t _Nm>
    [[__nodiscard__]]
    inline constexpr reverse_iterator<_Tp*>
    rbegin(_Tp (&__arr)[_Nm]) noexcept
    { return reverse_iterator<_Tp*>(__arr + _Nm); }






  template<typename _Tp, size_t _Nm>
    [[__nodiscard__]]
    inline constexpr reverse_iterator<_Tp*>
    rend(_Tp (&__arr)[_Nm]) noexcept
    { return reverse_iterator<_Tp*>(__arr); }






  template<typename _Tp>
    [[__nodiscard__]]
    inline constexpr reverse_iterator<const _Tp*>
    rbegin(initializer_list<_Tp> __il) noexcept
    { return reverse_iterator<const _Tp*>(__il.end()); }






  template<typename _Tp>
    [[__nodiscard__]]
    inline constexpr reverse_iterator<const _Tp*>
    rend(initializer_list<_Tp> __il) noexcept
    { return reverse_iterator<const _Tp*>(__il.begin()); }






  template<typename _Container>
    [[__nodiscard__, __gnu__::__always_inline__]]
    inline constexpr auto
    crbegin(const _Container& __cont) -> decltype(std::rbegin(__cont))
    { return std::rbegin(__cont); }






  template<typename _Container>
    [[__nodiscard__, __gnu__::__always_inline__]]
    inline constexpr auto
    crend(const _Container& __cont) -> decltype(std::rend(__cont))
    { return std::rend(__cont); }
# 259 "D:/Programs/MinGW/include/c++/14.2.0/bits/range_access.h" 3
  template <typename _Container>
    [[nodiscard, __gnu__::__always_inline__]]
    constexpr auto
    size(const _Container& __cont) noexcept(noexcept(__cont.size()))
    -> decltype(__cont.size())
    { return __cont.size(); }




  template <typename _Tp, size_t _Nm>
    [[nodiscard, __gnu__::__always_inline__]]
    constexpr size_t
    size(const _Tp (&)[_Nm]) noexcept
    { return _Nm; }





  template <typename _Container>
    [[nodiscard, __gnu__::__always_inline__]]
    constexpr auto
    empty(const _Container& __cont) noexcept(noexcept(__cont.empty()))
    -> decltype(__cont.empty())
    { return __cont.empty(); }




  template <typename _Tp, size_t _Nm>
    [[nodiscard, __gnu__::__always_inline__]]
    constexpr bool
    empty(const _Tp (&)[_Nm]) noexcept
    { return false; }





  template <typename _Tp>
    [[nodiscard, __gnu__::__always_inline__]]
    constexpr bool
    empty(initializer_list<_Tp> __il) noexcept
    { return __il.size() == 0;}





  template <typename _Container>
    [[nodiscard, __gnu__::__always_inline__]]
    constexpr auto
    data(_Container& __cont) noexcept(noexcept(__cont.data()))
    -> decltype(__cont.data())
    { return __cont.data(); }





  template <typename _Container>
    [[nodiscard, __gnu__::__always_inline__]]
    constexpr auto
    data(const _Container& __cont) noexcept(noexcept(__cont.data()))
    -> decltype(__cont.data())
    { return __cont.data(); }





  template <typename _Tp, size_t _Nm>
    [[nodiscard, __gnu__::__always_inline__]]
    constexpr _Tp*
    data(_Tp (&__array)[_Nm]) noexcept
    { return __array; }





  template <typename _Tp>
    [[nodiscard, __gnu__::__always_inline__]]
    constexpr const _Tp*
    data(initializer_list<_Tp> __il) noexcept
    { return __il.begin(); }



  template<typename _Container>
    [[nodiscard, __gnu__::__always_inline__]]
    constexpr auto
    ssize(const _Container& __cont)
    noexcept(noexcept(__cont.size()))
    -> common_type_t<ptrdiff_t, make_signed_t<decltype(__cont.size())>>
    {
      using type = make_signed_t<decltype(__cont.size())>;
      return static_cast<common_type_t<ptrdiff_t, type>>(__cont.size());
    }

  template<typename _Tp, ptrdiff_t _Num>
    [[nodiscard, __gnu__::__always_inline__]]
    constexpr ptrdiff_t
    ssize(const _Tp (&)[_Num]) noexcept
    { return _Num; }


}
# 45 "D:/Programs/MinGW/include/c++/14.2.0/array" 2 3







# 1 "D:/Programs/MinGW/include/c++/14.2.0/bits/version.h" 1 3
# 47 "D:/Programs/MinGW/include/c++/14.2.0/bits/version.h" 3
       
# 48 "D:/Programs/MinGW/include/c++/14.2.0/bits/version.h" 3
# 53 "D:/Programs/MinGW/include/c++/14.2.0/array" 2 3

namespace std
{


  template<typename _Tp, size_t _Nm>
    struct __array_traits
    {
      using _Type = _Tp[_Nm];
      using _Is_swappable = __is_swappable<_Tp>;
      using _Is_nothrow_swappable = __is_nothrow_swappable<_Tp>;
    };

 template<typename _Tp>
   struct __array_traits<_Tp, 0>
   {

     struct _Type
     {

       __attribute__((__always_inline__,__noreturn__))
       _Tp& operator[](size_t) const noexcept { __builtin_trap(); }


       __attribute__((__always_inline__))
       constexpr explicit operator _Tp*() const noexcept { return nullptr; }
     };

     using _Is_swappable = true_type;
     using _Is_nothrow_swappable = true_type;
   };
# 99 "D:/Programs/MinGW/include/c++/14.2.0/array" 3
  template<typename _Tp, std::size_t _Nm>
    struct array
    {
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef const value_type* const_pointer;
      typedef value_type& reference;
      typedef const value_type& const_reference;
      typedef value_type* iterator;
      typedef const value_type* const_iterator;
      typedef std::size_t size_type;
      typedef std::ptrdiff_t difference_type;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;


      typename __array_traits<_Tp, _Nm>::_Type _M_elems;




      constexpr void
      fill(const value_type& __u)
      { std::fill_n(begin(), size(), __u); }

      constexpr void
      swap(array& __other)
      noexcept(__array_traits<_Tp, _Nm>::_Is_nothrow_swappable::value)
      { std::swap_ranges(begin(), end(), __other.begin()); }


      [[__gnu__::__const__, __nodiscard__]]
      constexpr iterator
      begin() noexcept
      { return iterator(data()); }

      [[__nodiscard__]]
      constexpr const_iterator
      begin() const noexcept
      { return const_iterator(data()); }

      [[__gnu__::__const__, __nodiscard__]]
      constexpr iterator
      end() noexcept
      { return iterator(data() + _Nm); }

      [[__nodiscard__]]
      constexpr const_iterator
      end() const noexcept
      { return const_iterator(data() + _Nm); }

      [[__gnu__::__const__, __nodiscard__]]
      constexpr reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }

      [[__nodiscard__]]
      constexpr const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }

      [[__gnu__::__const__, __nodiscard__]]
      constexpr reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }

      [[__nodiscard__]]
      constexpr const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }

      [[__nodiscard__]]
      constexpr const_iterator
      cbegin() const noexcept
      { return const_iterator(data()); }

      [[__nodiscard__]]
      constexpr const_iterator
      cend() const noexcept
      { return const_iterator(data() + _Nm); }

      [[__nodiscard__]]
      constexpr const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(end()); }

      [[__nodiscard__]]
      constexpr const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(begin()); }


      [[__nodiscard__, __gnu__::__const__, __gnu__::__always_inline__]]
      constexpr size_type
      size() const noexcept { return _Nm; }

      [[__nodiscard__, __gnu__::__const__, __gnu__::__always_inline__]]
      constexpr size_type
      max_size() const noexcept { return _Nm; }

      [[__nodiscard__, __gnu__::__const__, __gnu__::__always_inline__]]
      constexpr bool
      empty() const noexcept { return size() == 0; }


      [[__nodiscard__]]
      constexpr reference
      operator[](size_type __n) noexcept
      {
 ;
 return _M_elems[__n];
      }

      [[__nodiscard__]]
      constexpr const_reference
      operator[](size_type __n) const noexcept
      {

 ;

 return _M_elems[__n];
      }

      constexpr reference
      at(size_type __n)
      {
 if (__n >= _Nm)
   std::__throw_out_of_range_fmt(("array::at: __n (which is %zu) " ">= _Nm (which is %zu)")
                                 ,
     __n, _Nm);
 return _M_elems[__n];
      }

      constexpr const_reference
      at(size_type __n) const
      {


 return __n < _Nm ? _M_elems[__n]
   : (std::__throw_out_of_range_fmt(("array::at: __n (which is %zu) " ">= _Nm (which is %zu)")
                                    ,
        __n, _Nm),
      _M_elems[__n]);
      }

      [[__nodiscard__]]
      constexpr reference
      front() noexcept
      {
 ;
 return _M_elems[(size_type)0];
      }

      [[__nodiscard__]]
      constexpr const_reference
      front() const noexcept
      {

 ;

 return _M_elems[(size_type)0];
      }

      [[__nodiscard__]]
      constexpr reference
      back() noexcept
      {
 ;
 return _M_elems[_Nm - 1];
      }

      [[__nodiscard__]]
      constexpr const_reference
      back() const noexcept
      {

 ;

 return _M_elems[_Nm - 1];
      }

      [[__nodiscard__, __gnu__::__const__, __gnu__::__always_inline__]]
      constexpr pointer
      data() noexcept
      { return static_cast<pointer>(_M_elems); }

      [[__nodiscard__]]
      constexpr const_pointer
      data() const noexcept
      { return static_cast<const_pointer>(_M_elems); }
    };


  template<typename _Tp, typename... _Up>
    array(_Tp, _Up...)
      -> array<enable_if_t<(is_same_v<_Tp, _Up> && ...), _Tp>,
        1 + sizeof...(_Up)>;



  template<typename _Tp, std::size_t _Nm>
    [[__nodiscard__]]
    constexpr
    inline bool
    operator==(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return std::equal(__one.begin(), __one.end(), __two.begin()); }


  template<typename _Tp, size_t _Nm>
    [[nodiscard]]
    constexpr __detail::__synth3way_t<_Tp>
    operator<=>(const array<_Tp, _Nm>& __a, const array<_Tp, _Nm>& __b)
    {
      if constexpr (_Nm && __is_memcmp_ordered<_Tp>::__value)
 if (!std::__is_constant_evaluated())
   {
     constexpr size_t __n = _Nm * sizeof(_Tp);
     return __builtin_memcmp(__a.data(), __b.data(), __n) <=> 0;
   }

      for (size_t __i = 0; __i < _Nm; ++__i)
 {
   auto __c = __detail::__synth3way(__a[__i], __b[__i]);
   if (__c != 0)
     return __c;
 }
      return strong_ordering::equal;
    }
# 368 "D:/Programs/MinGW/include/c++/14.2.0/array" 3
  template<typename _Tp, std::size_t _Nm>
    constexpr
    inline


    __enable_if_t<__array_traits<_Tp, _Nm>::_Is_swappable::value>



    swap(array<_Tp, _Nm>& __one, array<_Tp, _Nm>& __two)
    noexcept(noexcept(__one.swap(__two)))
    { __one.swap(__two); }


  template<typename _Tp, std::size_t _Nm>
    __enable_if_t<!__array_traits<_Tp, _Nm>::_Is_swappable::value>
    swap(array<_Tp, _Nm>&, array<_Tp, _Nm>&) = delete;


  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    [[__nodiscard__]]
    constexpr _Tp&
    get(array<_Tp, _Nm>& __arr) noexcept
    {
      static_assert(_Int < _Nm, "array index is within bounds");
      return __arr._M_elems[_Int];
    }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    [[__nodiscard__]]
    constexpr _Tp&&
    get(array<_Tp, _Nm>&& __arr) noexcept
    {
      static_assert(_Int < _Nm, "array index is within bounds");
      return std::move(std::get<_Int>(__arr));
    }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    [[__nodiscard__]]
    constexpr const _Tp&
    get(const array<_Tp, _Nm>& __arr) noexcept
    {
      static_assert(_Int < _Nm, "array index is within bounds");
      return __arr._M_elems[_Int];
    }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    [[__nodiscard__]]
    constexpr const _Tp&&
    get(const array<_Tp, _Nm>&& __arr) noexcept
    {
      static_assert(_Int < _Nm, "array index is within bounds");
      return std::move(std::get<_Int>(__arr));
    }


  template<typename _Tp, size_t _Nm>
    [[nodiscard]]
    constexpr array<remove_cv_t<_Tp>, _Nm>
    to_array(_Tp (&__a)[_Nm])
    noexcept(is_nothrow_constructible_v<_Tp, _Tp&>)
    {
      static_assert(!is_array_v<_Tp>);
      static_assert(is_constructible_v<_Tp, _Tp&>);
      if constexpr (is_constructible_v<_Tp, _Tp&>)
 {
   if constexpr (is_trivially_copyable_v<_Tp>
     && is_trivially_default_constructible_v<_Tp>
     && is_copy_assignable_v<_Tp>)
     {
       array<remove_cv_t<_Tp>, _Nm> __arr;
       if (!__is_constant_evaluated() && _Nm != 0)
  __builtin_memcpy((void*)__arr.data(), (void*)__a, sizeof(__a));
       else
  for (size_t __i = 0; __i < _Nm; ++__i)
    __arr._M_elems[__i] = __a[__i];
       return __arr;
     }
   else
     return [&__a]<size_t... _Idx>(index_sequence<_Idx...>) {
       return array<remove_cv_t<_Tp>, _Nm>{{ __a[_Idx]... }};
     }(make_index_sequence<_Nm>{});
 }
      else
 __builtin_unreachable();
    }

  template<typename _Tp, size_t _Nm>
    [[nodiscard]]
    constexpr array<remove_cv_t<_Tp>, _Nm>
    to_array(_Tp (&&__a)[_Nm])
    noexcept(is_nothrow_move_constructible_v<_Tp>)
    {
      static_assert(!is_array_v<_Tp>);
      static_assert(is_move_constructible_v<_Tp>);
      if constexpr (is_move_constructible_v<_Tp>)
 {
   if constexpr (is_trivially_copyable_v<_Tp>
     && is_trivially_default_constructible_v<_Tp>
     && is_copy_assignable_v<_Tp>)
     {
       array<remove_cv_t<_Tp>, _Nm> __arr;
       if (!__is_constant_evaluated() && _Nm != 0)
  __builtin_memcpy((void*)__arr.data(), (void*)__a, sizeof(__a));
       else
  for (size_t __i = 0; __i < _Nm; ++__i)
    __arr._M_elems[__i] = __a[__i];
       return __arr;
     }
   else
     return [&__a]<size_t... _Idx>(index_sequence<_Idx...>) {
       return array<remove_cv_t<_Tp>, _Nm>{{ std::move(__a[_Idx])... }};
     }(make_index_sequence<_Nm>{});
 }
      else
 __builtin_unreachable();
    }





  template<typename _Tp, size_t _Nm>
    struct tuple_size<array<_Tp, _Nm>>
    : public integral_constant<size_t, _Nm> { };


  template<size_t _Ind, typename _Tp, size_t _Nm>
    struct tuple_element<_Ind, array<_Tp, _Nm>>
    {
      static_assert(_Ind < _Nm, "array index is in range");
      using type = _Tp;
    };


  template<typename _Tp, size_t _Nm>
    inline constexpr size_t tuple_size_v<array<_Tp, _Nm>> = _Nm;

  template<typename _Tp, size_t _Nm>
    inline constexpr size_t tuple_size_v<const array<_Tp, _Nm>> = _Nm;


  template<typename _Tp, size_t _Nm>
    struct __is_tuple_like_impl<array<_Tp, _Nm>> : true_type
    { };


}
# 6 "D:/Institute/Third_year/PZ_Networks/1_3/Client/Entities/Block/Block.h" 2


# 7 "D:/Institute/Third_year/PZ_Networks/1_3/Client/Entities/Block/Block.h"
class Entity_block : public Entity {
public:
    enum class Block_type : uint8_t {
        Top = 0,
        Body = 1,
        Finish = 2
    };

    inline static const std::array<const char*, 3> TEXTURE_PATH_MAP = {
        "assets/tiles/city/top.png",
        "assets/tiles/city/body.png",
        "assets/tiles/city/win.png"
    };

public:
    Entity_block (SDL_Texture* texture = nullptr, SDL_Point tile_position = {0, 0});


};
# 2 "D:/Institute/Third_year/PZ_Networks/1_3/Client/Entities/Block/Block.cpp" 2

Entity_block::Entity_block (SDL_Texture* texture, SDL_Point tile_position)
    : Entity(
        texture,
        {0, 0, Entity::TILE_SIZE, Entity::TILE_SIZE},
        {0, 0, Entity::TILE_SIZE, Entity::TILE_SIZE},
        SDL_FPoint(float(tile_position.x), float(tile_position.y)),
        {0, 0}
      ) {}
